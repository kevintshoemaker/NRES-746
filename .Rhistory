curve(dbeta(x,1,1),ylim=c(0,2),col="red")
#hist(rbeta(10000,1,1),freq=F,ylim=c(0,2),col="red")
data = 3
param.space <- seq(0,1,by=0.001)
likelihood <- dbinom(data,size=10,prob=param.space)
par(mai=c(1,1,0,1))
curve(dbeta(x,1,1),ylim=c(0,2),col="blue",ylab="Probability density",xlab="param.space")
points(param.space,likelihood*5,type="l",col="red",lwd=2)
axis(4,at=seq(0,2,by=0.4),labels = seq(0,0.5,by=.1))
mtext("Likelihood", side=4, col="red",line=3)
prior <- dbeta(param.space,shape1=1,shape2=1)
#prior
## weight the data likelihood by the prior
weighted.likelihood <- likelihood*prior      # Numerator for Bayes rule
## compute normalization constant
normalization.constant <- sum(weighted.likelihood)
## Posterior!!
posterior <- weighted.likelihood/normalization.constant   # this is Bayes' rule!
## Plot it out!
par(mai=c(1,1,0,1))
plot(param.space,prior,ylim=c(0,5),type="l",lwd=1,lty=2,col="blue",ylab="Probability Density",xlab="param.space")
points(param.space,posterior*length(param.space),type="l",col="blue",lwd=2,lty=1)  # convert posterior to probability density
points(param.space,likelihood*5,type="l",col="red",lwd=1)
axis(4,at=seq(0,2,by=0.4),labels = seq(0,0.5,by=.1))
mtext("Likelihood", side=4, col="red",line=3)
prior <- dbeta(param.space,shape1=15,shape2=5)
#prior
## weight the data likelihood by the prior
weighted.likelihood <- likelihood*prior
## compute normalization constant
normalization.constant <- sum(weighted.likelihood)
## Posterior!!
posterior <- weighted.likelihood/normalization.constant
## Plot it out!
par(mai=c(1,1,0,1))
plot(param.space,prior,ylim=c(0,5),type="l",lwd=1,lty=2,col="blue",ylab="Probability Density",xlab="param.space")
points(param.space,posterior*length(param.space),type="l",col="blue",lwd=2,lty=1)
points(param.space,likelihood*5,type="l",col="red",lwd=1)
axis(4,at=seq(0,2,by=0.4),labels = seq(0,0.5,by=.1))
mtext("Likelihood", side=4, col="red",line=3)
moredata <- c(3, 1, 6, 2, 3, 2, 6, 1, 3, 3)
## prior
prior <- dbeta(param.space,shape1=15,shape2=5)
## likelihood
likelihood <- sapply(param.space,function(t) prod(dbinom(moredata,size=10,prob=t)))
## weight the data likelihood by the prior
weighted.likelihood <- likelihood*prior
## compute normalization constant
normalization.constant <- sum(weighted.likelihood)
## Posterior!!
posterior <- weighted.likelihood/normalization.constant
## Plot it out!
par(mai=c(1,1,0,1))
plot(param.space,prior,ylim=c(0,10),type="l",lwd=1,lty=2,col="blue",ylab="Probability Density",xlab="param.space")
points(param.space,posterior*length(param.space),type="l",col="blue",lwd=2,lty=1)
points(param.space,likelihood*1e9,type="l",col="red",lwd=1)
axis(4,at=seq(0,6,by=1),labels = seq(0,6e-9,by=1e-9))
mtext("Likelihood", side=4, col="red",line=3)
likelihood <- dbinom(data,size=10,prob=param.space)
prior <- dbeta(param.space,shape1=150,shape2=50)
#prior
## weight the data likelihood by the prior
weighted.likelihood <- likelihood*prior
## compute normalization constant
normalization.constant <- sum(weighted.likelihood)
## Posterior!!
posterior <- weighted.likelihood/normalization.constant
## Plot it out!
par(mai=c(1,1,0,1))
plot(param.space,prior,ylim=c(0,15),type="l",lwd=1,lty=2,col="blue",ylab="Probability Density",xlab="param.space")
points(param.space,posterior*length(param.space),type="l",col="blue",lwd=2,lty=1)
points(param.space,likelihood*5,type="l",col="red",lwd=1)
axis(4,at=seq(0,2,by=0.4),labels = seq(0,0.5,by=.1))
mtext("Likelihood", side=4, col="red",line=3)
### PRIOR
prior_beta <- c(shape1=1,shape2=1)
curve(dbeta(x,prior_beta['shape1'],prior_beta['shape2']),ylim=c(0,5),ylab="Prob Density",col="blue",lwd=1,lty=2,xlab="param.space")
### POSTERIOR
curve(dbeta(x,prior_beta['shape1']+data,prior_beta['shape2']+(10-data)),ylim=c(0,4),ylab="Prob Density",col="blue",lwd=2,lty=1,xlab="param.space",add=T)
### PRIOR
prior_beta <- c(shape1=15,shape2=5)
curve(dbeta(x,prior_beta['shape1'],prior_beta['shape2']),ylim=c(0,5),ylab="Prob Density",col="blue",lwd=1,lty=2,xlab="param.space")
### POSTERIOR
curve(dbeta(x,prior_beta['shape1']+data,prior_beta['shape2']+(10-data)),ylim=c(0,4),ylab="Prob Density",col="blue",lwd=2,lty=1,xlab="param.space",add=T)
graphics.off()
### PRIOR
prior_beta <- c(shape1=150,shape2=50)
curve(dbeta(x,prior_beta['shape1'],prior_beta['shape2']),ylim=c(0,15),ylab="Prob Density",col="blue",lwd=1,lty=2,xlab="param.space")
### POSTERIOR
curve(dbeta(x,prior_beta['shape1']+data,prior_beta['shape2']+(10-data)),ylim=c(0,15),ylab="Prob Density",col="blue",lwd=2,lty=1,xlab="param.space",add=T)
graphics.off()
curve(dlnorm(x,4,1),from=0.001,to=200,ylab="prob density")  # use a lognormal distribution for example of skewed dist...
param.space2 <- seq(0.001,200,length=10000)
skewed.posterior <- dlnorm(param.space2,4,1)
mean <- mean(rlnorm(10000,4,1))
mode <- param.space2[which.max(skewed.posterior)]
plot(param.space2,skewed.posterior,type="l",ylab="prob density")
abline(v=c(mean,mode),col=gray(0.5),lwd=3,lty=2)   # add to plot
graphics.off()
### POSTERIOR
posterior <- dbeta(param.space,1+data,1+(10-data))
mean <- mean(rbeta(10000,1+data,1+(10-data)))
mode <- param.space[which.max(posterior)]
plot(param.space,posterior,type="l",col="blue",lwd=2)
abline(v=c(mean,mode),col=gray(0.5),lwd=3,lty=2)   # add to plot
graphics.off()
### POSTERIOR
curve(dbeta(x,1+data,1+(10-data)),ylim=c(0,4),ylab="Prob Density",col="blue",lwd=2,lty=1,xlab="param.space")
### CREDIBLE INTERVAL
credible.interval <- qbeta(c(0.025,0.975),1+data,1+(10-data))     # get the credible interval
abline(v=credible.interval,col=gray(0.5),lwd=3,lty=2)   # add to plot
library(emdbook)
MyxDat <- MyxoTiter_sum
Myx <- subset(MyxDat,grade==1)
head(Myx)
hist(Myx$titer,freq=FALSE)
hist(Myx$titer,freq=FALSE)
curve(dgamma(x,shape=40,scale=0.15),add=T,col="red")
GammaLikelihoodFunction <- function(params){
prod(dgamma(Myx$titer,shape=params['shape'],scale=params['scale']))
}
params <- c(40,0.15)
names(params) <- c("shape","scale")
params
GammaLikelihoodFunction(params)
##############
# define 2-D parameter space!
##############
shapevec <- seq(10,100,by=0.1)
scalevec <- seq(0.01,0.3,by=0.001)
##############
# define the likelihood surface across this grid within parameter space
##############
likelihood2D <- matrix(nrow=length(shapevec),ncol=length(scalevec))   # initialize storage variable
newparams <- params
for(i in 1:length(shapevec)){
newparams['shape'] <- shapevec[i]
for(j in 1:length(scalevec)){
newparams['scale'] <- scalevec[j]
likelihood2D[i,j] <- GammaLikelihoodFunction(newparams)
}
}
############
# Visualize the likelihood surface
############
image(x=shapevec,y=scalevec,z=likelihood2D,zlim=c(1e-70,1e-17),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=likelihood2D,levels=c(1e-18,1e-17),add=T)
pixelArea <- 0.0001  # for determining probability densities
##############
# define the prior probability surface across this grid within parameter space
##############
prior2D <- matrix(1, nrow=length(shapevec),ncol=length(scalevec))   # initialize prior
prior2D <- prior2D/length(prior2D)
############
# Visualize the 2-D prior distribution
############
image(x=shapevec,y=scalevec,z=prior2D,zlim=c(0,0.001),col=rainbow(10))
weighted.likelihood <- prior2D * likelihood2D    # numerator of Bayes rule
normalization.constant <- sum(weighted.likelihood)    # denominator of Bayes rule
posterior2D <- weighted.likelihood/normalization.constant
############
# Visualize the 2-D posterior distribution
############
image(x=shapevec,y=scalevec,z=(posterior2D/pixelArea),zlim=c(0,5),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=(posterior2D/pixelArea),levels=c(1:4),add=T,drawlabels=FALSE)
possible.contours <- data.frame(contour = seq(0.13e-4,1e-4,length=100), quantile = NA)
i=1
for(i in 1:nrow(possible.contours)){
ndx <- which(posterior2D<possible.contours$contour[i],arr.ind = T)
possible.contours$quantile[i] <- sum(posterior2D[ndx])
}
head(possible.contours,10)
q95 <- 1.739394e-05
image(x=shapevec,y=scalevec,z=posterior2D,zlim=c(0.5e-11,5e-4),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=posterior2D,levels=q95,add=T,lwd=3,col="red",drawlabels=FALSE)
image(x=shapevec,y=scalevec,z=posterior2D,zlim=c(0.5e-11,5e-4),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=posterior2D,levels=q95,add=T,lwd=3,col="red",drawlabels=FALSE)
meanshape <- sum(shapevec*posterior2D)
meanscale <- sum(scalevec*posterior2D)
points(meanshape,meanscale,pch=20,cex=2,col="red")
marginal.dist.shape <- apply(posterior2D,1,mean)
plot(shapevec,(marginal.dist.shape/sum(marginal.dist.shape))/0.1,type="l",lwd=2,col="blue",ylab="probability density",main="Posterior probability")
abline(v=meanshape)
marginal.dist.scale <- apply(posterior2D,2,mean)
plot(scalevec,(marginal.dist.scale/sum(marginal.dist.scale))/0.001,type="l",lwd=2,col="blue",ylab="probability density",main="Posterior probability")
abline(v=meanscale)
meanshape
meanscale
sum(posterior2D)
posterior2D[1:10,1:10]
shape <- rep(shapevec,times=length(scalevec))
?sample
SampleFromPosterior <- function(n){
shape <- rep(shapevec,times=length(scalevec))
scale <- rep(scalevec,each=length(shapevec))
jointparams <- data.frame(shape=shape,scale=scale)
probs <- as.vector(posterior2D)
samples <- sample(1:length(probs),size=n,replace=TRUE,weight=probs)
jointparams[samples,]
}
samples<-SampleFromPosterior(10000)
n=10000
shape <- rep(shapevec,times=length(scalevec))
scale <- rep(scalevec,each=length(shapevec))
jointparams <- data.frame(shape=shape,scale=scale)
probs <- as.vector(posterior2D)
sample(1:length(probs),size=n,replace=TRUE,weight=probs)
probs
as.vector(posterior2D)
str(posterior2D)
sum(posterior2D)
c(1:length(probs))
SampleFromPosterior <- function(n){
shape <- rep(shapevec,times=length(scalevec))
scale <- rep(scalevec,each=length(shapevec))
jointparams <- data.frame(shape=shape,scale=scale)
probs <- as.vector(posterior2D)
samples <- sample(c(1:length(probs)),size=n,replace=TRUE,prob=probs)
jointparams[samples,]
}
samples<-SampleFromPosterior(n=10000)
par(mfrow=c(3,2))
plot(samples,col=1:10000)
samples<-SampleFromPosterior(n=10000)
par(mfrow=c(3,2))
plot(samples,col=1:10000)
plot(samples,type="l")
plot(ts(samples[,1]))
plot(ts(samples[,2]))
hist(samples[,1],40)
hist(samples[,2],40)
par(mfrow=c(1,1))
rbvn<-function (n, rho)   #function for drawing an arbitrary number of independent samples from the bivariate standard normal distribution.
{
x <- rnorm(n, 0, 1)
y <- rnorm(n, rho * x, sqrt(1 - rho^2))
cbind(x, y)
}
bvn<-rbvn(10000,0.98)
par(mfrow=c(3,2))
plot(bvn,col=1:10000)
plot(bvn,type="l")
plot(ts(bvn[,1]))
plot(ts(bvn[,2]))
hist(bvn[,1],40)
hist(bvn[,2],40)
par(mfrow=c(1,1))
install.packages("mvtnorm")
library(mvtnorm)
library(mvtnorm)
matrix(c(1,rho,rho,1),ncol=2)
rho=0.98
matrix(c(1,rho,rho,1),ncol=2)
dmvnorm(c(newx,newy),sigma = matrix(c(1,rho,rho,1),ncol=2))
x <- 0
y <- 0
prev <- dmvnorm(c(x,y),sigma = matrix(c(1,rho,rho,1),ncol=2))
prev
matrix(c(1,rho,rho,1),ncol=2)
prev <- dmvnorm(c(x,y),mean=c(0,0),sigma = matrix(c(1,rho,rho,1),ncol=2))
prev
mat <- matrix(ncol = 2, nrow = n)   # matrix for storing the random samples
y <- 0
prev <- dmvnorm(c(x,y),mean=c(0,0),sigma = matrix(c(1,rho,rho,1),ncol=2))
mat[1, ] <- c(x, y)        # initialize the markov chain
i=1
newx <- rnorm(1,x,1)     # make a jump
newx
newy <- rnorm(1,y,1)
newy
newprob <- dmvnorm(c(newx,newy),sigma = matrix(c(1,rho,rho,1),ncol=2))    # assess whether the new jump is good
ratio <- newprob/prev
ratio
newprob/prev
prob.accept <- min(1,ratio)     # decide whether to accept the new jump!
prob.accept
rand <- runif(1)
rand<=prob.accept
metropolisHastings <- function (n, rho=0.98){    # a MCMC sampler implementation of a bivariate random number generator
mat <- matrix(ncol = 2, nrow = n)   # matrix for storing the random samples
x <- 0
y <- 0
prev <- dmvnorm(c(x,y),mean=c(0,0),sigma = matrix(c(1,rho,rho,1),ncol=2))
mat[1, ] <- c(x, y)        # initialize the markov chain
counter <- 1
while(counter<=n) {
newx <- rnorm(1,x,0.5)     # make a jump
newy <- rnorm(1,y,0.5)
newprob <- dmvnorm(c(newx,newy),sigma = matrix(c(1,rho,rho,1),ncol=2))    # assess whether the new jump is good!
ratio <- newprob/prev
prob.accept <- min(1,ratio)     # decide whether to accept the new jump!
rand <- runif(1)
if(rand<=prob.accept){
x=newx;y=newy
mat[counter,] <- c(x,y)
counter=counter+1
prev <- newprob
}
}
return(mat)
}
bvn<-metropolisHastings(10000,0.98)
par(mfrow=c(3,2))
plot(bvn,col=1:10000)
plot(bvn,type="l")
plot(ts(bvn[,1]))
plot(ts(bvn[,2]))
hist(bvn[,1],40)
hist(bvn[,2],40)
par(mfrow=c(1,1))
rbvn<-function (n, rho)   #function for drawing an arbitrary number of independent samples from the bivariate standard normal distribution.
{
x <- rnorm(n, 0, 1)
y <- rnorm(n, rho * x, sqrt(1 - rho^2))
cbind(x, y)
}
bvn<-rbvn(10000,0.98)
par(mfrow=c(3,2))
plot(bvn,col=1:10000)
plot(bvn,type="l")
plot(ts(bvn[,1]))
plot(ts(bvn[,2]))
hist(bvn[,1],40)
hist(bvn[,2],40)
par(mfrow=c(1,1))
newguess <- newGuess(startingvals)
newguess
PosteriorRatio(startingvals,newguess)   # difference in posterior ratio
rbvn<-function (n, rho){  #function for drawing an arbitrary number of independent samples from the bivariate standard normal distribution.
x <- rnorm(n, 0, 1)
y <- rnorm(n, rho * x, sqrt(1 - rho^2))
cbind(x, y)
}
bvn<-rbvn(10000,0.98)
par(mfrow=c(3,2))
plot(bvn,col=1:10000)
plot(bvn,type="l")
plot(ts(bvn[,1]))
plot(ts(bvn[,2]))
hist(bvn[,1],40)
hist(bvn[,2],40)
par(mfrow=c(1,1))
prev_shape
prev_shape=75
GammaLikelihoodFunction(c(shape=prev_shape,scale=prev_scale))
prev_scale=0.28
GammaLikelihoodFunction(c(shape=prev_shape,scale=prev_scale))
GibbsSample.myxo <-function (prev_shape=65, prev_scale=0.28){
GammaLikelihoodFunction(c(shape=prev_shape,scale=prev_scale))
shape <-         # sample from shape conditional on scale
scale <-         # sample from scale conditional on shape
return(c(shape,scale))
}
GammaLikelihoodFunction(c(shape=prev_shape,scale=prev_scale))
prev_shape=50
prev_scale=0.15
GammaLikelihoodFunction(c(shape=prev_shape,scale=prev_scale))
View(GammaLikelihoodFunction)
thinnedMCMC
par(mfrow=c(3,2))
plot(thinnedMCMCs,col=1:10000)
par(mfrow=c(3,2))
plot(thinnedMCMC,col=1:10000)
plot(thinnedMCMC,type="l")
plot(ts(thinnedMCMC[,1]))
plot(ts(thinnedMCMC[,2]))
hist(thinnedMCMC[,1],40)
hist(thinnedMCMC[,2],40)
par(mfrow=c(1,1))
sink("BUGSmodel.txt")
cat("
model {
#############
# LIKELIHOOD
############
for(obs in 1:n.observations){
titer[obs] ~ dgamma(shape,rate)
}
#############
# PRIORS
############
shape ~ dgamma(0.001,0.001)
scale ~ dgamma(0.01,0.01)
rate <- 1/scale
}
")
sink()
GammaLikelihoodFunction()
GammaLikelihoodFunction
myx.data.for.bugs <- list(
titer = Myx$titer,
n.observations = length(Myx$titer)
)
myx.data.for.bugs <- list(
titer = Myx$titer,
n.observations = length(Myx$titer)
)
myx.data.for.bugs
init.vals.for.bugs <- function(){
list(
shape=runif(1,20,100),
scale=runif(1,0.05,0.3)
)
}
init.vals.for.bugs()
init.vals.for.bugs()
init.vals.for.bugs()
library(R2jags)
install.packages("R2jags")
library(R2jags)
sink("BUGSmodel.txt")
cat("
model {
#############
# LIKELIHOOD
############
for(obs in 1:n.observations){
titer[obs] ~ dgamma(shape,rate)
}
#############
# PRIORS
############
shape ~ dgamma(0.001,0.001)
scale ~ dgamma(0.01,0.01)
rate <- 1/scale
}
")
sink()
myx.data.for.bugs <- list(
titer = Myx$titer,
n.observations = length(Myx$titer)
)
myx.data.for.bugs
init.vals.for.bugs <- function(){
list(
shape=runif(1,20,100),
scale=runif(1,0.05,0.3)
)
}
init.vals.for.bugs()
init.vals.for.bugs()
init.vals.for.bugs()
?jags
library(R2jags)
params.to.store <- c("shape","scale")
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,model.file="BUGSmodel.txt" )
summary(jags.fit)
plot(jags.fit)
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
xyplot(jagsfit.mcmc)
library(coda)
xyplot(jagsfit.mcmc)
?xyplot
densityplot(jagsfit.mcmc)
plot(jagsfit.mcmc)
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,model.file="BUGSmodel.txt",n.chains = 3 )
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
plot(jagsfit.mcmc)
summary(jagsfit.mcmc)
gelman.diag(jagsfit.mcmc)
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=50000,model.file="BUGSmodel.txt",n.chains = 3, burn.in=10000,n.thin = 20)
?jags
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,model.file="BUGSmodel.txt",n.chains = 3,n.burnin = 0 )
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=50000,model.file="BUGSmodel.txt",n.chains = 3, n.burnin=10000,n.thin = 20)
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
gelman.diag(jagsfit.mcmc)
install.packages("rmarkdown")
install.packages("rmarkdown")
install.packages("rmarkdown")
install.packages("rmarkdown")
install.packages("rmarkdown")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
sink("BUGSmodel.txt")
cat("
model {
#############
# LIKELIHOOD
############
for(obs in 1:n.observations){
titer[obs] ~ dgamma(shape,rate)
}
#############
# PRIORS
############
shape ~ dgamma(0.001,0.001)
scale ~ dgamma(0.01,0.01)
rate <- 1/scale
}
")
sink()
myx.data.for.bugs <- list(
titer = Myx$titer,
n.observations = length(Myx$titer)
)
myx.data.for.bugs
library(R2jags)
library(coda)
params.to.store <- c("shape","scale")
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,model.file="BUGSmodel.txt",n.chains = 3,n.burnin = 0 )
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
jags.fit <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=50000,model.file="BUGSmodel.txt",n.chains = 3, n.burnin=10000,n.thin = 20)
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
gelman.diag(jagsfit.mcmc)
