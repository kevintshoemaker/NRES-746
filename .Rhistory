isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("GLMM.Rmd")
rmd2rscript("GLMM2023/GLMM.Rmd")
unlink("GLMM_cache", recursive = TRUE)
rmd2rscript("GLMM.Rmd")
rmd2rscript("GAMs_Lab.Rmd")
rmd2rscript("GLMM.Rmd")
##Load correct packages
library(terra)
##download the photo you would like to raster
drone<-terra::rast("SWRS_Plot771_1.JPG")
rm(list=ls())
df <- read.csv("rsf_lab.csv")
df <- na.omit(df)
mean.pfg <- mean(df$pfg)
sd.pfg <-  sd(df$pfg)
df$pfg.s <- (df$pfg-mean.pfg)/sd.pfg
mean.afg <- mean(df$afg)
sd.afg <-  sd(df$afg)
df$afg.s <- (df$afg-mean.afg)/sd.afg
mean.shrub <- mean(df$shrub)
sd.shrub <-  sd(df$shrub)
df$shrub.s <- (df$shrub-mean.shrub)/sd.shrub
mean.elev <- mean(df$elevation)
sd.elev <-  sd(df$elevation)
df$elev.s <- (df$elevation-mean.elev)/sd.elev
mean.jul <- mean(df$JulianDay)
sd.jul <-  sd(df$JulianDay)
df$jul.s <- (df$JulianDay-mean.jul)/sd.jul
mean.tree <- mean(df$tree)
sd.tree <-  sd(df$tree)
df$tree.s <- (df$tree-mean.tree)/sd.tree
df$ID2 <- as.numeric(as.factor(df$ID))
df$Sex <- as.factor(df$Sex)
hist(df$jul.s)
library(ResourceSelection)
library(lubridate)
library(tidyr)
library(terra)
library(spdep)
library(sf)
library(dplyr)
library(sp)
library(adehabitatHR)
library(scales)
library(raster)
#library(rgdal) # Removed from CRAN in October! Replaced by terra.
library(ggplot2)
library(amt, quietly = T)
library(raster, quietly = T)
library(glmmTMB)
rm(list=ls())
df <- read.csv("rsf_lab.csv")
df <- na.omit(df)
mean.pfg <- mean(df$pfg)
sd.pfg <-  sd(df$pfg)
df$pfg.s <- (df$pfg-mean.pfg)/sd.pfg
mean.afg <- mean(df$afg)
sd.afg <-  sd(df$afg)
df$afg.s <- (df$afg-mean.afg)/sd.afg
mean.shrub <- mean(df$shrub)
sd.shrub <-  sd(df$shrub)
df$shrub.s <- (df$shrub-mean.shrub)/sd.shrub
mean.elev <- mean(df$elevation)
sd.elev <-  sd(df$elevation)
df$elev.s <- (df$elevation-mean.elev)/sd.elev
mean.jul <- mean(df$JulianDay)
sd.jul <-  sd(df$JulianDay)
df$jul.s <- (df$JulianDay-mean.jul)/sd.jul
mean.tree <- mean(df$tree)
sd.tree <-  sd(df$tree)
df$tree.s <- (df$tree-mean.tree)/sd.tree
df$ID2 <- as.numeric(as.factor(df$ID))
df$Sex <- as.factor(df$Sex)
hist(df$jul.s)
hist(df$elev.s)
hist(df$shrub.s)
hist(df$pfg.s)
hist(df$afg.s)
## Build your GLMM::   --------------------
spring_mod0 <- glmmTMB(Used ~ Sex + jul.s + pfg.s + (1|ID),
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(spring_mod0)
fullmod <- glmmTMB(Used ~ Sex + jul.s + poly(pfg.s,2) + poly(afg.s,2) + poly(elev,s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
fullmod <- glmmTMB(Used ~ Sex + jul.s + poly(pfg.s,2) + poly(afg.s,2) + poly(elev.s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
fullmod <- glmmTMB(Used ~ Sex + jul.s + poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(spring_mod0)
summary(fullmod)
library(effects)
effects::effect("elev",fullmod)
effects::effect("elev.s",fullmod)
plot(effects::effect("elev.s",fullmod))
plot(effects::effect("afg.s",fullmod))
plot(effects::effect("jul.s",fullmod))
summary(fullmod)
plot(effects::effect("afg.s",fullmod))
plot(effects::effect("pfg.s",fullmod))
plot(effects::effect("elev.s",fullmod))
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
plot(effects::effect("elev.s",fullmod))
plot(effects::effect("elev.s",fullmod))
summary(fullmod)
sims <- simulateResiduals(fullmod)
library(DHARMa)
sims <- simulateResiduals(fullmod)
testResiduals(sims)
summary(fullmod)
df$ID
df$ID <- as.factor(df$ID)
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID) + (0+poly(elev.s,2)|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(fullmod)
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID) + (0+poly(elev.s,2)|ID) + (0+poly(afg.s,2)|ID) + (0+afg.s|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID) + (0+poly(elev.s,2)|ID) + (0+poly(pfg.s,2)|ID) + (0+afg.s|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(fullmod)
library(effects)
plot(effects::effect("elev.s",fullmod))
plot(effects::effect("afg.s",fullmod))
plot(effects::effect("jul.s",fullmod))
# plot(effects::effect("jul.s",fullmod))
plot(effects::effect("pfg.s",fullmod))
library(DHARMa)
sims <- simulateResiduals(fullmod)
testResiduals(sims)
ranef(fullmod)
elevs <- seq(min(df$elev.s),max(elev.s),length=100)
elevs <- seq(min(df$elev.s),max(df$elev.s),length=100)
elevs
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[1],levels=levels(df$ID))
)
predict(fullmod,newdf,type="response")
preds <- predict(fullmod,newdf,type="response")
plot(elevs,preds,type="l")
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[2],levels=levels(df$ID))
)
preds <- predict(fullmod,newdf,type="response")
# plot(elevs,preds,type="l")
lines(elevs,preds)
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[3],levels=levels(df$ID))
)
preds <- predict(fullmod,newdf,type="response")
# plot(elevs,preds,type="l")
lines(elevs,preds)
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[4],levels=levels(df$ID))
)
preds <- predict(fullmod,newdf,type="response")
# plot(elevs,preds,type="l")
lines(elevs,preds)
library(rpart)          # library to plot a decision tree.
library(randomForest)   # RandomForest library
library(rfUtilities)    # library to use utility functions on Random forest model to analyse model perfomance and evaluation.
data(iris)
head(iris)
tree <- rpart(Species~.,method = 'class',control = rpart.control(cp=0,minsplit = 1),data = iris)
par(xpd= NA) # setting the plot parameter not to expand(To avoid text being cut out at the corners)
plot(tree)
# adding the text to the tree
# use.n =T to plot the number of obs assosicated with each class at each node.
text(tree,use.n = T)
tree <- rpart(Species~.,method = 'class',control = rpart.control(cp=0.05,minsplit = 1),data = iris)
set.seed(1234) #setting the intial value for Random number generator
rf <- randomForest(Species ~ .,data = iris,mtry = 4,ntrees = 100,proximity=TRUE,importance= TRUE )
print(rf)
print(rf)
plot(rf) # plotting OOB error rate of all three species based on no.of tree generated by Random Forest
?randomForest
knitr::opts_chunk$set(echo = TRUE, message = F)
library(geoR) # this may be obsolete soon
library(dplyr)
library(sf)
library(leaflet)
library(viridis)
library(terra)
library(geodata)
library(geoR) # this may be obsolete soon
library(INLA)
data(gambia)
library(geoR) # this may be obsolete soon
library(dplyr)
library(sf)
library(leaflet)
library(viridis)
library(terra)
library(geodata)
library(INLA)
library(randomForest)
library(rfUtilities)
library(randomForest)
library(rfUtilities)
my_data = read.csv("C:/Users/mahip/Downloads/ET_data.csv")
library(randomForest)
library(rfUtilities)
my_data = read.csv("ET_data.csv")
my_data = na.omit(my_data)
# Initialize empty training and test sets
train_set <- data.frame()
test_set <- data.frame()
# Specify the number of rows to include in each set alternately
rows_per_set <- 3
# Create alternating sets
for (i in seq(1, nrow(my_data), by = rows_per_set * 2)) {
test_indices <- i:(i + rows_per_set - 1)
train_indices <- (i + rows_per_set):(i + rows_per_set * 2 - 1)
test_set <- rbind(test_set, my_data[test_indices, , drop = FALSE])
train_set <- rbind(train_set, my_data[train_indices, , drop = FALSE])
}
train_set <- na.omit(train_set)
set.seed(123)
rf <- randomForest(data = train_set ,x = train_set[,c(1,3:8)],y = train_set$ET,ntree = 600,mtry = 2,importance = TRUE,proximity = TRUE)
print(rf)
plot(rf)
set.seed(123)
tuneRF(y = train_set$ET,x = train_set[,c(1,3:8)],,mtryStart = 2,stepFactor = 3,trace = TRUE,plot = TRUE, ntreeTry = 600 )
cv <- rf.crossValidation(x= rf, xdata = my_data[,c(1,3:8)],ydata = my_data$ET,p = 0.2, n = 99, seed = 123)
cv <- rf.crossValidation(x= rf, xdata = my_data[,c(1,3:8)],ydata = my_data$ET,p = 0.2, n = 99, seed = 123)
mean(cv$fit.var.exp)
mean(cv$fit.mse)
mean(cv$y.rmse)
mean(cv$y.mbe)
mean(cv$y.mae)
mean(cv$D)
mean(cv$p.val)
varImpPlot(rf)
library(randomForest)
library(rfUtilities)
my_data = read.csv('path_to_csv')
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(INLA)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("SpatialRegression.Rmd")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("SpatialRegression.Rmd")
