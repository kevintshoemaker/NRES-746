table(slugs$slugs,slugs$field)
barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), col=c('black','red'), legend.text=TRUE, xlab='# of slugs', ylab='frequency')
my.aic<-function(output) -2*(-output$minimum) + 2*length(output$estimate)
unlink("LAB5_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
slugs<-read.table( 'http://www.bio.ic.ac.uk/research/mjcraw/statcomp/data/slugsurvey.txt', header=TRUE)
head(slugs)
# write.csv(slugs,file = "slugs.csv", row.names = F)
table(slugs$slugs,slugs$field)
table(slugs$slugs,slugs$field)
barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), col=c('black','red'), legend.text=TRUE, xlab='# of slugs', ylab='frequency')
out <- table(slugs$slugs,slugs$field)
out
barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), col=c('black','red'), legend.text=TRUE, xlab='# of slugs', ylab='frequency')
out2 <- nlm(function(p) poi.2(slugs,p),c(1.2,1))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
slugs<-read.table( 'http://www.bio.ic.ac.uk/research/mjcraw/statcomp/data/slugsurvey.txt', header=TRUE)
head(slugs)
# write.csv(slugs,file = "slugs.csv", row.names = F)
out <- table(slugs$slugs,slugs$field)
out
barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), col=c('black','red'), legend.text=TRUE, xlab='# of slugs', ylab='frequency')
poi.1<-function(data,p) -sum(log(dpois(data$slugs,lambda=p)))
mean(slugs$slugs)
out1 <- nlm(function(p) poi.1(slugs,p),2)
out1
as.numeric(as.factor(slugs$field))
poi.2<-function(data,p) {
field.dummy<-as.numeric(as.factor(slugs$field))-1
mylambda<-p[1]+p[2]*field.dummy
negloglike<- -sum(dpois(data$slugs,lambda=mylambda,log=T))
return(negloglike)
}
tapply(slugs$slugs,slugs$field,mean)
out2 <- nlm(function(p) poi.2(slugs,p),c(1.2,1))
out2
out1$minimum
out2$minimum
my.aic<-function(output) -2*(-output$minimum) + 2*length(output$estimate)
my.aic(out1)
my.aic(out2)
zip1<-function(data,p) {
lambda<-p[1]
theta<-p[2]
zero.term<-sum(log(theta+(1-theta)* dpois(data$slugs[data$slugs==0], lambda)))
nonzero.term<-sum(log((1- theta)* dpois(data$slugs[data$slugs>0], lambda)))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
slugs
mod1 <- glm(slugs~1, data=slugs, family=poisson())
mod2 <- glm(slugs~field, data=slugs, family=poisson())
logLik(mod1)
out1$minimum
logLik(mod2)
mod2 <- glm(slugs~field, data=slugs, family=poisson())
mod2
my.aic<-function(output) -2*(-output$minimum) + 2*length(output$estimate)
my.aic(out1)
my.aic(out2)
my.aic(out1)
aic(mod1)
AIC(mod1)
my.aic(out1)
AIC(mod1,mod2)
zip1<-function(data,p) {
lambda<-p[1]
theta<-p[2]
zero.term<-sum(log(theta+(1-theta)* dpois(data$slugs[data$slugs==0], lambda)))   # stochastic process #1
nonzero.term<-sum(log((1- theta)* dpois(data$slugs[data$slugs>0], lambda)))      # stochastic process #2
negloglike<- -(zero.term+nonzero.term)
negloglike
}
zip1<-function(data,p) {
lambda<-p[1]
theta<-p[2]
zero.term<-sum(log(theta+(1-theta)* dpois(data$slugs[data$slugs==0], lambda)))   # stochastic process #1
nonzero.term<-sum(log((1- theta)* dpois(data$slugs[data$slugs>0], lambda)))      # stochastic process #2
negloglike<- -(zero.term+nonzero.term)
negloglike
}
library(glmmTMB)
library(DHARMa)
mean(slugs$slugs[slugs$slugs>0])
table(slugs$slugs)[1]/sum(table(slugs$slugs))
out7 <- nlm(function(p) zip1(slugs,p),c(3,.4))
out7
?glmmTMB
mod7 <- glmmTMB(slugs~1,slugs,family=poisson(),ziformula = ~1)
out7
logLik(mod7)
logLik(mod1)
my.aic(out7)
AIC(mod1,mod2,mod7)
# different lambda, same theta
zip2<-function(data,p) {
field.dummy<-as.numeric(as.factor(slugs$field))-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
zero.term<-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
nonzero.term<-sum(ifelse(data$slugs>0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
# different lambda, same theta
zip2<-function(data,p) {
field.dummy<-as.numeric(as.factor(slugs$field))-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
zero.term<-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
nonzero.term<-sum(ifelse(data$slugs>0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
mean(slugs$slugs[slugs$slugs>0])
table(slugs$slugs)[1]/sum(table(slugs$slugs))
out7 <- nlm(function(p) zip1(slugs,p),c(3,.4))
out7
mod7 <- glmmTMB(slugs~1,slugs,family=poisson(),ziformula = ~1)
mod7 <- glmmTMB(slugs~1,slugs,family=poisson(),ziformula = ~1)
logLik(mod7)
# different lambda, same theta
zip2<-function(data,p) {
field.dummy<-as.numeric(as.factor(slugs$field))-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
zero.term<-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
nonzero.term<-sum(ifelse(data$slugs>0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
zip2.alt<-function(data,p) {
field.dummy<-as.numeric(slugs$field)-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
negloglike<- -sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),log((1-theta)*dpois(data$slugs,lambda=mylambda))))
negloglike
}
tapply(slugs$slugs[slugs$slugs>0],slugs$field[slugs$slugs>0],mean)
out8 <- nlm(function(p) zip2(slugs,p),c(3.4,.42,-.4))
zip2.alt<-function(data,p) {
field.dummy<-as.numeric(as.factor(slugs$field))-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
negloglike<- -sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),log((1-theta)*dpois(data$slugs,lambda=mylambda))))
negloglike
}
tapply(slugs$slugs[slugs$slugs>0],slugs$field[slugs$slugs>0],mean)
out8 <- nlm(function(p) zip2(slugs,p),c(3.4,.42,-.4))
zip2
out8
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("LAB5.Rmd")
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE10.Rmd")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("GLMM.Rmd")
rmd2rscript("GLMM2023/GLMM.Rmd")
unlink("GLMM_cache", recursive = TRUE)
rmd2rscript("GLMM.Rmd")
rmd2rscript("GAMs_Lab.Rmd")
rmd2rscript("GLMM.Rmd")
##Load correct packages
library(terra)
##download the photo you would like to raster
drone<-terra::rast("SWRS_Plot771_1.JPG")
rm(list=ls())
df <- read.csv("rsf_lab.csv")
df <- na.omit(df)
mean.pfg <- mean(df$pfg)
sd.pfg <-  sd(df$pfg)
df$pfg.s <- (df$pfg-mean.pfg)/sd.pfg
mean.afg <- mean(df$afg)
sd.afg <-  sd(df$afg)
df$afg.s <- (df$afg-mean.afg)/sd.afg
mean.shrub <- mean(df$shrub)
sd.shrub <-  sd(df$shrub)
df$shrub.s <- (df$shrub-mean.shrub)/sd.shrub
mean.elev <- mean(df$elevation)
sd.elev <-  sd(df$elevation)
df$elev.s <- (df$elevation-mean.elev)/sd.elev
mean.jul <- mean(df$JulianDay)
sd.jul <-  sd(df$JulianDay)
df$jul.s <- (df$JulianDay-mean.jul)/sd.jul
mean.tree <- mean(df$tree)
sd.tree <-  sd(df$tree)
df$tree.s <- (df$tree-mean.tree)/sd.tree
df$ID2 <- as.numeric(as.factor(df$ID))
df$Sex <- as.factor(df$Sex)
hist(df$jul.s)
library(ResourceSelection)
library(lubridate)
library(tidyr)
library(terra)
library(spdep)
library(sf)
library(dplyr)
library(sp)
library(adehabitatHR)
library(scales)
library(raster)
#library(rgdal) # Removed from CRAN in October! Replaced by terra.
library(ggplot2)
library(amt, quietly = T)
library(raster, quietly = T)
library(glmmTMB)
rm(list=ls())
df <- read.csv("rsf_lab.csv")
df <- na.omit(df)
mean.pfg <- mean(df$pfg)
sd.pfg <-  sd(df$pfg)
df$pfg.s <- (df$pfg-mean.pfg)/sd.pfg
mean.afg <- mean(df$afg)
sd.afg <-  sd(df$afg)
df$afg.s <- (df$afg-mean.afg)/sd.afg
mean.shrub <- mean(df$shrub)
sd.shrub <-  sd(df$shrub)
df$shrub.s <- (df$shrub-mean.shrub)/sd.shrub
mean.elev <- mean(df$elevation)
sd.elev <-  sd(df$elevation)
df$elev.s <- (df$elevation-mean.elev)/sd.elev
mean.jul <- mean(df$JulianDay)
sd.jul <-  sd(df$JulianDay)
df$jul.s <- (df$JulianDay-mean.jul)/sd.jul
mean.tree <- mean(df$tree)
sd.tree <-  sd(df$tree)
df$tree.s <- (df$tree-mean.tree)/sd.tree
df$ID2 <- as.numeric(as.factor(df$ID))
df$Sex <- as.factor(df$Sex)
hist(df$jul.s)
hist(df$elev.s)
hist(df$shrub.s)
hist(df$pfg.s)
hist(df$afg.s)
## Build your GLMM::   --------------------
spring_mod0 <- glmmTMB(Used ~ Sex + jul.s + pfg.s + (1|ID),
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(spring_mod0)
fullmod <- glmmTMB(Used ~ Sex + jul.s + poly(pfg.s,2) + poly(afg.s,2) + poly(elev,s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
fullmod <- glmmTMB(Used ~ Sex + jul.s + poly(pfg.s,2) + poly(afg.s,2) + poly(elev.s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
fullmod <- glmmTMB(Used ~ Sex + jul.s + poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(spring_mod0)
summary(fullmod)
library(effects)
effects::effect("elev",fullmod)
effects::effect("elev.s",fullmod)
plot(effects::effect("elev.s",fullmod))
plot(effects::effect("afg.s",fullmod))
plot(effects::effect("jul.s",fullmod))
summary(fullmod)
plot(effects::effect("afg.s",fullmod))
plot(effects::effect("pfg.s",fullmod))
plot(effects::effect("elev.s",fullmod))
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
plot(effects::effect("elev.s",fullmod))
plot(effects::effect("elev.s",fullmod))
summary(fullmod)
sims <- simulateResiduals(fullmod)
library(DHARMa)
sims <- simulateResiduals(fullmod)
testResiduals(sims)
summary(fullmod)
df$ID
df$ID <- as.factor(df$ID)
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID) + (0+poly(elev.s,2)|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(fullmod)
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID) + (0+poly(elev.s,2)|ID) + (0+poly(afg.s,2)|ID) + (0+afg.s|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
fullmod <- glmmTMB(Used ~ poly(pfg.s,2) + afg.s + poly(elev.s,2) +
(1|ID) + (0+poly(elev.s,2)|ID) + (0+poly(pfg.s,2)|ID) + (0+afg.s|ID)
,
data = df, family=binomial(link="logit"),
na.action = "na.fail", REML=FALSE)
summary(fullmod)
library(effects)
plot(effects::effect("elev.s",fullmod))
plot(effects::effect("afg.s",fullmod))
plot(effects::effect("jul.s",fullmod))
# plot(effects::effect("jul.s",fullmod))
plot(effects::effect("pfg.s",fullmod))
library(DHARMa)
sims <- simulateResiduals(fullmod)
testResiduals(sims)
ranef(fullmod)
elevs <- seq(min(df$elev.s),max(elev.s),length=100)
elevs <- seq(min(df$elev.s),max(df$elev.s),length=100)
elevs
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[1],levels=levels(df$ID))
)
predict(fullmod,newdf,type="response")
preds <- predict(fullmod,newdf,type="response")
plot(elevs,preds,type="l")
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[2],levels=levels(df$ID))
)
preds <- predict(fullmod,newdf,type="response")
# plot(elevs,preds,type="l")
lines(elevs,preds)
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[3],levels=levels(df$ID))
)
preds <- predict(fullmod,newdf,type="response")
# plot(elevs,preds,type="l")
lines(elevs,preds)
newdf <- data.frame(
elev.s = elevs,
afg.s = mean(df$afg.s),
pfg.s = mean(df$pfg.s),
ID = factor(levels(df$ID)[4],levels=levels(df$ID))
)
preds <- predict(fullmod,newdf,type="response")
# plot(elevs,preds,type="l")
lines(elevs,preds)
library(rpart)          # library to plot a decision tree.
library(randomForest)   # RandomForest library
library(rfUtilities)    # library to use utility functions on Random forest model to analyse model perfomance and evaluation.
data(iris)
head(iris)
tree <- rpart(Species~.,method = 'class',control = rpart.control(cp=0,minsplit = 1),data = iris)
par(xpd= NA) # setting the plot parameter not to expand(To avoid text being cut out at the corners)
plot(tree)
# adding the text to the tree
# use.n =T to plot the number of obs assosicated with each class at each node.
text(tree,use.n = T)
tree <- rpart(Species~.,method = 'class',control = rpart.control(cp=0.05,minsplit = 1),data = iris)
set.seed(1234) #setting the intial value for Random number generator
rf <- randomForest(Species ~ .,data = iris,mtry = 4,ntrees = 100,proximity=TRUE,importance= TRUE )
print(rf)
print(rf)
plot(rf) # plotting OOB error rate of all three species based on no.of tree generated by Random Forest
?randomForest
