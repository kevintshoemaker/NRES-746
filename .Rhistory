rmd2rscript_labanswers("LAB4.Rmd")
?MyxoTiter_sum
rmd2rscript("LECTURE9.Rmd")
unlink('SpatialAutocorrelation_cache', recursive = TRUE)
rmarkdown::render("TimeSeries.Rmd",rmarkdown::pdf_document())
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render("SEM.Rmd",rmarkdown::pdf_document())
rmarkdown::render("SpatialAutocorrelation.Rmd",rmarkdown::pdf_document())
rmarkdown::render("SpatialAutocorrelation.Rmd",rmarkdown::pdf_document())
install.packages("raster")
rmarkdown::render("SpatialAutocorrelation.Rmd",rmarkdown::pdf_document())
rmarkdown::render("BayesianNetworks.Rmd",rmarkdown::pdf_document())
rmarkdown::render("BayesianNetworks.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("QuantileRegression.Rmd",rmarkdown::pdf_document())
rmarkdown::render("Ordination.Rmd",rmarkdown::pdf_document())
rmarkdown::render("RSFs.Rmd",rmarkdown::pdf_document())
?mep
?kdepairs
rmarkdown::render("RSFs.Rmd",rmarkdown::pdf_document())
install.packages("randomForest")
install.packages("maptools")
install.packages(c("caret", "e1071"))
knitr::opts_chunk$set(echo = TRUE,cache = TRUE)
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic.tif")
#Load Packages
library("raster")
library("rgdal")
library("sp")
libraryh("maptools")
library("maptools")
library("randomForest")
library("caret")
library("e1071")
#Load Packages
library("raster")
library("rgdal")
library("sp")
library("maptools")
library("randomForest")
library("caret")
library("e1071")
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic.tif")
#Load Packages
library("raster")
library("rgdal")
library("sp")
library("maptools")
library("randomForest")
library("caret")
library("e1071")
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic_Full.tif")
#Rename the band names based on their spectra:
names(lm_highrez_brick) <- c("R","G","B","NIR")
# Import the raster and vector files
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic_Full.tif")
#Rename the band names based on their spectra:
names(lm_highrez_brick) <- c("R","G","B","NIR")
# Import the training shapefile:
lm_highrez_training_points <-
readOGR(dsn=".",layer="LM_Training")
# Repeat the process for the testing dataset:
lm_highrez_testing_points <-
readOGR(dsn=".",layer="LM_Test")
# Check out the files
lm_highrez_brick
lm_highrez_training_points
lm_highrez_testing_points
# Look at the attibute table of the training data:
#as.data.frame(lm_highrez_testing_points)
# Plot Data:
plotRGB(lm_highrez_brick)
plot(lm_highrez_training_points,add=TRUE,col="yellow")
plot(lm_highrez_testing_points,add=TRUE,col="orange")
quote(5+5)
?quote
a<-quote(5+5)
eval(a)
str(a)
a<-expression(5+5)
a
eval(a)
str(a)
a[[1]]
str(a[[1]])
?D
expression(mean(1:10))
eval(expression(mean(1:10)))
mean(1:10)
eval(expression(quote(mean(1:10))))
eval(eval(expression(quote(mean(1:10)))))
quote(mean(1:10))
eval(quote(mean(1:10)))
?expression
as.name("A")
do.call(paste, list(as.name("A"), as.name("B")), quote = TRUE)
list(as.name("A"), as.name("B"))
do.call(paste, list(as.name("A"), as.name("B")), quote = F)
A <- 2
f <- function(x) print(x^2)
env <- new.env()
assign("A", 10, envir = env)
assign("f", f, envir = env)
f <- function(x) print(x)
f(A)                                      # 2
do.call("f", list(A))                     # 2
do.call("f", list(A), envir = env)        # 4
do.call(f, list(A), envir = env)          # 2
do.call("f", list(quote(A)), envir = env) # 100
do.call(f, list(quote(A)), envir = env)   # 10
do.call("f", list(as.name("A")), envir = env) # 100
f
quote(A)
eval(quote(A))
quote(A)
?quote
install.packages("learnr")
1 + 1
library(rmarkdown)
install.packages("rmarkdown")
install.packages("rmarkdown")
version()
install.packages("rmarkdown")
install.packages("rmarkdown")
unlink('LAB1_cache', recursive = TRUE)
install.packages("rsconnect")
```{r, echo=FALSE}
shinyApp(
ui = fluidPage(
textInput("testq", "", value = "", width = NULL,
placeholder = "Your code here"),
verbatimTextOutput("value")
),
server = function(input, output) {
output$phonePlot = renderPlot({
barplot(WorldPhones[,input$region]*1000,
ylab = "Number of Telephones", xlab = "Year")
})
},
options = list(height = 500)
)
```
rsconnect::setAccountInfo(name='kevintshoemaker',
token='DA17E68D6DD522DEBD2FEC01402D1C58',
secret='RHyBXk3Fx6DrE8jZtmZ3vIC318RqDlT7tCYafguB')
1 + 1
unlink('LAB1_cache', recursive = TRUE)
# Chunk 1: setup
library(learnr)
tutorial_options(exercise.timelimit = 60)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# Chunk 2
############################################################
####                                                    ####
####  NRES 746, Lab 1                                   ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  Computational algorithms and standard statistics  ####
############################################################
# Chunk 3: functest
1+1
# myfunc <- function(){
#
# }
# Chunk 4
####################
# CENTRAL LIMIT THEOREM demonstration
####################
lots <- 100000       # number approximating infinity
N_IND_SAMPLES <- 1000       # number of indepenent random samples to draw from the specified distribution
SAMPLESIZE <- 10          # sample size of each independent random sample
########
#  Define the random number distribution. Here, we will use a "uniform" random number generator with a min of 10 and max of 20.
TRUEMIN <- 10
TRUEMAX <- 20
datafountain <- runif(lots,TRUEMIN,TRUEMAX)      # here we define the full set of possible random numbers to draw random samples from (the population of potential data)
#######
# Draw multiple samples from the pool (population) of possible data.
samplemean <- numeric(N_IND_SAMPLES)     # set up storage vector
for(i in 1:N_IND_SAMPLES){      # for each replicate (independent random sample)
sample <- sample(datafountain,SAMPLESIZE)   # draw an independent random sample from the population of interest
samplemean[i] <- mean(sample)    # compute and record the sample mean
}
hist(datafountain,freq=F,ylim=c(0,1))      # plot out the distribution of sample means
hist(samplemean,freq=F,add=T,col="red")    # overlay the distribution of the underlying data from which we are drawing samples.
# Chunk 19
rlocodist <- function(n){
vals <- c(1,7,10,35)         # possible data values
probs <- c(1,2,5,0.5)     # relative probability of each data values
probs <- probs/sum(probs)
vals[apply(rmultinom(n,1,probs),2,function(t) which(t==1))]     # sample from this made-up distribution
}
lots=10000
datafountain <- rlocodist(lots)
hist(datafountain, main="non-standard made-up distribution")
# Chunk 20
newsum <- function(x=c(1,2,4)){
sm <- sum(x)
return(sm)
}
newsum(x=c(5:10))   # specify x manually
newsum()    # use default value!
# Chunk 22
air.cleaned <- na.omit(airquality)    # remove rows with missing data
# Chunk 23
model1 <- lm(Ozone~Solar.R+Wind+Temp,data=air.cleaned)
# Chunk 24
par(mfrow=c(3,2))
plot(model1, which=c(1:4))   # diagnostic plots (NOTE: the plot function returns these plots by default when the input is a linear regression model)
hist(residuals(model1), breaks=10)   # histogram of residuals
plot(predict(model1) ~ air.cleaned$Ozone)     # plot predicted vs observed- should follow 1:1 line. Examine this for model biases.
abline(0,1)
# Chunk 25
symbols(air.cleaned$Temp, air.cleaned$Solar.R, circles=air.cleaned$Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
# alternatively...
coplot(air.cleaned$Ozone~air.cleaned$Temp|air.cleaned$Solar.R,rows=1)
# Chunk 26
formula2 <- "Ozone ~ Wind + Solar.R * Temp"   # you can name formulas...
# Chunk 27
model2 <- lm(formula2,data=air.cleaned)
# Chunk 29
NobleFir.df <- read.csv("TreeData.csv")
# Chunk 31
boxplot(NobleFir.df$Northeastness~NobleFir.df$ABPR, xlab="Presence of Noble Fir", ylab="Northeastness")   # for example
# Chunk 32
Biomass_std.lm <- with(NobleFir.df,     # using the "with()" statement, we don't need to keep referencing the name of the data frame.
lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
# Chunk 33
with(NobleFir.df,
symbols(x,y,circles=abs(residuals(Biomass_std.lm)), inches=0.3, ylab="Northing", xlab="Easting", main="Errors from Biomass Regression Model")
)
# Chunk 36: test4a1
df <- data.frame(
TreatmentA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
TreatmentB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
# Chunk 37: test4a2
reshapefunc <- function(df,varname){
sample.size <- nrow(df)     # determine sample size
reshape_df <- data.frame(                # "reshape" the data frame so each observation gets its own row (standard format)
Treatment = rep(c("A","B"),each=sample.size),
Value = c(df[,1],df[,2])
)
names(reshape_df)[2] <- varname   # rename the value column to whatever the user specifies
return(reshape_df)
}
unlink('LAB1_cache', recursive = TRUE)
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
devtools::install_github("lionel-/redpen")
install.packages("rlang")
install.packages("rlang")
devtools::install_github("lionel-/redpen")
devtools::install_github("dtkaplan/checkr")
devtools::install_github("lionel-/redpen",force = T)
devtools::install_github("dtkaplan/checkr")
?checkr::check_for_learnr
?checkr
library(help="checkr")
vignette(package="
"checkr")
vignette(package="checkr")
checkr::line_where()
?checkr::line_where
?checkr::for_checkr
?checkr::insist
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
line_where(ex, insist(F == "^"), message = "Didn't find exponentiation")
library(checkr)
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
line_where(ex, insist(F == "^"), message = "Didn't find exponentiation")
?line_binding
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
ex <- for_checkr(quote(z <- 2+2))
ex
line_binding(ex, 2 + 2, passif(TRUE, "The pattern matched."), message = "I was looking for 2+2.")
line_binding(ex, 3 + 3, message = "I was looking for 3 + 3")
line_binding(ex, 2 + 2, passif(Z == "z", "Assignment to {{Z}}."))
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
ex
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
line_where(ex,insist(all(F=="+")))
insist(all(F=="+"))
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
myvec <- c(1:4)
myvec
myvec <- c(1:4)
myvec
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
answer1a <- CoefVar(trees$Height)    # run your new function!
answer1a
answer1a <- CoefVar(trees$Height)    # run your new function!
answer1a
######################
# LAB 1 (possible) answers
######################
#############
## exercise 1a
CoefVar <- function(vector){
cv <- sd(vector,na.rm=TRUE)/mean(vector,na.rm=TRUE)
return(cv)
}
answer1a <- CoefVar(trees$Height)    # run your new function!
answer1a
round(answer1a,3)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
?for_checkr
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
answer1a
V
V(code)
code
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
lm_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
lm_line
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
func_call <- arg_calling(func_line, CoefVar)
func_call
t1 <- data_arg(func_call,
insist(identical(V, test),
"Your data argument {{E}} was not `test`."),
message = "You didn't supply a `data = ` argument to `lm()`.")
data_arg(func_call)
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
code
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
func_call <- arg_calling(func_line, CoefVar)
func_call
data_arg(func_call)
data_arg(code)
data_arg(code[[1]])
data_arg(code[[2]])
data_arg(code[[3]])
code[[3]]
code
code$code[[3]]
data_arg(code$code[[3]])
code$values
code$values[[3]]
?data_arg
data_arg(code)
func_line
vector_arg(func_line)
test<-1
vector_arg(func_line)
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
numeric_arg(code, message = "")
numeric_arg(func_line, message = "")
test <- trees$Height
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_call <- arg_calling(func_line, CoefVar)
func_call
func_call
func_line
func_line$code
func_line$values
func_call$values
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
?line_calling
?arg_calling
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
named_arg(func_line,"test", message = "The argument to your function should be test")
named_arg(func_line)
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(vector=test)}))
code
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
named_arg(func_line,"test", message = "The argument to your function should be test")
named_arg(func_line,"vector", message = "The argument to your function should be test")
named_arg(func_line,vector, message = "The argument to your function should be test")
named_arg(func_line,test, message = "The argument to your function should be test")
named_arg(func_line,"vector", message = "The argument to your function should be test")
func_line
vector_arg(func_line)
test
function_arg(code)
function_arg(func_line)
?line_binding
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,sd,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,"sd",message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,sd(vector),message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,test,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,test <- trees$Height,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,trees$Height,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,function(vector){sd(vector)/mean(vector)},message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,'function(vector){sd(vector)/mean(vector)}',message = "Use the function 'sd'")
func_line
?lines_after
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,'function(vector){sd(vector)/mean(vector)}',message = "Use the function 'sd'")
func_call <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
check(func_call, insist(dplyr::near(V,answer1a,tol=0.001),
"Your solution is {{V}}. This is not the correct result"),
passif(TRUE, "Great job!"))
func_call$values
check(func_call, insist(dplyr::near(V,answer1a,tol=0.001),
message="Your solution is {{V}}. This is not the correct result"),
passif(TRUE, "Great job!"))
func_call
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"),passif(TRUE, "Great job!"))
line_where(func_call, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"),passif(TRUE, "Great job!"))
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"),passif(TRUE, "Great job!"))
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
install.packages("emdbook")
install.packages("ROCR")
install.packages("party")
install.packages("bnlearn")
install.packages("sparsebn")
install.packages(c("dtw", "forecast", "tseries"))
install.packages(c("GGally", "lavaan"))
install.packages("HDInterval")
install.packages(c("geosphere", "gstat"))
install.packages(c("arm", "ResourceSelection", "sjstats"))
install.packages("Qtools")
install.packages(c("scatterplot3d", "vegan"))
install.packages(c("amt", "aod"))
install.packages("randomForest")
install.packages("Rgraphviz")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
source("http://bioconductor.org/biocLite.R")
install.packages("BiocManager")
# source("http://bioconductor.org/biocLite.R")
# biocLite("Rgraphviz")
BiocManager::install("Rgraphviz")
library("Rgraphviz")
install.packages("RevoUtilsMath")
#install.packages("sparsebn")
library(sparsebn)
unlink('BayesianNetworks_cache', recursive = TRUE)
shiny::runUrl("http://naes.unr.edu/shoemaker/teaching/NRES-746/NRES-746_lab1.zip")
shiny::runUrl("http://naes.unr.edu/shoemaker/teaching/NRES-746/NRES-746_lab1.zip")
