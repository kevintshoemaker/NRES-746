b <- params[3]                              # b parameter (not a function of wave/nonwave)
k <- c(params[4],params[5])[wave.code]      # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a.n=1,a.w=1,b=1,k.n=1,k.w=1)
NegBinomLik_constb(params)
MLE_constb <- optim(fn=NegBinomLik_constb,par=c(a.n=1,a.w=1,b=1,k.n=1,k.w=1),method="L-BFGS-B")
MLE_constb$par
MLE_constb$value
deviance_full <- 2*MLE_full$value
deviance_constb <- 2*MLE_constb$value
deviance_full
deviance_constb
Deviance.dif <- deviance_constb - deviance_full
Deviance.dif
Chisq.crit <- qchisq(0.95,1)
Chisq.crit
Deviance.dif>=Chisq.crit   # perform the LRT
1-pchisq(Deviance.dif,1)   # p-value
curve(dchisq(x,df=1),0,5)
abline(v=Deviance.dif,col="red",lwd=4)
NegBinomLik_nowave <- function(params){
a <- params[1]      # a parameters
b <- params[2]      # b parameter (not a function of wave/nonwave)
k <- params[3]      # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a=1,b=1,k=1)
NegBinomLik_nowave(params)
MLE_nowave <- optim(fn=NegBinomLik_nowave,par=params,method="L-BFGS-B")
MLE_nowave$par
MLE_nowave$value
deviance_full <- 2*MLE_full$value
deviance_nowave <- 2*MLE_nowave$value
Deviance.dif <- deviance_nowave - deviance_full
Deviance.dif
Chisq.crit <- qchisq(0.95,df=3)   # now three additional params in the more complex model!
Chisq.crit
Deviance.dif>=Chisq.crit
1-pchisq(Deviance.dif,df=3)   # p-value
curve(dchisq(x,df=3),0,15)
abline(v=Deviance.dif,col="red",lwd=4)
NegBinomLik_constak <- function(params){
wave.code <- as.numeric(fir$WAVE_NON)      # convert to ones and twos
a <- params[1]                             # a parameters
b <- c(params[2],params[3])[wave.code]                              # b parameter (not a function of wave/nonwave)
k <- params[4]                               # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a=1,b.n=1,b.w=1,k=1)
NegBinomLik_constak(params)
MLE_constak <- optim(fn=NegBinomLik_constak,par=params)
MLE_constak$par
MLE_constak$value
deviance_constak <- 2*MLE_constak$value
PoisLik_nowave <- function(params){
a <- params[1]      # a parameters
b <- params[2]      # b parameter (not a function of wave/nonwave)
expcones <- a*fir$DBH^b
-sum(dpois(fir$TOTCONES,lambda=expcones,log=TRUE))
}
params <- c(a=1,b=1)
PoisLik_nowave(params)
MLE_pois <- optim(fn=PoisLik_nowave,par=params)
MLE_pois$par
MLE_pois$value
deviance_pois <- 2*MLE_pois$value
AIC_constak <- deviance_constak + 2*4
AIC_full <- deviance_full + 2*6
AIC_constb <- deviance_constb + 2*5
AIC_nowave <- deviance_nowave + 2*3
AIC_pois <- deviance_pois + 2*2
AICtable <- data.frame(
Model = c("Full","Constant b","Constant a and k","All constant","Poisson"),
AIC = c(AIC_full,AIC_constb,AIC_constak,AIC_nowave,AIC_pois),
Deviance = c(deviance_full,deviance_constb,deviance_constak,deviance_nowave,deviance_pois),
params = c(6,5,4,3,2),
stringsAsFactors = F
)
AICtable$DeltaAIC <- AICtable$AIC-AICtable$AIC[which.min(AICtable$AIC)]
AICtable[order(AICtable$AIC),c(1,2,5,4,3)]
probs1 <- dbinom(0:10,10,0.5)
names(probs1) = 0:10
barplot(probs1,ylab="probability")
curve(dbeta(x,1,1))
lots=100000
hist(rbinom(lots,10,prob=rbeta(lots,1,1)),freq = F)   # no particular observation is favored
probs2 <- rep(1/11,times=11)
names(probs2) = 0:10
barplot(probs2,ylab="probability",ylim=c(0,1))
probs2 <- rep(1/11,times=11)
names(probs2) = 0:10
barplot(probs2,ylab="probability",ylim=c(0,1))
probs1 <- dbinom(0:10,10,0.5)
names(probs1) = 0:10
barplot(probs1,ylab="probability",add=T,col="red",density=20)
probs2 <- rep(1/11,times=11)
names(probs2) = 0:10
barplot(probs2,ylab="probability",ylim=c(0,1))
probs1 <- dbinom(0:10,10,0.5)
names(probs1) = 0:10
barplot(probs1,ylab="probability",add=T,col="red",density=20)
abline(v=3,col="green",lwd=4 )
BayesFactor = (1/11)/dbinom(2,10,0.5)
BayesFactor
BayesFactor = dbinom(3,10,0.5)/(1/11)
BayesFactor
cat("
model  {
### Likelihood
for(i in 1:n.obs){
expected.cones[i] <- a[wave[i]]*pow(DBH[i],b[wave[i]])   # a*DBH^b
p[i] <- r[wave[i]] / (r[wave[i]] + expected.cones[i])
observed.cones[i] ~ dnegbin(p[i],r[wave[i]])
}
### Priors
for(j in 1:2){   # estimate separately for wave and non-wave
a[j] ~ dunif(0.001,2)
b[j] ~ dunif(0.5,4)
r[j] ~ dunif(0.5,5)
}
}
",file="BUGS_fir.txt")
data.package <- list(
observed.cones = fir$TOTCONES,
n.obs = nrow(fir),
wave = as.numeric(fir$WAVE_NON),
DBH = fir$DBH
)
#data.package
init.generator <- function(){ list(
a = runif(2, 0.2,0.5),
b = runif(2, 2,3),
r = runif(2, 1,2)
)
}
init.generator()
library(R2jags)    # load packages
library(coda)
library(lattice)
params.to.monitor <- c("a","b","r")
jags.fit <- jags(data=data.package,inits=init.generator,parameters.to.save=params.to.monitor,n.iter=10000,model.file="BUGS_fir.txt",n.chains = 2,n.burnin = 2000,n.thin=5 )
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
densityplot(jagsfit.mcmc)
hist(jags.fit$BUGSoutput$sims.list$r[,1],main="dispersion param",ylab="Prob Density",xlab="dispersion param",freq = F,ylim=c(0,2))
hist(jags.fit$BUGSoutput$sims.list$r[,2],density=20,col="green",add=T,freq=F)
legend("topright",col=c("green","white"),density=c(20,0),legend=c("wave","nonwave"),bty="n")
DIC_full <- jags.fit$BUGSoutput$DIC
DIC_full
cat("
model  {
### Likelihood
for(i in 1:n.obs){
expected.cones[i] <- a*pow(DBH[i],b)   # a*DBH^b
p[i] <- r / (r + expected.cones[i])
observed.cones[i] ~ dnegbin(p[i],r)
}
### Priors
a ~ dunif(0.001,2)
b ~ dunif(0.5,4)
r ~ dunif(0.5,5)
}
",file="BUGS_fir_reduced.txt")
data.package <- list(
observed.cones = fir$TOTCONES,
n.obs = nrow(fir),
#wave = as.numeric(fir$WAVE_NON),
DBH = fir$DBH
)
#data.package
init.generator <- function(){ list(
a = runif(1, 0.2,0.5),
b = runif(1, 2,3),
r = runif(1, 1,2)
)
}
init.generator()
params.to.monitor <- c("a","b","r")
jags.fit <- jags(data=data.package,inits=init.generator,parameters.to.save=params.to.monitor,n.iter=10000,model.file="BUGS_fir_reduced.txt",n.chains = 2,n.burnin = 2000,n.thin=5 )
jagsfit.mcmc <- as.mcmc(jags.fit)   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
densityplot(jagsfit.mcmc)
DIC_reduced <- jags.fit$BUGSoutput$DIC
DIC_reduced
DIC_full
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(emdbook)
data(FirDBHFec)
fir <- na.omit(FirDBHFec[,c("TOTCONES","DBH","WAVE_NON")])
fir$TOTCONES <- round(fir$TOTCONES)
head(fir)
plot(fir$TOTCONES ~ fir$DBH)
ndx <- fir$WAVE_NON=="w"   # logical vector indicating which observations were from "wave" sites
plot(fir$TOTCONES[ndx] ~ fir$DBH[ndx],xlab="DBH",ylab="Tot Cones")
points(fir$DBH[!ndx],fir$TOTCONES[!ndx],pch=4,col="red")
legend("topleft",pch=c(1,4),col=c("black","red"),legend=c("Wave","Non-wave"),bty="n")
NegBinomLik_full <- function(params){
wave.code <- as.numeric(fir$WAVE_NON)      # convert to ones and twos
a <- c(params[1],params[2])[wave.code]     # a parameters
b <- c(params[3],params[4])[wave.code]      # b parameter (not a function of wave/nonwave)
k <- c(params[5],params[6])[wave.code]       # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a.n=1,a.w=1,b.n=1,b.w=1,k.n=1,k.w=1)
NegBinomLik_full(params)
MLE_full <- optim(fn=NegBinomLik_full,par=c(a.n=1,a.w=1,b.n=1,b.w=1,k.n=1,k.w=1),method="L-BFGS-B")
MLE_full$par
MLE_full$value
NegBinomLik_constb <- function(params){
wave.code <- as.numeric(fir$WAVE_NON)      # convert to ones and twos
a <- c(params[1],params[2])[wave.code]      # a parameters
b <- params[3]                              # b parameter (not a function of wave/nonwave)
k <- c(params[4],params[5])[wave.code]      # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a.n=1,a.w=1,b=1,k.n=1,k.w=1)
NegBinomLik_constb(params)
MLE_constb <- optim(fn=NegBinomLik_constb,par=c(a.n=1,a.w=1,b=1,k.n=1,k.w=1),method="L-BFGS-B")
MLE_constb$par
MLE_constb$value
deviance_full <- 2*MLE_full$value
deviance_constb <- 2*MLE_constb$value
deviance_full
deviance_constb
Deviance.dif <- deviance_constb - deviance_full
Deviance.dif
Chisq.crit <- qchisq(0.95,1)
Chisq.crit
Deviance.dif>=Chisq.crit   # perform the LRT
1-pchisq(Deviance.dif,1)   # p-value
curve(dchisq(x,df=1),0,5)
abline(v=Deviance.dif,col="red",lwd=4)
NegBinomLik_nowave <- function(params){
a <- params[1]      # a parameters
b <- params[2]      # b parameter (not a function of wave/nonwave)
k <- params[3]      # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a=1,b=1,k=1)
NegBinomLik_nowave(params)
MLE_nowave <- optim(fn=NegBinomLik_nowave,par=params,method="L-BFGS-B")
MLE_nowave$par
MLE_nowave$value
deviance_full <- 2*MLE_full$value
deviance_nowave <- 2*MLE_nowave$value
Deviance.dif <- deviance_nowave - deviance_full
Deviance.dif
Chisq.crit <- qchisq(0.95,df=3)   # now three additional params in the more complex model!
Chisq.crit
Deviance.dif>=Chisq.crit
1-pchisq(Deviance.dif,df=3)   # p-value
curve(dchisq(x,df=3),0,15)
abline(v=Deviance.dif,col="red",lwd=4)
NegBinomLik_constak <- function(params){
wave.code <- as.numeric(fir$WAVE_NON)      # convert to ones and twos
a <- params[1]                             # a parameters
b <- c(params[2],params[3])[wave.code]                              # b parameter (not a function of wave/nonwave)
k <- params[4]                               # dispersion parameters
expcones <- a*fir$DBH^b
-sum(dnbinom(fir$TOTCONES,mu=expcones,size=k,log=TRUE))
}
params <- c(a=1,b.n=1,b.w=1,k=1)
NegBinomLik_constak(params)
MLE_constak <- optim(fn=NegBinomLik_constak,par=params)
MLE_constak$par
MLE_constak$value
deviance_constak <- 2*MLE_constak$value
PoisLik_nowave <- function(params){
a <- params[1]      # a parameters
b <- params[2]      # b parameter (not a function of wave/nonwave)
expcones <- a*fir$DBH^b
-sum(dpois(fir$TOTCONES,lambda=expcones,log=TRUE))
}
params <- c(a=1,b=1)
PoisLik_nowave(params)
MLE_pois <- optim(fn=PoisLik_nowave,par=params)
MLE_pois$par
MLE_pois$value
deviance_pois <- 2*MLE_pois$value
AIC_constak <- deviance_constak + 2*4
AIC_full <- deviance_full + 2*6
AIC_nowave <- deviance_nowave + 2*3
AIC_constak <- deviance_constak + 2*4
AIC_full <- deviance_full + 2*6
AIC_nowave <- deviance_nowave + 2*3
AIC_pois <- deviance_pois + 2*2
AICtable <- data.frame(
Model = c("Full","Constant b","Constant a and k","All constant","Poisson"),
AIC = c(AIC_full,AIC_constb,AIC_constak,AIC_nowave,AIC_pois),
Deviance = c(deviance_full,deviance_constb,deviance_constak,deviance_nowave,deviance_pois),
params = c(6,5,4,3,2),
stringsAsFactors = F
)
AICtable$DeltaAIC <- AICtable$AIC-AICtable$AIC[which.min(AICtable$AIC)]
AICtable$Weights <- exp(-0.5*AICtable$DeltaAIC) / sum(exp(-0.5*AICtable$DeltaAIC))
AICtable[order(AICtable$AIC),c(1,2,5,4,3)]
AICtable[order(AICtable$AIC),c(1,2,5,6,4,3)]
AICtable[order(AICtable$AIC),c(1,2,5,6,4,3)]
AICtable$Weights
AICtable$Weights <- round(exp(-0.5*AICtable$DeltaAIC) / sum(exp(-0.5*AICtable$DeltaAIC)),3)
AICtable$Weights
AICtable[order(AICtable$AIC),c(1,2,5,6,4,3)]
AICtable$AICc <- AICtable$AIC + ((2*AICtable$params)*(AICtable$params+1))/(nrow(fir)-AICtable$params-1)
AICtable$AICc
AICtable[order(AICtable$AIC),c(1,7,2,5,6,4,3)]
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
slugs<-read.table( 'http://www.bio.ic.ac.uk/research/mjcraw/statcomp/data/slugsurvey.txt', header=TRUE)
head(slugs)
table(slugs$slugs,slugs$field)
out <- table(slugs$slugs,slugs$field)
barplot(out)
barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), col=c('black','red'), legend.text=TRUE, xlab='# of slugs', ylab='frequency')
coords<-barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), ylim=c(0,27), col=c('black','red'), xlab='# of slugs', ylab='frequency')
box()
legend(coords[1,8], 26, c('nursery','rookery'), density=c(20,20), angle=c(45,135), fill=c('black','red'), cex=c(.8,.8),bty='n')
box()
coords<-barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), ylim=c(0,27), col=c('black','red'), xlab='# of slugs', ylab='frequency')
box()
legend(coords[1,8], 26, c('nursery','rookery'), density=c(20,20), angle=c(45,135), fill=c('black','red'), cex=c(.8,.8),bty='n')
?nlm
poi.1<-function(data,p) -sum(log(dpois(data$slugs,lambda=p)))
mean(slugs$slugs)
out1 <- nlm(function(p) poi.1(slugs,p),2)
out1
tapply(slugs$slugs,slugs$field,mean)
out2 <- nlm(function(p) poi.2(slugs,p),c(1.2,1))
poi.2<-function(data,p) {
field.dummy<-as.numeric(data$field)-1
mylambda<-p[1]+p[2]*field.dummy
negloglike<- -sum(log(dpois(data$slugs,lambda=mylambda)))
negloglike
}
out2 <- nlm(function(p) poi.2(slugs,p),c(1.2,1))
out2
> #common lambda and theta
#common lambda and theta
zip1<-function(data,p) {
lambda<-p[1]
theta<-p[2]
zero.term<-sum(log(theta+(1-theta)* dpois(data$slugs[data$slugs==0], lambda)))
nonzero.term<-sum(log((1- theta)* dpois(data$slugs[data$slugs>0], lambda)))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
mean(slugs$slugs[slugs$slugs>0])
table(slugs$slugs)[1]/sum(table(slugs$slugs))
out7 <- nlm(function(p) zip1(slugs,p),c(3,.4))
out7
my.aic(out7)
my.aic<-function(output) -2*(-output$minimum) + 2*length(output$estimate)
my.aic(out1)
my.aic(out2)
#common lambda and theta
zip1<-function(data,p) {
lambda<-p[1]
theta<-p[2]
zero.term<-sum(log(theta+(1-theta)* dpois(data$slugs[data$slugs==0], lambda)))
nonzero.term<-sum(log((1- theta)* dpois(data$slugs[data$slugs>0], lambda)))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
my.aic(out7)
# different lambda, same theta
zip2<-function(data,p) {
field.dummy<-as.numeric(slugs$field)-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
zero.term<-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
nonzero.term<-sum(ifelse(data$slugs>0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
negloglike<- -sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),log((1-theta)* dpois(data$slugs,lambda=mylambda))))
zip2.alt<-function(data,p) {
field.dummy<-as.numeric(slugs$field)-1
mylambda<-p[1]+p[3]*field.dummy
theta<-p[2]
negloglike<- -sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),log((1-theta)*dpois(data$slugs,lambda=mylambda))))
negloglike
}
tapply(slugs$slugs[slugs$slugs>0],slugs$field[slugs$slugs>0],mean)
#different theta
zip3<-function(data,p){
field.dummy<-as.numeric(data$field)-1
mylambda<-p[1]
theta<-p[2]+p[3]*field.dummy
zero.term<-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
nonzero.term<-sum(ifelse(data$slugs>0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
negloglike<- -(zero.term+nonzero.term)
negloglike
}
out8 <- nlm(function(p) zip2(slugs,p),c(3.4,.42,-.4))
out8
out9 <- nlm(function(p) zip3(slugs,p),c(3,.6,-.4))
out9
norm.neglike<-function(data,p) {
t.y<-log(data$slugs+1)
mu<-p[1]
my.sd<-p[2]
negloglike<- -sum(log(dnorm(t.y,mean=mu,sd=my.sd)))
negloglike
}
mean(log(slugs$slugs+1))
sd(log(slugs$slugs+1))
norm.neglike2<-function(data,p) {
t.y<-log(data$slugs+1)
field.dummy<-as.numeric(data$field)-1
mu<-p[1]+field.dummy*p[3]
my.sd<-p[2]
negloglike<- -sum(log(dnorm(t.y,mean=mu,sd=my.sd)))
negloglike
}
outnorm2 <- nlm(function(p) norm.neglike2(slugs,p),c(.5,.7,.5))
outnorm2
norm.like2<-function(data,out) {
t.y<-log(data$slugs+1)
field.dummy<-as.numeric(data$field)-1
mu<-out$estimate[1]+field.dummy*out$estimate[3]
my.sd<-out$estimate[2]
negloglike<- -sum(log(dnorm(t.y,mean=mu,
sd=my.sd)*1/(data$slugs+1)))
out<-list(negloglike,out$estimate)
names(out)<-c("minimum","estimate")
out
}
out21 <- norm.like2(slugs,outnorm2)->
my.aic(out21)
out21 <- norm.like2(slugs,outnorm2)
my.aic(out21)
my.aic(out9)
AIC.func<-function(model.list,n,modelnames) {
output<-NULL
for (i in 1:length(model.list)) {
cur.model<-model.list[[i]]
LL<- -cur.model$minimum
K<-length(cur.model$estimate)
AIC<- -2*LL + 2*K
AICc<-AIC + 2*K*(K+1)/(n-K-1)
output<-rbind(output,c(LL,K,AIC,AICc))
}
colnames(output)<-c('LogL','K','AIC','AICc')
minAICc<-min(output[,"AICc"])
deltai<-output[,"AICc"]-minAICc
rel.like<-exp(-deltai/2)
wi<-round(rel.like/sum(rel.like),3)
out<-data.frame(modelnames,output,deltai,wi)
out
}
AIC.func(models,80,model.names)
models<-list(out1,out2,out7,out8,out9,out20,out21)
AIC.func(models,80,model.names)
out20 <- norm.like(slugs,out.norm)
#calculate negative loglikelihood for AIC
norm.like<-function(data,out) {
t.y<-log(data$slugs+1)
mu<-out$estimate[1]
my.sd<-out$estimate[2]
negloglike<- -sum(log(dnorm(t.y,mean=mu, sd=my.sd)*1/(data$slugs+1)))
out<-list(negloglike,out$estimate)
names(out)<-c("minimum","estimate")
out
}
out20 <- norm.like(slugs,out.norm)
out.norm <- nlm(function(p) norm.neglike(slugs,p),c(.73,.74))
out.norm
#calculate negative loglikelihood for AIC
norm.like<-function(data,out) {
t.y<-log(data$slugs+1)
mu<-out$estimate[1]
my.sd<-out$estimate[2]
negloglike<- -sum(log(dnorm(t.y,mean=mu, sd=my.sd)*1/(data$slugs+1)))
out<-list(negloglike,out$estimate)
names(out)<-c("minimum","estimate")
out
}
out20 <- norm.like(slugs,out.norm)
out20
outnorm2 <- nlm(function(p) norm.neglike2(slugs,p),c(.5,.7,.5))
outnorm2
models<-list(out1,out2,out7,out8,out9,out20,out21)
AIC.func(models,80,model.names)
model.names<-c('Pois.common','Pois.mean','Zip.common', 'Zip.mean','Zip.theta','lognormal','lognormal.mean')
AIC.func(models,80,model.names)
AIC.func(models,80,model.names)
AIC.func<-function(model.list,n,modelnames) {
output<-NULL
for (i in 1:length(model.list)) {
cur.model<-model.list[[i]]
LL<- -cur.model$minimum
K<-length(cur.model$estimate)
AIC<- -2*LL + 2*K
AICc<-AIC + 2*K*(K+1)/(n-K-1)
output<-rbind(output,c(LL,K,AIC,AICc))
}
colnames(output)<-c('LogL','K','AIC','AICc')
minAICc<-min(output[,"AICc"])
deltai<-output[,"AICc"]-minAICc
rel.like<-exp(-deltai/2)
wi<-round(rel.like/sum(rel.like),3)
out<-data.frame(modelnames,output,deltai,wi)[order(deltai),]
out
}
AIC.func(models,80,model.names)
