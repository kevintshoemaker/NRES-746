newguess <- abs(oldguess + jump)    # note: by taking the abs val to avoid negative numbers, our proposal jump probs are not strictly symmetrical, but this should not present a big issue in practice.
return(newguess)
}
# set a new "guess" near to the original guess
newGuess(oldguess=params)
newGuess(oldguess=params)
newGuess(oldguess=params)
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
##########
# Set a starting point in parameter spacer
startingvals <- c(shape=45,scale=0.18)    # starting point for the algorithm
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###########
# Try our new functions
newguess <- newGuess(startingvals)    # take a jump in parameter space
newguess
PosteriorRatio2(startingvals,newguess)   # difference in posterior ratio
###############
# Visualize the Metropolis-Hastings routine:
chain.length <- 11
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
###############
# Visualize the Metropolis-Hastings routine:
chain.length <- 11
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
##########
# Get more MCMC samples
chain.length <- 100
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
############
# And more...
chain.length <- 1000
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
##########
# Set a starting point in parameter spacer
startingvals <- c(shape=75,scale=0.28)    # starting point for the algorithm
###############
# Visualize the Metropolis-Hastings routine:
chain.length <- 11
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
############
# And more...
chain.length <- 1000
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
##########
# Try again- run for much longer
chain.length <- 20000
oldguess <- startingvals
guesses <- matrix(0,nrow=chain.length,ncol=2)
colnames(guesses) <- names(startingvals)
guesses[1,] <- startingvals
counter <- 2
while(counter <= chain.length){
newguess <- newGuess(oldguess)
post.rat <- PosteriorRatio2(oldguess,newguess)
prob.accept <- min(1,post.rat)
rand <- runif(1)
if(rand<=prob.accept){
oldguess <- newguess
guesses[counter,] <- newguess
counter=counter+1
}
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
#############
# Use longer "burn-in"
burn.in <- 5000
MCMCsamples <- guesses[-c(1:burn.in),]
chain.length=chain.length-burn.in
##########
# "thin" the MCMC samples
thinnedMCMC <- MCMCsamples[seq(1,chain.length,by=10),]
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'shape'],type="l",main="shape parameter",xlab="iteration",ylab="shape")
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'scale'],type="l",main="scale parameter",xlab="iteration",ylab="scale")
##########
# "thin" the MCMC samples
thinnedMCMC <- MCMCsamples[seq(1,chain.length,by=5),]
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'shape'],type="l",main="shape parameter",xlab="iteration",ylab="shape")
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'scale'],type="l",main="scale parameter",xlab="iteration",ylab="scale")
##########
# "thin" the MCMC samples
thinnedMCMC <- MCMCsamples[seq(1,chain.length,by=20),]
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'shape'],type="l",main="shape parameter",xlab="iteration",ylab="shape")
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'scale'],type="l",main="scale parameter",xlab="iteration",ylab="scale")
##########
# "thin" the MCMC samples
thinnedMCMC <- MCMCsamples[seq(1,chain.length,by=5),]
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'shape'],type="l",main="shape parameter",xlab="iteration",ylab="shape")
plot(1:nrow(thinnedMCMC),thinnedMCMC[,'scale'],type="l",main="scale parameter",xlab="iteration",ylab="scale")
# Visualize the posterior!
plot(density(thinnedMCMC[,'scale']),main="scale parameter",xlab="scale")
plot(density(thinnedMCMC[,'shape']),main="shape parameter",xlab="shape")
#############
# Now construct a Gibbs sampler alternative
gibbs<-function (n, rho){    # a gibbs sampler implementation of a bivariate random number generator
mat <- matrix(ncol = 2, nrow = n)   # matrix for storing the random samples
x <- 0
y <- 0
mat[1, ] <- c(x, y)        # initialize the markov chain
for (i in 2:n) {
x <- rnorm(1, rho * y, sqrt(1 - rho^2))        # sample from x conditional on y
y <- rnorm(1, rho * x, sqrt(1 - rho^2))        # sample from y conditional on x
mat[i, ] <- c(x, y)
}
mat
}
#############
# Simple example of a Gibbs sampler
#############
########
# first, recall our simple bivariate normal sampler
rbvn<-function (n, rho){  #function for drawing an arbitrary number of independent samples from the bivariate standard normal distribution.
x <- rnorm(n, 0, 1)
y <- rnorm(n, rho * x, sqrt(1 - rho^2))
cbind(x, y)
}
bvn<-rbvn(10000,0.98)
par(mfrow=c(3,2))
plot(bvn,col=1:10000)
plot(bvn,type="l")
plot(ts(bvn[,1]))
plot(ts(bvn[,2]))
hist(bvn[,1],40)
hist(bvn[,2],40)
par(mfrow=c(1,1))
##########
# Test the Gibbs sampler
bvn<-gibbs(10000,0.98)
par(mfrow=c(3,2))
plot(bvn,col=1:10000)
plot(bvn,type="l")
plot(ts(bvn[,1]))
plot(ts(bvn[,2]))
hist(bvn[,1],40)
hist(bvn[,2],40)
par(mfrow=c(1,1))
###########
# Myxomatosis example in BUGS modeling language
##########
# Write the BUGS model to file
cat("
model {
#############
# LIKELIHOOD
############
for(obs in 1:n.observations){
titer[obs] ~ dgamma(shape,rate)
}
#############
# PRIORS
############
shape ~ dgamma(0.001,0.001)
scale ~ dgamma(0.001,0.001)
rate <- 1/scale
}
", file="BUGSmodel.txt")
############
# Encapsulate the data into a single "list" object
myx.data.for.bugs <- list(
titer = Myx$titer,
n.observations = length(Myx$titer)
)
myx.data.for.bugs
###########
# Function for generating random initial values for all free parameters
init.vals.for.bugs <- function(){
list(
shape=runif(1,20,100),
scale=runif(1,0.05,0.3)
)
}
init.vals.for.bugs()
init.vals.for.bugs()
init.vals.for.bugs()
###########
# Run JAGS!!!!
##########
#library(R2jags)
library(jagsUI)
library(modeest)
library(coda)
params.to.store <- c("shape","scale")
jags.fit <- jags(model="BUGSmodel.txt",data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,n.chains = 3,n.adapt = 100,n.burnin = 0)
jagsfit.mcmc <- jags.fit$samples   # extract "MCMC" object
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
################
# Run the chains for longer!
jags.fit <- jags(model="BUGSmodel.txt",data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,
n.iter = 10000,n.chains = 3,n.adapt = 1000,n.burnin = 1000,
n.thin=20,parallel=T )
jagsfit.mcmc <- jags.fit$samples   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
##############
# Run convergence diagnostics
gelman.diag(jagsfit.mcmc)
###########
# Myxomatosis example in BUGS modeling language
##########
# Write the BUGS model to file
cat("
model {
#############
# LIKELIHOOD
############
for(obs in 1:n.observations){
titer[obs] ~ dgamma(shape,rate)
}
#############
# PRIORS
############
shape ~ dgamma(0.001,0.001)
scale ~ dgamma(0.01,0.01)
rate <- 1/scale
}
", file="BUGSmodel.txt")
############
# Encapsulate the data into a single "list" object
myx.data.for.bugs <- list(
titer = Myx$titer,
n.observations = length(Myx$titer)
)
myx.data.for.bugs
###########
# Function for generating random initial values for all free parameters
init.vals.for.bugs <- function(){
list(
shape=runif(1,20,100),
scale=runif(1,0.05,0.3)
)
}
init.vals.for.bugs()
init.vals.for.bugs()
init.vals.for.bugs()
###########
# Run JAGS!!!!
##########
#library(R2jags)
library(jagsUI)
library(modeest)
library(coda)
params.to.store <- c("shape","scale")
jags.fit <- jags(model="BUGSmodel.txt",data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,n.chains = 3,n.adapt = 100,n.burnin = 0)
jagsfit.mcmc <- jags.fit$samples   # extract "MCMC" object
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
################
# Run the chains for longer!
jags.fit <- jags(model="BUGSmodel.txt",data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,
n.iter = 10000,n.chains = 3,n.adapt = 1000,n.burnin = 1000,
n.thin=20,parallel=T )
jagsfit.mcmc <- jags.fit$samples   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
###########
# Myxomatosis example in BUGS modeling language
##########
# Write the BUGS model to file
cat("
model {
#############
# LIKELIHOOD
############
for(obs in 1:n.observations){
titer[obs] ~ dgamma(shape,rate)
}
#############
# PRIORS
############
shape ~ dgamma(0.001,0.001)
scale ~ dgamma(0.001,0.001)
rate <- 1/scale
}
", file="BUGSmodel.txt")
###########
# Run JAGS!!!!
##########
#library(R2jags)
library(jagsUI)
library(modeest)
library(coda)
params.to.store <- c("shape","scale")
jags.fit <- jags(model="BUGSmodel.txt",data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=5000,n.chains = 3,n.adapt = 100,n.burnin = 0)
jagsfit.mcmc <- jags.fit$samples   # extract "MCMC" object
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
################
# Run the chains for longer!
jags.fit <- jags(model="BUGSmodel.txt",data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,
n.iter = 100000,n.chains = 3,n.adapt = 1000,n.burnin = 10000,
n.thin=100,parallel=T )
jagsfit.mcmc <- jags.fit$samples   # convert to "MCMC" object (coda package)
summary(jagsfit.mcmc)
plot(jagsfit.mcmc)
##############
# Run convergence diagnostics
gelman.diag(jagsfit.mcmc)
unlink("LECTURE7_cache", recursive = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("LECTURE5.Rmd")
rmd2rscript("LECTURE6.Rmd")
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript("LECTURE9.Rmd")
