abs(cor(df.rikz[,c(2,5)]))
# define the model
lme.rikz <- lmer(Richness ~ NAP + (1 | Beach), data = df.rikz)
# residual vs fitted plot
plot(lme.rikz, xlab = "Fitted", ylab = "Residual")
summary(lme.rikz)
rm(list=ls())
df.sloth <- read.csv("sloth_point5only_withPatchGroup.csv", header = TRUE, sep = ",")
str(df.sloth) # 25 variables with 25 observations
# drop metadata, response, random effect, categorical data
df.sloth2 <- subset.data.frame(df.sloth, select = -c(SITE_ID, LONGITUDE, LATITUDE, LAND_USE, patch_grou, OCCURRENCE))
df.sloth2$PR <- as.numeric(df.sloth2$PR)
str(df.sloth2)
IsItNormal <- function(df, save = F) { ### should be able to accept any dataframe of arbitrary size & names, if all columns contain data that Shapiro-Wilk test likes
slothtest <- list()
for(i in seq(dim(df)[2])) {
slothtest <- append(slothtest, shapiro.test(df[[i]]))
}
mx.slothtest <- matrix(slothtest, byrow = T, ncol = 4)
df.slothtest <- data.frame(var = as.character(colnames(df)),
W = as.numeric(mx.slothtest[,1]),
p = as.numeric(mx.slothtest[,2]),
row.names = NULL)
if(save == T) {write.table(df.slothtest, file = paste0("IsItNormal", round(as.numeric(Sys.time())), ".csv"), row.names = F, sep = ",")}
return(df.slothtest)
}
IsItNormal(df.sloth2)
df.sloth.log <- as.data.frame(apply(df.sloth2, 2, log))
df.sloth.sqrt <- as.data.frame(apply(df.sloth2, 2, sqrt))
df.sloth.squared <- as.data.frame(apply(df.sloth2, 2, function(x) x^2))
df.slothtest.transformed <- cbind(IsItNormal(df.sloth2),
IsItNormal(df.sloth.log)[,2:3],
IsItNormal(df.sloth.sqrt)[,2:3],
IsItNormal(df.sloth.squared)[,2:3])
colnames(df.slothtest.transformed)[4:5] <- paste0("log.", c("W", "p"))
colnames(df.slothtest.transformed)[6:7] <- paste0("sqrt.", c("W", "p"))
colnames(df.slothtest.transformed)[8:9] <- paste0("squared.", c("W", "p"))
# Table defining the normality at different transformations saved to your drive
write.table(df.slothtest.transformed, file = paste0("AreTransformedSlothsNormal_", round(as.numeric(Sys.time())), ".csv"), row.names = F, sep = ",")
# data subsetted removing "never normal columns" based on normality tests
df.sloth3 <- subset.data.frame(df.sloth2, select = -c(CONTAG, DIST_SEC_F, PATCH_SHAP, PLAND_SF, SIEI))
# Log transform "PATCH_AREA", "DIST_ROAD","PD", "LPI","AREA_WM"
df.sloth4 <- subset.data.frame(df.sloth2, select = c(PATCH_AREA, DIST_ROAD,PD, LPI,AREA_WM))
df.sloth4.log <- log(df.sloth4)
colnames(df.sloth4.log) <- paste0("log", colnames(df.sloth4.log))
# data subset with only normal non-transformed variables
df.sloth.normal <- subset.data.frame(df.sloth3, select = c(DIST_RIP_F,ECON_AM,EDGE,GYRATE_WM,PATCH_GYRA,PR,SHAPE_WM))
# sqrt CWED
df.sloth3.sqrt <- sqrt(df.sloth3["CWED"])
colnames(df.sloth3.sqrt) <- paste0("sqrt", colnames(df.sloth3.sqrt))
# squared SIDI
sq <- function(x){
x^2
}
df.sloth3sq <- sq(df.sloth3["SIDI"])
colnames(df.sloth3sq) <- paste0("square", colnames(df.sloth3sq))
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("MixedEffects.Rmd")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("MixedEffects.Rmd")
library(Matrix)
library(lme4)
library(MASS)
library(arm)
library(sjstats)
library(ResourceSelection)
# load in
df.rikz <- read.csv("RIKZ.csv")
# load in
df.rikz <- read.csv("RIKZ.txt")
# test for correlation
abs(cor(df.rikz[,c(2,5)]))
# load in
df.rikz <- read.table("RIKZ.txt",header=T)
# test for correlation
abs(cor(df.rikz[,c(2,5)]))
# define the model
lme.rikz <- lmer(Richness ~ NAP + (1 | Beach), data = df.rikz)
# residual vs fitted plot
plot(lme.rikz, xlab = "Fitted", ylab = "Residual")
install.packages(c("quantreg", "Qtools"))
rmd2rscript("QuantileRegression.Rmd")
knitr::opts_chunk$set(echo = TRUE,cache=TRUE)
suppressWarnings(library(vegan))
suppressWarnings(library(MASS))
data(varespec)
head(varespec)
sum(varespec==0)/(nrow(varespec)*ncol(varespec)) # 42% of the data are zeroes
dim(varespec) # 44 different species, not distributed evenly among sites
data(mtcars)
head(mtcars)
dim(mtcars)
cars<-mtcars[,-c(8:9)] # remove categorical variables
mtcars.pca<-prcomp(mtcars[,c(1:7,10,11)], center = TRUE,scale. = TRUE)
summary(mtcars.pca)
biplot(mtcars.pca) # This is a little messy with sample names
rmd2rscript("Ordination.Rmd")
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
rmd2rscript("Ordination.Rmd")
install.packages("ResourceSelection")
install.packages("amt")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("RSFs.Rmd")
install.packages("aod")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("RSFs.Rmd")
rmd2rscript("RSFs.Rmd")
rmd2rscript("RSFs.Rmd")
install.packages("gplots")
install.packages("ROCR")
install.packages("rms")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render('LECTURE3.Rmd',rmarkdown::pdf_document())
rmd2rscript("LECTURE10.Rmd")
rmd2rscript("LECTURE10.Rmd")
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE5.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE6.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE9.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers("LAB4.Rmd")
rmd2rscript_labanswers("LAB4.Rmd")
?MyxoTiter_sum
rmd2rscript("LECTURE9.Rmd")
unlink('SpatialAutocorrelation_cache', recursive = TRUE)
rmarkdown::render("TimeSeries.Rmd",rmarkdown::pdf_document())
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render("SEM.Rmd",rmarkdown::pdf_document())
rmarkdown::render("SpatialAutocorrelation.Rmd",rmarkdown::pdf_document())
rmarkdown::render("SpatialAutocorrelation.Rmd",rmarkdown::pdf_document())
install.packages("raster")
rmarkdown::render("SpatialAutocorrelation.Rmd",rmarkdown::pdf_document())
rmarkdown::render("BayesianNetworks.Rmd",rmarkdown::pdf_document())
rmarkdown::render("BayesianNetworks.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("MixedEffects.Rmd",rmarkdown::pdf_document())
rmarkdown::render("QuantileRegression.Rmd",rmarkdown::pdf_document())
rmarkdown::render("Ordination.Rmd",rmarkdown::pdf_document())
rmarkdown::render("RSFs.Rmd",rmarkdown::pdf_document())
?mep
?kdepairs
rmarkdown::render("RSFs.Rmd",rmarkdown::pdf_document())
install.packages("randomForest")
install.packages("maptools")
install.packages(c("caret", "e1071"))
knitr::opts_chunk$set(echo = TRUE,cache = TRUE)
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic.tif")
#Load Packages
library("raster")
library("rgdal")
library("sp")
libraryh("maptools")
library("maptools")
library("randomForest")
library("caret")
library("e1071")
#Load Packages
library("raster")
library("rgdal")
library("sp")
library("maptools")
library("randomForest")
library("caret")
library("e1071")
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic.tif")
#Load Packages
library("raster")
library("rgdal")
library("sp")
library("maptools")
library("randomForest")
library("caret")
library("e1071")
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic_Full.tif")
#Rename the band names based on their spectra:
names(lm_highrez_brick) <- c("R","G","B","NIR")
# Import the raster and vector files
# Import the GeoTiff as a "brick" (an R multiband raster file):
lm_highrez_brick <- brick("Mosaic_Full.tif")
#Rename the band names based on their spectra:
names(lm_highrez_brick) <- c("R","G","B","NIR")
# Import the training shapefile:
lm_highrez_training_points <-
readOGR(dsn=".",layer="LM_Training")
# Repeat the process for the testing dataset:
lm_highrez_testing_points <-
readOGR(dsn=".",layer="LM_Test")
# Check out the files
lm_highrez_brick
lm_highrez_training_points
lm_highrez_testing_points
# Look at the attibute table of the training data:
#as.data.frame(lm_highrez_testing_points)
# Plot Data:
plotRGB(lm_highrez_brick)
plot(lm_highrez_training_points,add=TRUE,col="yellow")
plot(lm_highrez_testing_points,add=TRUE,col="orange")
