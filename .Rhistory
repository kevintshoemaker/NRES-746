alternates$half <- newsimplex
alternates$double[[1]] <- double + oldpoint
alternates$half[[1]] <- half + oldpoint
alternates$reflected <- alternates$reflected[vertnames]
alternates$double <- alternates$double[vertnames]
alternates$half <- alternates$half[vertnames]
return(alternates)
}
MoveTheSimplex <- function(oldsimplex){     # (incomplete) nelder-mead algorithm
newsimplex <- oldsimplex  #
# Start by identifying the *worst* vertex (the one with the lowest likelihood)
VertexLik <- SimplexLik(newsimplex)
WorstLik <- min(VertexLik)
BestLik <- max(VertexLik)
WorstVertex <- names(VertexLik[which.min(VertexLik)])    # identify vertex with lowest likelihood
candidates <- ReflectIt(oldsimplex=newsimplex,WorstVertex)      # reflect across the remaining edge
CandidateLik <- sapply(candidates,SimplexLik)                          # re-evaluate likelihood at the vertices...
CandidateLik <- apply(CandidateLik,c(1,2), function(t) ifelse(is.nan(t),-99999,t))
bestCandidate <- names(which.max(CandidateLik[WorstVertex,]))
bestCandidateLik <- CandidateLik[WorstVertex,bestCandidate]
if(CandidateLik[WorstVertex,"reflected"]>=WorstLik){
if(CandidateLik[WorstVertex,"reflected"]>BestLik){
if(CandidateLik[WorstVertex,"double"]>CandidateLik[WorstVertex,"reflected"]){
newsimplex <- candidates[["double"]]    # expansion
}else{
newsimplex <- candidates[["reflected"]]
}
}else if(CandidateLik[WorstVertex,"half"]>CandidateLik[WorstVertex,"reflected"]){   # contraction
newsimplex <- candidates[["half"]]
}else{
newsimplex <- candidates[["reflected"]]
}
}else{
BestVertex <- names(VertexLik[which.max(VertexLik)])
newsimplex <- ShrinkIt(oldsimplex,BestVertex)
}
return(newsimplex)
}
#####
# Helper Functions
#####
## this function reflects the worst vertex across the remaining vector
ReflectIt <- function(oldsimplex,WorstVertex){
vertnames <- names(oldsimplex)
## re-arrange simplex- worst must be first
worstndx <- which(names(oldsimplex)==WorstVertex)
otherndx <- c(1:3)[-worstndx]
newndx <- c(worstndx,otherndx)
## translate so that vertex 1 is the origin (0,0)
oldsimplex <- oldsimplex[newndx]
translate <- oldsimplex[[1]]
newsimplex <- list(oldsimplex[[1]]-translate,oldsimplex[[2]]-translate,oldsimplex[[3]]-translate)
reflected <- c(newsimplex[[2]]["shape"]+newsimplex[[3]]["shape"],newsimplex[[2]]["scale"]+newsimplex[[3]]["scale"])
names(reflected) <- c("shape","scale")
## translate back to the likelihood surface
newsimplex[[1]] <- reflected
newsimplex <- list(newsimplex[[1]]+translate,newsimplex[[2]]+translate,newsimplex[[3]]+translate)
## return the new simplex
names(newsimplex) <- names(oldsimplex)
## generate some alternative jumps (or "oozes"!)...
oldpoint <- oldsimplex[[1]]
newpoint <- newsimplex[[1]]
newpoint2 <- newpoint-oldpoint
double <- newpoint2 * 3
half <- newpoint2 * 0.24
alternates <- list()
alternates$reflected <- newsimplex
alternates$double <- newsimplex
alternates$half <- newsimplex
alternates$double[[1]] <- double + oldpoint
alternates$half[[1]] <- half + oldpoint
alternates$reflected <- alternates$reflected[vertnames]
alternates$double <- alternates$double[vertnames]
alternates$half <- alternates$half[vertnames]
return(alternates)
}
ShrinkIt <- function(oldsimplex,BestVertex){
newsimplex <- oldsimplex
## indices...
bestndx <- which(names(oldsimplex)==BestVertex)
otherndx <- c(1:3)[-bestndx]
translate <- oldsimplex[[bestndx]]
i=2
for(i in otherndx){
newvector <- oldsimplex[[i]]-translate
shrinkvector <- newvector * 0.5
newsimplex[[i]] <- shrinkvector + translate
}
return(newsimplex)
}
MoveTheSimplex <- function(oldsimplex){     # (incomplete) nelder-mead algorithm
newsimplex <- oldsimplex  #
# Start by identifying the *worst* vertex (the one with the lowest likelihood)
VertexLik <- SimplexLik(newsimplex)
WorstLik <- min(VertexLik)
BestLik <- max(VertexLik)
WorstVertex <- names(VertexLik[which.min(VertexLik)])    # identify vertex with lowest likelihood
candidates <- ReflectIt(oldsimplex=newsimplex,WorstVertex)      # reflect across the remaining edge
CandidateLik <- sapply(candidates,SimplexLik)                          # re-evaluate likelihood at the vertices...
CandidateLik <- apply(CandidateLik,c(1,2), function(t) ifelse(is.nan(t),-99999,t))
bestCandidate <- names(which.max(CandidateLik[WorstVertex,]))
bestCandidateLik <- CandidateLik[WorstVertex,bestCandidate]
if(CandidateLik[WorstVertex,"reflected"]>=WorstLik){
if(CandidateLik[WorstVertex,"reflected"]>BestLik){
if(CandidateLik[WorstVertex,"double"]>CandidateLik[WorstVertex,"reflected"]){
newsimplex <- candidates[["double"]]    # expansion
}else{
newsimplex <- candidates[["reflected"]]
}
}else if(CandidateLik[WorstVertex,"half"]>CandidateLik[WorstVertex,"reflected"]){   # contraction
newsimplex <- candidates[["half"]]
}else{
newsimplex <- candidates[["reflected"]]
}
}else{
BestVertex <- names(VertexLik[which.max(VertexLik)])
newsimplex <- ShrinkIt(oldsimplex,BestVertex)
}
return(newsimplex)
}
# image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
# contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
# addSimplex(oldsimplex,col="red")
# addSimplex(candidates$reflected,col="green")
# addSimplex(candidates$half,col="green")
###########
# Visualize the simplex
oldsimplex <- simplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex)
#####
# Helper Functions
#####
## this function reflects the worst vertex across the remaining vector
ReflectIt <- function(oldsimplex,WorstVertex){
vertnames <- names(oldsimplex)
## re-arrange simplex- worst must be first
worstndx <- which(names(oldsimplex)==WorstVertex)
otherndx <- c(1:3)[-worstndx]
newndx <- c(worstndx,otherndx)
## translate so that vertex 1 is the origin (0,0)
oldsimplex <- oldsimplex[newndx]
translate <- oldsimplex[[1]]
newsimplex <- list(oldsimplex[[1]]-translate,oldsimplex[[2]]-translate,oldsimplex[[3]]-translate)
reflected <- c(newsimplex[[2]]["shape"]+newsimplex[[3]]["shape"],newsimplex[[2]]["scale"]+newsimplex[[3]]["scale"])
names(reflected) <- c("shape","scale")
## translate back to the likelihood surface
newsimplex[[1]] <- reflected
newsimplex <- list(newsimplex[[1]]+translate,newsimplex[[2]]+translate,newsimplex[[3]]+translate)
## return the new simplex
names(newsimplex) <- names(oldsimplex)
## generate some alternative jumps (or "oozes"!)...
oldpoint <- oldsimplex[[1]]
newpoint <- newsimplex[[1]]
newpoint2 <- newpoint-oldpoint
double <- newpoint2 * 3
half <- newpoint2 * 0.24
alternates <- list()
alternates$reflected <- newsimplex
alternates$double <- newsimplex
alternates$half <- newsimplex
alternates$double[[1]] <- double + oldpoint
alternates$half[[1]] <- half + oldpoint
alternates$reflected <- alternates$reflected[vertnames]
alternates$double <- alternates$double[vertnames]
alternates$half <- alternates$half[vertnames]
return(alternates)
}
ShrinkIt <- function(oldsimplex,BestVertex){
newsimplex <- oldsimplex
## indices...
bestndx <- which(names(oldsimplex)==BestVertex)
otherndx <- c(1:3)[-bestndx]
translate <- oldsimplex[[bestndx]]
i=2
for(i in otherndx){
newvector <- oldsimplex[[i]]-translate
shrinkvector <- newvector * 0.5
newsimplex[[i]] <- shrinkvector + translate
}
return(newsimplex)
}
MoveTheSimplex <- function(oldsimplex){     # (incomplete) nelder-mead algorithm
newsimplex <- oldsimplex  #
# Start by identifying the *worst* vertex (the one with the lowest likelihood)
VertexLik <- SimplexLik(newsimplex)
WorstLik <- min(VertexLik)
BestLik <- max(VertexLik)
WorstVertex <- names(VertexLik[which.min(VertexLik)])    # identify vertex with lowest likelihood
candidates <- ReflectIt(oldsimplex=newsimplex,WorstVertex)      # reflect across the remaining edge
CandidateLik <- sapply(candidates,SimplexLik)                          # re-evaluate likelihood at the vertices...
CandidateLik <- apply(CandidateLik,c(1,2), function(t) ifelse(is.nan(t),-99999,t))
bestCandidate <- names(which.max(CandidateLik[WorstVertex,]))
bestCandidateLik <- CandidateLik[WorstVertex,bestCandidate]
if(CandidateLik[WorstVertex,"reflected"]>=WorstLik){
if(CandidateLik[WorstVertex,"reflected"]>BestLik){
if(CandidateLik[WorstVertex,"double"]>CandidateLik[WorstVertex,"reflected"]){
newsimplex <- candidates[["double"]]    # expansion
}else{
newsimplex <- candidates[["reflected"]]
}
}else if(CandidateLik[WorstVertex,"half"]>CandidateLik[WorstVertex,"reflected"]){   # contraction
newsimplex <- candidates[["half"]]
}else{
newsimplex <- candidates[["reflected"]]
}
}else{
BestVertex <- names(VertexLik[which.max(VertexLik)])
newsimplex <- ShrinkIt(oldsimplex,BestVertex)
}
return(newsimplex)
}
# image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
# contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
# addSimplex(oldsimplex,col="red")
# addSimplex(candidates$reflected,col="green")
# addSimplex(candidates$half,col="green")
###########
# Visualize the simplex
oldsimplex <- simplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex,col="green")
############
# Make another move
oldsimplex <- newsimplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex)
############
# Make another move
oldsimplex <- newsimplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex,col="green")
############
# Make another move
oldsimplex <- newsimplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex,col="green")
############
# Make another move
oldsimplex <- newsimplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex,col="green")
############
# Make another few moves
par(mfrow=c(2,2))
for(i in 1:4){
oldsimplex <- newsimplex
newsimplex <- MoveTheSimplex(oldsimplex)
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
addSimplex(oldsimplex,col="red")
addSimplex(newsimplex,col="green")
}
############
# Build a simplex optimization function!
SimplexMethod <- function(firstguess,tolerance=0.00001){
initsimplex <- list()
initsimplex[['vertex1']] <- firstguess + c(5,0.05)
initsimplex[['vertex2']] <- firstguess + c(-5,-0.05)
initsimplex[['vertex3']] <- firstguess + c(5,-0.05)
VertexLik <- SimplexLik(initsimplex)
oldbestlik <- VertexLik[which.max(VertexLik)]
deltalik <- 100
counter <- 0
while(counter<100){
newsimplex <- MoveTheSimplex(oldsimplex)
VertexLik <- SimplexLik(newsimplex)
bestlik <- VertexLik[which.max(VertexLik)]
deltalik <- bestlik-oldbestlik
oldsimplex <- newsimplex
oldbestlik <- bestlik
counter <- counter+1
}
mle <- list()
mle$estimate <- newsimplex[[1]]
mle$likelihood <- bestlik
mle$iterations <- counter
return(mle)
}
SimplexMethod(firstguess = c(shape=39,scale=0.28))
MLE
unlink("LECTURE5_cache", recursive = TRUE)
################
# Simulated annealing!
startingvals <- c(shape=80,scale=0.15)
startinglik <- GammaLikelihoodFunction(startingvals)
startinglik
k = 100   # set the "temperature"
# function for making new guesses
newGuess <- function(oldguess=startingvals){
maxshapejump <- 5
maxscalejump <- 0.05
jump <- c(runif(1,-maxshapejump,maxshapejump),runif(1,-maxscalejump,maxscalejump))
newguess <- oldguess + jump
return(newguess)
}
# set a new "guess" near to the original guess
newGuess(oldguess=startingvals)     # each time is different- this is the first optimization procedure with randomness built in
newGuess(oldguess=startingvals)
newGuess(oldguess=startingvals)
############
# run and visualize a Metropolis simulated annealing routine
k <- 100
oldguess <- startingvals
counter <- 0
guesses <- matrix(0,nrow=100,ncol=2)
colnames(guesses) <- names(startingvals)
while(counter<100){
newguess <- newGuess(oldguess)
loglikdif <- LikDif(oldguess,newguess)
if(loglikdif>0){
oldguess <- newguess
}else{
rand=runif(1)
if(rand <= exp(loglikdif/k)){
oldguess <- newguess   # accept even if worse!
}
}
counter <- counter + 1
guesses[counter,] <- oldguess
}
############
# evaluate the difference in likelihood between the new proposal and the old point
LikDif <- function(oldguess,newguess){
oldLik <- GammaLikelihoodFunction(oldguess)
newLik <- GammaLikelihoodFunction(newguess)
return(newLik-oldLik)
}
newguess <- newGuess(oldguess=startingvals)
loglikdif <- LikDif(oldguess=startingvals,newguess)
loglikdif
################
# Simulated annealing!
startingvals <- c(shape=80,scale=0.15)
startinglik <- GammaLikelihoodFunction(startingvals)
startinglik
k = 100   # set the "temperature"
# function for making new guesses
newGuess <- function(oldguess=startingvals){
maxshapejump <- 5
maxscalejump <- 0.05
jump <- c(runif(1,-maxshapejump,maxshapejump),runif(1,-maxscalejump,maxscalejump))
newguess <- oldguess + jump
return(newguess)
}
# set a new "guess" near to the original guess
newGuess(oldguess=startingvals)     # each time is different- this is the first optimization procedure with randomness built in
newGuess(oldguess=startingvals)
newGuess(oldguess=startingvals)
############
# run and visualize a Metropolis simulated annealing routine
k <- 100
oldguess <- startingvals
counter <- 0
guesses <- matrix(0,nrow=100,ncol=2)
colnames(guesses) <- names(startingvals)
while(counter<100){
newguess <- newGuess(oldguess)
loglikdif <- LikDif(oldguess,newguess)
if(loglikdif>0){
oldguess <- newguess
}else{
rand=runif(1)
if(rand <= exp(loglikdif/k)){
oldguess <- newguess   # accept even if worse!
}
}
counter <- counter + 1
guesses[counter,] <- oldguess
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
###########
# Run it for longer!
k <- 10
oldguess <- startingvals
counter <- 0
guesses <- matrix(0,nrow=1000,ncol=2)
colnames(guesses) <- names(startingvals)
while(counter<1000){
newguess <- newGuess(oldguess)
loglikdif <- LikDif(oldguess,newguess)
if(loglikdif>0){
oldguess <- newguess
}else{
rand=runif(1)
if(rand <= exp(loglikdif/k)){
oldguess <- newguess   # accept even if worse!
}
}
counter <- counter + 1
guesses[counter,] <- oldguess
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
#############
# cool the "temperature" over time and let the algorithm settle down
k <- 100
oldguess <- startingvals
counter <- 0
guesses <- matrix(0,nrow=10000,ncol=2)
colnames(guesses) <- names(startingvals)
MLE <- list(vals=startingvals,lik=GammaLikelihoodFunction(startingvals),step=0)
while(counter<10000){
newguess <- newGuess(oldguess)
loglikdif <- LikDif(oldguess,newguess)
if(loglikdif>0){
oldguess <- newguess
}else{
rand=runif(1)
if(rand <= exp(loglikdif/k)){
oldguess <- newguess   # accept even if worse!
}
}
counter <- counter + 1
if(counter%%100==0) k <- k*0.8
guesses[counter,] <- oldguess
thislik <- GammaLikelihoodFunction(oldguess)
if(thislik>MLE$lik) MLE <- list(vals=oldguess,lik=GammaLikelihoodFunction(oldguess),step=counter)
}
# visualize!
image(x=shapevec,y=scalevec,z=surface2D,zlim=c(-1000,-30),col=topo.colors(12))
contour(x=shapevec,y=scalevec,z=surface2D,levels=c(-30,-40,-80,-500),add=T)
lines(guesses,col="red")
points(MLE$vals[1],MLE$vals[2],col="green",pch=20,cex=3)
MLE
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("LECTURE4.Rmd")
rmd2rscript("LECTURE4.Rmd")
rmd2rscript("LECTURE5.Rmd")
rmd2rscript("LECTURE4.Rmd")
rmd2rscript("LECTURE5.Rmd")
rmd2rscript("LECTURE6.Rmd")
rmd2rscript("LECTURE5.Rmd")
rmd2rscript("LECTURE6.Rmd")
rmd2rscript("LECTURE7.Rmd")  ##
?jags
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(R2jags)
library(jagsUI)
?jags
unlink("LECTURE7_cache", recursive = TRUE)
