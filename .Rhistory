}
jags.fit_ricker <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs,parameters.to.save=params.to.store,n.iter=50000,model.file="BUGSmodel_ricker.txt",n.chains = 3,n.burnin = 5000,n.thin = 20 )
jags.fit_mm <- jags(data=myx.data.for.bugs,inits=init.vals.for.bugs2,parameters.to.save=params.to.store,n.iter=50000,model.file="BUGSmodel_mm.txt",n.chains = 3,n.burnin = 5000,n.thin = 20 )
Myx_PostPredCheck <- function(MCMC1=jags.fit_ricker,MCMC2=jags.fit_mm){
lots <- 1000
nMCMC <- min(jags.fit_ricker$BUGSoutput$n.keep,jags.fit_mm$BUGSoutput$n.keep)
# hard-code the data
MyxDat <- MyxoTiter_sum
Myx <- subset(MyxDat,grade==1)  #Data set from grade 1 of myxo data
nobs <- nrow(Myx)
SSEobs_rick <- numeric(lots)
SSEobs_mm <- numeric(lots)
SSEsim_rick <- numeric(lots)
SSEsim_mm <- numeric(lots)
params_rick <- matrix(NA, nrow=lots,ncol=3)
params_mm <- matrix(NA, nrow=lots,ncol=3)
colnames(params_rick) <- c("a","b","shape")
colnames(params_mm) <- c("a","b","shape")
alldays <- sort(unique(Myx$day))
allsims_rick <- matrix(nrow=lots,ncol=length(alldays))
allsims_mm <- matrix(nrow=lots,ncol=length(alldays))
colnames(allsims_rick) <- alldays
colnames(allsims_mm) <- alldays
i=2
for(i in 1:lots){
random_index <- sample(1:nMCMC,1)
params_rick[i,] <- c(a=MCMC1$BUGSoutput$sims.list$a[random_index],
b=MCMC1$BUGSoutput$sims.list$b[random_index],
shape=MCMC1$BUGSoutput$sims.list$shape[random_index])
params_mm[i,] <- c(a=MCMC2$BUGSoutput$sims.list$a[random_index],
b=MCMC2$BUGSoutput$sims.list$b[random_index],
shape=MCMC2$BUGSoutput$sims.list$shape[random_index])
### loop through titer observations
exptiter_rick <- Ricker(Myx$day,params_rick[i,"a"],params_rick[i,"b"])
exptiter_mm <- MMFunc(Myx$day,params_mm[i,"a"],params_mm[i,"b"])
simobs_rick <- rgamma(nobs,shape=params_rick[i,"shape"],rate=(params_rick[i,"shape"]/exptiter_rick))
simobs_mm <- rgamma(nobs,shape=params_mm[i,"shape"],rate=(params_mm[i,"shape"]/exptiter_mm))
SSEobs_rick[i] <- sum((Myx$titer-exptiter_rick)^2)
SSEobs_mm[i] <- sum((Myx$titer-exptiter_mm)^2)
SSEsim_rick[i] <- sum((simobs_rick-exptiter_rick)^2)
SSEsim_mm[i] <- sum((simobs_mm-exptiter_mm)^2)
allsims_rick[i,] <- tapply(simobs_rick,Myx$day,function(t) t[sample.int(length(t))][1] )
allsims_mm[i,] <- tapply(simobs_mm,Myx$day,function(t) t[sample.int(length(t))][1] )
}
boxplot(allsims_rick,xlab="Days",ylab="Titer",xlim=c(0,10),main="Ricker",at=as.numeric(colnames(allsims_rick)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
boxplot(allsims_mm,xlab="Days",ylab="Titer",xlim=c(0,10),main="M-M",at=as.numeric(colnames(allsims_mm)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
plot(SSEsim_rick~SSEobs_rick,main="Posterior Pred Check, Ricker")
abline(0,1,col="red")
plot(SSEsim_mm~SSEobs_mm,main="Posterior Pred Check, M-M")
abline(0,1,col="red")
pval_rick <- length(which(SSEsim_rick>SSEobs_rick))/lots
pval_mm <- length(which(SSEsim_mm>SSEobs_mm))/lots
output <- list()
output[["p-vals"]] <- c(pval_rick,pval_mm)
output[["PPC_rick"]] <- as.data.frame(cbind(params_rick,SSEsim_rick,SSEobs_rick))
output[["PPC_mm"]] <- as.data.frame(cbind(params_mm,SSEsim_mm,SSEobs_mm))
colnames <- c("a","b","shape","SSEsim","SSEobs")
names(output[["PPC_rick"]]) <- colnames
names(output[["PPC_mm"]]) <- colnames
return(output)
Myx_PostPredCheck <- function(MCMC1=jags.fit_ricker,MCMC2=jags.fit_mm){
lots <- 1000
nMCMC <- min(jags.fit_ricker$BUGSoutput$n.keep,jags.fit_mm$BUGSoutput$n.keep)
# hard-code the data
MyxDat <- MyxoTiter_sum
Myx <- subset(MyxDat,grade==1)  #Data set from grade 1 of myxo data
nobs <- nrow(Myx)
SSEobs_rick <- numeric(lots)
SSEobs_mm <- numeric(lots)
SSEsim_rick <- numeric(lots)
SSEsim_mm <- numeric(lots)
params_rick <- matrix(NA, nrow=lots,ncol=3)
params_mm <- matrix(NA, nrow=lots,ncol=3)
colnames(params_rick) <- c("a","b","shape")
colnames(params_mm) <- c("a","b","shape")
alldays <- sort(unique(Myx$day))
allsims_rick <- matrix(nrow=lots,ncol=length(alldays))
allsims_mm <- matrix(nrow=lots,ncol=length(alldays))
colnames(allsims_rick) <- alldays
colnames(allsims_mm) <- alldays
i=2
for(i in 1:lots){
random_index <- sample(1:nMCMC,1)
params_rick[i,] <- c(a=MCMC1$BUGSoutput$sims.list$a[random_index],
b=MCMC1$BUGSoutput$sims.list$b[random_index],
shape=MCMC1$BUGSoutput$sims.list$shape[random_index])
params_mm[i,] <- c(a=MCMC2$BUGSoutput$sims.list$a[random_index],
b=MCMC2$BUGSoutput$sims.list$b[random_index],
shape=MCMC2$BUGSoutput$sims.list$shape[random_index])
### loop through titer observations
exptiter_rick <- Ricker(Myx$day,params_rick[i,"a"],params_rick[i,"b"])
exptiter_mm <- MMFunc(Myx$day,params_mm[i,"a"],params_mm[i,"b"])
simobs_rick <- rgamma(nobs,shape=params_rick[i,"shape"],rate=(params_rick[i,"shape"]/exptiter_rick))
simobs_mm <- rgamma(nobs,shape=params_mm[i,"shape"],rate=(params_mm[i,"shape"]/exptiter_mm))
SSEobs_rick[i] <- sum((Myx$titer-exptiter_rick)^2)
SSEobs_mm[i] <- sum((Myx$titer-exptiter_mm)^2)
SSEsim_rick[i] <- sum((simobs_rick-exptiter_rick)^2)
SSEsim_mm[i] <- sum((simobs_mm-exptiter_mm)^2)
allsims_rick[i,] <- tapply(simobs_rick,Myx$day,function(t) t[sample.int(length(t))][1] )
allsims_mm[i,] <- tapply(simobs_mm,Myx$day,function(t) t[sample.int(length(t))][1] )
}
boxplot(allsims_rick,xlab="Days",ylab="Titer",xlim=c(0,10),main="Ricker",at=as.numeric(colnames(allsims_rick)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
boxplot(allsims_mm,xlab="Days",ylab="Titer",xlim=c(0,10),main="M-M",at=as.numeric(colnames(allsims_mm)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
plot(SSEsim_rick~SSEobs_rick,main="Posterior Pred Check, Ricker")
abline(0,1,col="red")
plot(SSEsim_mm~SSEobs_mm,main="Posterior Pred Check, M-M")
abline(0,1,col="red")
pval_rick <- length(which(SSEsim_rick>SSEobs_rick))/lots
pval_mm <- length(which(SSEsim_mm>SSEobs_mm))/lots
output <- list()
output[["p-vals"]] <- c(pval_rick,pval_mm)
output[["PPC_rick"]] <- as.data.frame(cbind(params_rick,SSEsim_rick,SSEobs_rick))
output[["PPC_mm"]] <- as.data.frame(cbind(params_mm,SSEsim_mm,SSEobs_mm))
colnames <- c("a","b","shape","SSEsim","SSEobs")
names(output[["PPC_rick"]]) <- colnames
names(output[["PPC_mm"]]) <- colnames
return(output)
Myx_PostPredCheck <- function(MCMC1=jags.fit_ricker,MCMC2=jags.fit_mm){
lots <- 1000
nMCMC <- min(jags.fit_ricker$BUGSoutput$n.keep,jags.fit_mm$BUGSoutput$n.keep)
# hard-code the data
MyxDat <- MyxoTiter_sum
Myx <- subset(MyxDat,grade==1)  #Data set from grade 1 of myxo data
nobs <- nrow(Myx)
SSEobs_rick <- numeric(lots)
SSEobs_mm <- numeric(lots)
SSEsim_rick <- numeric(lots)
SSEsim_mm <- numeric(lots)
params_rick <- matrix(NA, nrow=lots,ncol=3)
params_mm <- matrix(NA, nrow=lots,ncol=3)
colnames(params_rick) <- c("a","b","shape")
colnames(params_mm) <- c("a","b","shape")
alldays <- sort(unique(Myx$day))
allsims_rick <- matrix(nrow=lots,ncol=length(alldays))
allsims_mm <- matrix(nrow=lots,ncol=length(alldays))
colnames(allsims_rick) <- alldays
colnames(allsims_mm) <- alldays
i=2
for(i in 1:lots){
random_index <- sample(1:nMCMC,1)
params_rick[i,] <- c(a=MCMC1$BUGSoutput$sims.list$a[random_index],
b=MCMC1$BUGSoutput$sims.list$b[random_index],
shape=MCMC1$BUGSoutput$sims.list$shape[random_index])
params_mm[i,] <- c(a=MCMC2$BUGSoutput$sims.list$a[random_index],
b=MCMC2$BUGSoutput$sims.list$b[random_index],
shape=MCMC2$BUGSoutput$sims.list$shape[random_index])
### loop through titer observations
exptiter_rick <- Ricker(Myx$day,params_rick[i,"a"],params_rick[i,"b"])
exptiter_mm <- MMFunc(Myx$day,params_mm[i,"a"],params_mm[i,"b"])
simobs_rick <- rgamma(nobs,shape=params_rick[i,"shape"],rate=(params_rick[i,"shape"]/exptiter_rick))
simobs_mm <- rgamma(nobs,shape=params_mm[i,"shape"],rate=(params_mm[i,"shape"]/exptiter_mm))
SSEobs_rick[i] <- sum((Myx$titer-exptiter_rick)^2)
SSEobs_mm[i] <- sum((Myx$titer-exptiter_mm)^2)
SSEsim_rick[i] <- sum((simobs_rick-exptiter_rick)^2)
SSEsim_mm[i] <- sum((simobs_mm-exptiter_mm)^2)
allsims_rick[i,] <- tapply(simobs_rick,Myx$day,function(t) t[sample.int(length(t))][1] )
allsims_mm[i,] <- tapply(simobs_mm,Myx$day,function(t) t[sample.int(length(t))][1] )
}
boxplot(allsims_rick,xlab="Days",ylab="Titer",xlim=c(0,10),main="Ricker",at=as.numeric(colnames(allsims_rick)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
boxplot(allsims_mm,xlab="Days",ylab="Titer",xlim=c(0,10),main="M-M",at=as.numeric(colnames(allsims_mm)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
plot(SSEsim_rick~SSEobs_rick,main="Posterior Pred Check, Ricker")
abline(0,1,col="red")
plot(SSEsim_mm~SSEobs_mm,main="Posterior Pred Check, M-M")
abline(0,1,col="red")
pval_rick <- length(which(SSEsim_rick>SSEobs_rick))/lots
pval_mm <- length(which(SSEsim_mm>SSEobs_mm))/lots
output <- list()
output[["p-vals"]] <- c(pval_rick,pval_mm)
output[["PPC_rick"]] <- as.data.frame(cbind(params_rick,SSEsim_rick,SSEobs_rick))
output[["PPC_mm"]] <- as.data.frame(cbind(params_mm,SSEsim_mm,SSEobs_mm))
colnames <- c("a","b","shape","SSEsim","SSEobs")
names(output[["PPC_rick"]]) <- colnames
names(output[["PPC_mm"]]) <- colnames
return(output)
}
Myx_PostPredCheck <- function(MCMC1=jags.fit_ricker,MCMC2=jags.fit_mm){
lots <- 1000
nMCMC <- min(jags.fit_ricker$BUGSoutput$n.keep,jags.fit_mm$BUGSoutput$n.keep)
# hard-code the data
MyxDat <- MyxoTiter_sum
Myx <- subset(MyxDat,grade==1)  #Data set from grade 1 of myxo data
nobs <- nrow(Myx)
SSEobs_rick <- numeric(lots)
SSEobs_mm <- numeric(lots)
SSEsim_rick <- numeric(lots)
SSEsim_mm <- numeric(lots)
params_rick <- matrix(NA, nrow=lots,ncol=3)
params_mm <- matrix(NA, nrow=lots,ncol=3)
colnames(params_rick) <- c("a","b","shape")
colnames(params_mm) <- c("a","b","shape")
alldays <- sort(unique(Myx$day))
allsims_rick <- matrix(nrow=lots,ncol=length(alldays))
allsims_mm <- matrix(nrow=lots,ncol=length(alldays))
colnames(allsims_rick) <- alldays
colnames(allsims_mm) <- alldays
i=2
for(i in 1:lots){
random_index <- sample(1:nMCMC,1)
params_rick[i,] <- c(a=MCMC1$BUGSoutput$sims.list$a[random_index],
b=MCMC1$BUGSoutput$sims.list$b[random_index],
shape=MCMC1$BUGSoutput$sims.list$shape[random_index])
params_mm[i,] <- c(a=MCMC2$BUGSoutput$sims.list$a[random_index],
b=MCMC2$BUGSoutput$sims.list$b[random_index],
shape=MCMC2$BUGSoutput$sims.list$shape[random_index])
### loop through titer observations
exptiter_rick <- Ricker(Myx$day,params_rick[i,"a"],params_rick[i,"b"])
exptiter_mm <- MMFunc(Myx$day,params_mm[i,"a"],params_mm[i,"b"])
simobs_rick <- rgamma(nobs,shape=params_rick[i,"shape"],rate=(params_rick[i,"shape"]/exptiter_rick))
simobs_mm <- rgamma(nobs,shape=params_mm[i,"shape"],rate=(params_mm[i,"shape"]/exptiter_mm))
SSEobs_rick[i] <- sum((Myx$titer-exptiter_rick)^2)
SSEobs_mm[i] <- sum((Myx$titer-exptiter_mm)^2)
SSEsim_rick[i] <- sum((simobs_rick-exptiter_rick)^2)
SSEsim_mm[i] <- sum((simobs_mm-exptiter_mm)^2)
allsims_rick[i,] <- tapply(simobs_rick,Myx$day,function(t) t[sample.int(length(t))][1] )
allsims_mm[i,] <- tapply(simobs_mm,Myx$day,function(t) t[sample.int(length(t))][1] )
}
boxplot(allsims_rick,xlab="Days",ylab="Titer",xlim=c(0,10),main="Ricker",at=as.numeric(colnames(allsims_rick)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
boxplot(allsims_mm,xlab="Days",ylab="Titer",xlim=c(0,10),main="M-M",at=as.numeric(colnames(allsims_mm)))
points(Myx$day,Myx$titer,col="green",pch=19,cex=2)
plot(SSEsim_rick~SSEobs_rick,main="Posterior Pred Check, Ricker")
abline(0,1,col="red")
plot(SSEsim_mm~SSEobs_mm,main="Posterior Pred Check, M-M")
abline(0,1,col="red")
pval_rick <- length(which(SSEsim_rick>SSEobs_rick))/lots
pval_mm <- length(which(SSEsim_mm>SSEobs_mm))/lots
output <- list()
output[["p-vals"]] <- c(pval_rick,pval_mm)
output[["PPC_rick"]] <- as.data.frame(cbind(params_rick,SSEsim_rick,SSEobs_rick))
output[["PPC_mm"]] <- as.data.frame(cbind(params_mm,SSEsim_mm,SSEobs_mm))
colnames <- c("a","b","shape","SSEsim","SSEobs")
names(output[["PPC_rick"]]) <- colnames
names(output[["PPC_mm"]]) <- colnames
return(output)
}
test <- Myx_PostPredCheck(MCMC1=jags.fit_ricker,MCMC2=jags.fit_mm)
test[[1]]   # p-vals
DIC_ricker <- jags.fit_ricker$DIC
DIC_MM <- jags.fit_ricker$DIC
DIC_ricker <- jags.fit_ricker$DIC
DIC_MM <- jags.fit_MM$DIC
DIC_MM <- jags.fit_mm$DIC
DIC_ricker
DIC_ricker <- jags.fit_ricker$BUGSoutput$DIC
DIC_MM <- jags.fit_mm$BUGSoutput$DIC
DIC_ricker
DIC_MM
library(loo)    # for computing WAIC
?loo::waic
avals <- jags.fit_ricker$BUGSoutput$sims.list$a
bvals <- jags.fit_ricker$BUGSoutput$sims.list$b
svals <- jags.fit_ricker$BUGSoutput$sims.list$shape
t=1
Ricker(Myx$day,avals[t],bvals[t])
liks_ricker <- sapply(1:nmcmc_ricker,function(t) dgamma(Myx$titer,svals[t],rate=(svals[t]/Ricker(Myx$day,avals[t],bvals[t])))  )
nmcmc_ricker <- jags.fit_ricker$BUGSoutput$n.keep   # number of mcmc samples
avals <- jags.fit_ricker$BUGSoutput$sims.list$a
bvals <- jags.fit_ricker$BUGSoutput$sims.list$b
svals <- jags.fit_ricker$BUGSoutput$sims.list$shape
liks_ricker <- sapply(1:nmcmc_ricker,function(t) dgamma(Myx$titer,svals[t],rate=(svals[t]/Ricker(Myx$day,avals[t],bvals[t])))  )
liks_ricker
nrow(liks_ricker)
nmcmc_ricker <- jags.fit_ricker$BUGSoutput$n.keep   # number of mcmc samples
avals <- jags.fit_ricker$BUGSoutput$sims.list$a
bvals <- jags.fit_ricker$BUGSoutput$sims.list$b
svals <- jags.fit_ricker$BUGSoutput$sims.list$shape
liks_ricker <- t(sapply(1:nmcmc_ricker,function(t) dgamma(Myx$titer,svals[t],rate=(svals[t]/Ricker(Myx$day,avals[t],bvals[t])))  ) )
MM()
MMFunc()
nmcmc_mm <- jags.fit_mm$BUGSoutput$n.keep   # number of mcmc samples
avals <- jags.fit_mm$BUGSoutput$sims.list$a
bvals <- jags.fit_mm$BUGSoutput$sims.list$b
svals <- jags.fit_mm$BUGSoutput$sims.list$shape
liks_mm <- t(sapply(1:nmcmc_ricker,function(t) dgamma(Myx$titer,svals[t],rate=(svals[t]/MMFunc(Myx$day,avals[t],bvals[t])))  ) )
nmcmc_ricker <- jags.fit_ricker$BUGSoutput$n.keep   # number of mcmc samples
avals <- jags.fit_ricker$BUGSoutput$sims.list$a
bvals <- jags.fit_ricker$BUGSoutput$sims.list$b
svals <- jags.fit_ricker$BUGSoutput$sims.list$shape
liks_ricker <- t(sapply(1:nmcmc_ricker,function(t) dgamma(Myx$titer,svals[t],rate=(svals[t]/Ricker(Myx$day,avals[t],bvals[t])),log = T)  ) )
nmcmc_mm <- jags.fit_mm$BUGSoutput$n.keep   # number of mcmc samples
avals <- jags.fit_mm$BUGSoutput$sims.list$a
bvals <- jags.fit_mm$BUGSoutput$sims.list$b
svals <- jags.fit_mm$BUGSoutput$sims.list$shape
liks_mm <- t(sapply(1:nmcmc_ricker,function(t) dgamma(Myx$titer,svals[t],rate=(svals[t]/MMFunc(Myx$day,avals[t],bvals[t])),log=T)  ) )
WAIC_ricker <- waic(liks_ricker)
WAIC_mm <- waic(liks_mm)
WAIC_ricker$estimates["waic",]
WAIC_mm$estimates["waic",]
DIC_ricker
DIC_MM
WAIC_ricker$estimates["waic",]
WAIC_mm$estimates["waic",]
install.packages(c("Matrix", "arm", "sjstats", "ResourceSelection"))
install.packages(c("Matrix", "arm", "sjstats", "ResourceSelection"))
install.packages("ResourceSelection")
install.packages("arm")
install.packages("sjstats")
knitr::opts_chunk$set(echo = FALSE)
#######
# Install packages
library(Matrix)
library(lme4)
library(MASS)
library(arm)
library(sjstats)
library(ResourceSelection)
read.table("RIKZ.txt")
read.table("RIKZ.txt",header=T)
# load in
df.rikz <- read.table("RIKZ.txt",header=T)
# test for correlation
abs(cor(df.rikz[,c(2,5)]))
# define the model
lme.rikz <- lmer(Richness ~ NAP + (1 | Beach), data = df.rikz)
# residual vs fitted plot
plot(lme.rikz, xlab = "Fitted", ylab = "Residual")
summary(lme.rikz)
rm(list=ls())
df.sloth <- read.csv("sloth_point5only_withPatchGroup.csv", header = TRUE, sep = ",")
str(df.sloth) # 25 variables with 25 observations
# drop metadata, response, random effect, categorical data
df.sloth2 <- subset.data.frame(df.sloth, select = -c(SITE_ID, LONGITUDE, LATITUDE, LAND_USE, patch_grou, OCCURRENCE))
df.sloth2$PR <- as.numeric(df.sloth2$PR)
str(df.sloth2)
IsItNormal <- function(df, save = F) { ### should be able to accept any dataframe of arbitrary size & names, if all columns contain data that Shapiro-Wilk test likes
slothtest <- list()
for(i in seq(dim(df)[2])) {
slothtest <- append(slothtest, shapiro.test(df[[i]]))
}
mx.slothtest <- matrix(slothtest, byrow = T, ncol = 4)
df.slothtest <- data.frame(var = as.character(colnames(df)),
W = as.numeric(mx.slothtest[,1]),
p = as.numeric(mx.slothtest[,2]),
row.names = NULL)
if(save == T) {write.table(df.slothtest, file = paste0("IsItNormal", round(as.numeric(Sys.time())), ".csv"), row.names = F, sep = ",")}
return(df.slothtest)
}
IsItNormal(df.sloth2)
df.sloth.log <- as.data.frame(apply(df.sloth2, 2, log))
df.sloth.sqrt <- as.data.frame(apply(df.sloth2, 2, sqrt))
df.sloth.squared <- as.data.frame(apply(df.sloth2, 2, function(x) x^2))
df.slothtest.transformed <- cbind(IsItNormal(df.sloth2),
IsItNormal(df.sloth.log)[,2:3],
IsItNormal(df.sloth.sqrt)[,2:3],
IsItNormal(df.sloth.squared)[,2:3])
colnames(df.slothtest.transformed)[4:5] <- paste0("log.", c("W", "p"))
colnames(df.slothtest.transformed)[6:7] <- paste0("sqrt.", c("W", "p"))
colnames(df.slothtest.transformed)[8:9] <- paste0("squared.", c("W", "p"))
# Table defining the normality at different transformations saved to your drive
write.table(df.slothtest.transformed, file = paste0("AreTransformedSlothsNormal_", round(as.numeric(Sys.time())), ".csv"), row.names = F, sep = ",")
# data subsetted removing "never normal columns" based on normality tests
df.sloth3 <- subset.data.frame(df.sloth2, select = -c(CONTAG, DIST_SEC_F, PATCH_SHAP, PLAND_SF, SIEI))
# Log transform "PATCH_AREA", "DIST_ROAD","PD", "LPI","AREA_WM"
df.sloth4 <- subset.data.frame(df.sloth2, select = c(PATCH_AREA, DIST_ROAD,PD, LPI,AREA_WM))
df.sloth4.log <- log(df.sloth4)
colnames(df.sloth4.log) <- paste0("log", colnames(df.sloth4.log))
# data subset with only normal non-transformed variables
df.sloth.normal <- subset.data.frame(df.sloth3, select = c(DIST_RIP_F,ECON_AM,EDGE,GYRATE_WM,PATCH_GYRA,PR,SHAPE_WM))
# sqrt CWED
df.sloth3.sqrt <- sqrt(df.sloth3["CWED"])
colnames(df.sloth3.sqrt) <- paste0("sqrt", colnames(df.sloth3.sqrt))
# squared SIDI
sq <- function(x){
x^2
}
df.sloth3sq <- sq(df.sloth3["SIDI"])
colnames(df.sloth3sq) <- paste0("square", colnames(df.sloth3sq))
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("MixedEffects.Rmd")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("MixedEffects.Rmd")
library(Matrix)
library(lme4)
library(MASS)
library(arm)
library(sjstats)
library(ResourceSelection)
# load in
df.rikz <- read.csv("RIKZ.csv")
# load in
df.rikz <- read.csv("RIKZ.txt")
# test for correlation
abs(cor(df.rikz[,c(2,5)]))
# load in
df.rikz <- read.table("RIKZ.txt",header=T)
# test for correlation
abs(cor(df.rikz[,c(2,5)]))
# define the model
lme.rikz <- lmer(Richness ~ NAP + (1 | Beach), data = df.rikz)
# residual vs fitted plot
plot(lme.rikz, xlab = "Fitted", ylab = "Residual")
install.packages(c("quantreg", "Qtools"))
rmd2rscript("QuantileRegression.Rmd")
knitr::opts_chunk$set(echo = TRUE,cache=TRUE)
suppressWarnings(library(vegan))
suppressWarnings(library(MASS))
data(varespec)
head(varespec)
sum(varespec==0)/(nrow(varespec)*ncol(varespec)) # 42% of the data are zeroes
dim(varespec) # 44 different species, not distributed evenly among sites
data(mtcars)
head(mtcars)
dim(mtcars)
cars<-mtcars[,-c(8:9)] # remove categorical variables
mtcars.pca<-prcomp(mtcars[,c(1:7,10,11)], center = TRUE,scale. = TRUE)
summary(mtcars.pca)
biplot(mtcars.pca) # This is a little messy with sample names
rmd2rscript("Ordination.Rmd")
install_github("vqv/ggbiplot")
library(devtools)
install_github("vqv/ggbiplot")
rmd2rscript("Ordination.Rmd")
