leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(precip, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal, values = values(precip),
title = "Precip"
) %>%
addScaleBar(position = c("bottomleft"))
pal <- colorNumeric("viridis", values(precip),
na.color = "transparent"
)
# map precip raster
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(precip, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal, values = values(precip),
title = "Precip"
) %>%
addScaleBar(position = c("bottomleft"))
# map elevation raster
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(elev, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal, values = values(elev),
title = "Altitude (m)"
) %>%
addScaleBar(position = c("bottomleft"))
pal <- colorNumeric("viridis", values(precip),
na.color = "transparent"
)
pal <- colorNumeric("viridis", values(elev),
na.color = "transparent"
)
# map elevation raster
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(elev, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal, values = values(elev),
title = "Altitude (m)"
) %>%
addScaleBar(position = c("bottomleft"))
df["elev"] <-
terra::extract(elev, df[, c("long", "lat")],
list=T, ID=F, method="bilinear")
head(df)
df["precip"] <-
terra::extract(precip, df[, c("long", "lat")],
list=T, ID=F, method="bilinear")
head(df)
View(df)
coo
rmd2rscript("SpatialRegression.Rmd")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("SpatialRegression.Rmd")
## Build the mesh ----
coo <- cbind(df$long, df$lat) # coordinates of observations
mesh <- inla.mesh.2d(loc = coo,
# loc is coordinates to start the mesh
max.edge = c(0.1, 5),
# max.edge-play around with these values and see
cutoff = 0.01
)
mesh$n
plot(mesh)
points(coo, col = "red")
A <- inla.spde.make.A(mesh = mesh, loc = coo) # coo is coordinates of our observations
A
str(A)
?inla.spde.make.A
mesh$n
dp <- terra::as.points(elev) # this makes the elev raster into a vector of points
dim(dp)
dp
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
# rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts: see NRESlabs folder!!
#   outfile <- gsub(".Rmd",".R",infile)
#   close( file( outfile, open="w" ) )   # clear output file
#   con1 <- file(infile,open="r")
#   con2 <- file(outfile,"w")
#   stringToFind <- "```{r*"
#   stringToFind2 <- c("answer","test","solution")
#   isrblock <- FALSE
#   #count=0
#   blocknum=0
#
#   while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
#     isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
#     showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
#     if(isrblock){
#       blocknum=blocknum+1
#       while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
#         if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#         #count=count+1
#       }
#       isrblock=FALSE
#     }
#   }
#   closeAllConnections()
# }
rmd2rscript("SpatialRegression.Rmd")
rmd2rscript("SpatialRegression.Rmd")
# Spatial regression topic...
# Install packages --------------------
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
# Load packages --------------------
library(geoR) # geoR may be obsolete soon
library(dplyr)
library(sf)
library(leaflet)
library(viridis)
library(terra)
library(geodata)
library(INLA)
library(geostats)
# Load data -------------------------
data(gambia)
head(gambia)
dim(gambia)   # 2035 observations at individual level
dim(unique(gambia[, c("x", "y")]))   # 65 unique locations
rm(gambia.borders)
# Process data -------------------
# For the lab-part 1, different variables, consider other models----
# dplyr and summary statistics to create the new columns
df <- group_by(gambia, x, y) %>%
summarize(
total = n(),
positive = sum(pos),
prev = positive / total,
netuse = mean(netuse),   # for the lab, you could include these
greenness = mean(green)
)
head(df)
# create geometric points from XY
pts <-
st_multipoint(x = as.matrix(df[,1:2]), dim="XY")
# create spatially referenced points: these are in UTM Zone 28 N
sp <-
st_sfc(pts, crs = "+proj=utm +zone=28")
# transform to long lat crs: WGS84
sp_tr <-
st_transform(sp, crs = "+proj=longlat +datum=WGS84")
# add long, lat columns to data frame
df[, c("long", "lat")] <- st_coordinates(sp_tr)[,1:2]
head(df)
# get raster data -----------------
elev <- elevation_30s(country = "GMB",
path = tempdir(), mask = TRUE)
precip <- worldclim_country(country = "GMB",
var="prec", # choose anything!
path = tempdir(),
version=2.1,
mask = TRUE)
precip <- precip$GMB_wc2.1_30s_prec_10
# plot(precip)
# visualize spatial data -------------
pal <- colorBin("viridis", bins = c(0, 0.25, 0.5, 0.75, 1))
leaflet(df) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircles(lng = ~long, lat = ~lat, color = ~ pal(prev)) %>%
addLegend("bottomright",
pal = pal, values = ~prev,
title = "Malaria Prevalence"
) %>%
addScaleBar(position = c("bottomleft"))
pal <- colorNumeric("viridis", values(elev),
na.color = "transparent"
)
# map elevation raster
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(elev, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal, values = values(elev),
title = "Altitude (m)"
) %>%
addScaleBar(position = c("bottomleft"))
pal <- colorNumeric("viridis", values(precip),
na.color = "transparent"
)
# map precip raster
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(precip, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal, values = values(precip),
title = "Precip"
) %>%
addScaleBar(position = c("bottomleft"))
# extract elevation for all observations and add "alt" to dataframe
df["elev"] <-
terra::extract(elev, df[, c("long", "lat")],
list=T, ID=F, method="bilinear")
head(df)
# extract precip for all observations and add "alt" to dataframe
df["precip"] <-
terra::extract(precip, df[, c("long", "lat")],
list=T, ID=F, method="bilinear")
head(df)
# start the INLA spatial regression process -------------------
## Build the mesh ----
coo <- cbind(df$long, df$lat) # coordinates of observations
mesh <- inla.mesh.2d(loc = coo,
# loc is coordinates to start the mesh
max.edge = c(0.1, 5),
# max.edge-play around with these values and see
cutoff = 0.01
)
mesh$n
plot(mesh)
points(coo, col = "red")
# sparse matrix
A <- inla.spde.make.A(mesh = mesh, loc = coo) # coo is coordinates of our observations
stk.nopred <- inla.stack(stk.e, stk.p)  # assembles the data for INLA, similar to how we "package" the data for JAGS
spde <-
inla.spde2.matern(mesh = mesh,
alpha = 2, # 0 > alpha â‰¥ 2
#prior.variance.nominal = 1, # nominal prior mean for the field variance, sigma
#prior.range.nominal = NULL, # nominal prior mean for the spatial range
constr = TRUE) # constr imposes an integrate-to-zero constraint for our model
indexs <-
inla.spde.make.index("s", spde$n.spde)
lengths(indexs)
df$positive
df
df$total
df$positive
stk.e <- inla.stack(
tag = "est", # lets INLA know this is our estimation stack
data = list(y = df$positive, numtrials = df$total),
A = list(1, A), # A, projection matrix
effects = list(data.frame(b0 = 1,
elevation = df$elev, netuse = df$netuse, precip = df$precip), s = indexs)
)
stk.nopred <- inla.stack(stk.e)  # assembles the data for INLA, similar to how we "package" the data for JAGS
formula <- y ~ 0 + b0 + elevation + netuse + precip + f(s, model = spde)
formula
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
control.compute=list(return.marginals.predictor=TRUE),
data = inla.stack.data(stk.full),
control.predictor = list(
compute = TRUE, # this computes the posteriors of the predictions
link = 1,
A = inla.stack.A(stk.full)
)
)
res <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
control.compute=list(return.marginals.predictor=TRUE),
data = inla.stack.data(stk.nopred),
control.predictor = list(
compute = TRUE, # this computes the posteriors of the predictions
link = 1,
A = inla.stack.A(stk.nopred)
)
)
summary(res)
dfp <- terra::as.points(elev) # this makes the elev raster into a vector (spatvector) of points
dim(dfp)
eleva <- terra::aggregate(elev, fact = 4, fun = mean) # reduce the number of raster cells, factor 4 combines 4x4 cells of raster into one cell
precipa <- terra::aggregate(precip, fact = 4, fun = mean)
dfp <- terra::as.points(eleva) # take aggregated raster and turn into vector of points so it is easier to get coordinates from them
crds(dfp)
# then use the crds() function to get coordinates and put everything into a matrix
dfp <- as.matrix(cbind(crds(dfp)[,1], crds(dfp)[,2], values(dp)))
# then use the crds() function to get coordinates and put everything into a matrix
dfp <- as.matrix(cbind(crds(dfp)[,1], crds(dfp)[,2], values(dfp)))
colnames(dfp) <- c("x", "y", "alt")
colnames(dfp) <- c("x", "y", "elev")
View(dfp)
summary(res)
dfp <- as.matrix(cbind(crds(dfp)[,1], crds(dfp)[,2], values(dfp)))
dfp <- terra::as.points(elev) # this makes the elev raster into a vector (spatvector) of points
dim(dfp)  # 12847 points
dfp <- terra::as.points(elev) # this makes the elev raster into a vector (spatvector) of points
dim(dfp)  # 12847 points
eleva <- terra::aggregate(elev, fact = 4, fun = mean) # reduce the number of raster cells, factor 4 combines 4x4 cells of raster into one cell
precipa <- terra::aggregate(precip, fact = 4, fun = mean)
dfp <- terra::as.points(eleva) # take aggregated raster and turn into vector of points so it is easier to get coordinates from them
dfp <- as.matrix(cbind(crds(dfp)[,1], crds(dfp)[,2], values(dfp)))
colnames(dfp) <- c("x", "y", "elev")
dfp
df
dfp <- as.data.frame(dfp)
dfp$precip <- values(precipa)
colnames(dfp) <- c("long", "lat", "elev")
dfp$precip <-  terra::extract(precip, dfp[, c("long", "lat")],
list=T, ID=F, method="bilinear")
dfp$precip
df$netuse
dfp$netuse <- 0.5
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
coop <- dp[, c("long", "lat")]
coop <- dfp[, c("long", "lat")]
Ap <- inla.spde.make.A(mesh = mesh, loc = coop)
Ap <- inla.spde.make.A(mesh = mesh, loc = as.matrix(coop))
stk.p <- inla.stack(
tag = "pred", # tag it for prediction, so INLA knows
data = list(y = NA, numtrials = NA),
A = list(1, Ap), # Ap, prediction matrix
effects = list(data.frame(b0 = 1,
elevation = dfp$elev,
precip = dfp$precip,
netuse = dfp$netuse),
s = indexs
)
)
stk.full <- inla.stack(stk.e, stk.p)  # assembles the data for INLA, similar to how we "package" the data for JAGS
formula <- y ~ 0 + b0 + elevation + netuse + precip + f(s, model = spde)
res2 <- inla(formula,
family = "binomial",
Ntrials = numtrials,
control.family = list(link = "logit"),
control.compute=list(return.marginals.predictor=TRUE),
data = inla.stack.data(stk.full),
control.predictor = list(
compute = TRUE, # this computes the posteriors of the predictions
link = 1,
A = inla.stack.A(stk.full)
)
)
summary(res)
index <- inla.stack.index(stack = stk.full, tag = "pred")$data
prev_mean <- res$summary.fitted.values[index, "mean"]
prev_ll <- res$summary.fitted.values[index, "0.025quant"]
prev_ul <- res$summary.fitted.values[index, "0.975quant"]
pal <- colorNumeric("viridis", c(0, 1), na.color = "transparent")
ra
### Rasterize the Prediction ----
r_prev_mean <- terra::rasterize(
x = coop, y = eleva, values = prev_mean,
fun = mean
)
prev_mean
summary(res2)
prev_mean <- res2$summary.fitted.values[index, "mean"]
prev_ll <- res2$summary.fitted.values[index, "0.025quant"]
prev_ul <- res2$summary.fitted.values[index, "0.975quant"]
pal <- colorNumeric("viridis", c(0, 1), na.color = "transparent")
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircles(
lng = coop[, 1], lat = coop[, 2],
color = pal(prev_mean)
) %>%
addLegend("bottomright",
pal = pal, values = prev_mean,
title = "Prev."
) %>%
addScaleBar(position = c("bottomleft"))
### Rasterize the Prediction ----
r_prev_mean <- terra::rasterize(
x = coop, y = eleva, values = prev_mean,
fun = mean
)
coop
### Rasterize the Prediction ----
r_prev_mean <- terra::rasterize(
x = as.matrix(coop), y = eleva, values = prev_mean,
fun = mean
)
pal <- colorNumeric("viridis", c(0, 1), na.color = "transparent")
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(r_prev_mean, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal,
values = values(r_prev_mean), title = "Prev."
) %>%
addScaleBar(position = c("bottomleft"))
### Lower limits of prediction
r_prev_ll <- terra::rasterize(
x = coop, y = eleva, values = prev_ll,
fun = mean
)
### Lower limits of prediction
r_prev_ll <- terra::rasterize(
x = as.matrix(coop), y = eleva, values = prev_ll,
fun = mean
)
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(r_prev_ll, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal,
values = values(r_prev_ll), title = "LL"
) %>%
addScaleBar(position = c("bottomleft"))
### Lower limits of prediction
r_prev_ul <- terra::rasterize(
x = as.matrix(coop), y = ra, values = prev_ul,
fun = mean
)
### Lower limits of prediction
r_prev_ul <- terra::rasterize(
x = as.matrix(coop), y = eleva, values = prev_ul,
fun = mean
)
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(r_prev_ul, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal,
values = values(r_prev_ul), title = "UL"
) %>%
addScaleBar(position = c("bottomleft"))
## For the lab-part 4 ----
### Mapping exceedance probabilities ----
threshold <- 0.2 # exceedance threshold 20%
index <- inla.stack.index(stack = stk.full, tag = "pred")$data
marg <- res$marginals.fitted.values[index][[1]]
1 - inla.pmarginal(q = threshold, marginal = marg) # probability
excprob <- sapply(res$marginals.fitted.values[index],
FUN = function(marg){1-inla.pmarginal(q = threshold, marginal = marg)})
excprob <- sapply(res2$marginals.fitted.values[index],
FUN = function(marg){1-inla.pmarginal(q = threshold, marginal = marg)})
head(excprob)
excprob <- sapply(res2$marginals.fitted.values[index],
FUN = function(marg){1-inla.pmarginal(q = threshold, marginal = marg)})
head(excprob)
r_excprob <- terra::rasterize(
x = as.matrix(coop), y = eleva, values = excprob,
fun = mean
)
# map
pal <- colorNumeric("viridis", c(0, 1), na.color = "transparent")
leaflet() %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addRasterImage(r_excprob, colors = pal, opacity = 0.5) %>%
addLegend("bottomright",
pal = pal,
values = values(r_excprob), title = "P(p>0.2)"
) %>%
addScaleBar(position = c("bottomleft"))
