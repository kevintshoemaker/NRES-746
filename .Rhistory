1+1
# myfunc <- function(){
#
# }
# Chunk 4
####################
# CENTRAL LIMIT THEOREM demonstration
####################
lots <- 100000       # number approximating infinity
N_IND_SAMPLES <- 1000       # number of indepenent random samples to draw from the specified distribution
SAMPLESIZE <- 10          # sample size of each independent random sample
########
#  Define the random number distribution. Here, we will use a "uniform" random number generator with a min of 10 and max of 20.
TRUEMIN <- 10
TRUEMAX <- 20
datafountain <- runif(lots,TRUEMIN,TRUEMAX)      # here we define the full set of possible random numbers to draw random samples from (the population of potential data)
#######
# Draw multiple samples from the pool (population) of possible data.
samplemean <- numeric(N_IND_SAMPLES)     # set up storage vector
for(i in 1:N_IND_SAMPLES){      # for each replicate (independent random sample)
sample <- sample(datafountain,SAMPLESIZE)   # draw an independent random sample from the population of interest
samplemean[i] <- mean(sample)    # compute and record the sample mean
}
hist(datafountain,freq=F,ylim=c(0,1))      # plot out the distribution of sample means
hist(samplemean,freq=F,add=T,col="red")    # overlay the distribution of the underlying data from which we are drawing samples.
# Chunk 19
rlocodist <- function(n){
vals <- c(1,7,10,35)         # possible data values
probs <- c(1,2,5,0.5)     # relative probability of each data values
probs <- probs/sum(probs)
vals[apply(rmultinom(n,1,probs),2,function(t) which(t==1))]     # sample from this made-up distribution
}
lots=10000
datafountain <- rlocodist(lots)
hist(datafountain, main="non-standard made-up distribution")
# Chunk 20
newsum <- function(x=c(1,2,4)){
sm <- sum(x)
return(sm)
}
newsum(x=c(5:10))   # specify x manually
newsum()    # use default value!
# Chunk 22
air.cleaned <- na.omit(airquality)    # remove rows with missing data
# Chunk 23
model1 <- lm(Ozone~Solar.R+Wind+Temp,data=air.cleaned)
# Chunk 24
par(mfrow=c(3,2))
plot(model1, which=c(1:4))   # diagnostic plots (NOTE: the plot function returns these plots by default when the input is a linear regression model)
hist(residuals(model1), breaks=10)   # histogram of residuals
plot(predict(model1) ~ air.cleaned$Ozone)     # plot predicted vs observed- should follow 1:1 line. Examine this for model biases.
abline(0,1)
# Chunk 25
symbols(air.cleaned$Temp, air.cleaned$Solar.R, circles=air.cleaned$Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
# alternatively...
coplot(air.cleaned$Ozone~air.cleaned$Temp|air.cleaned$Solar.R,rows=1)
# Chunk 26
formula2 <- "Ozone ~ Wind + Solar.R * Temp"   # you can name formulas...
# Chunk 27
model2 <- lm(formula2,data=air.cleaned)
# Chunk 29
NobleFir.df <- read.csv("TreeData.csv")
# Chunk 31
boxplot(NobleFir.df$Northeastness~NobleFir.df$ABPR, xlab="Presence of Noble Fir", ylab="Northeastness")   # for example
# Chunk 32
Biomass_std.lm <- with(NobleFir.df,     # using the "with()" statement, we don't need to keep referencing the name of the data frame.
lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
# Chunk 33
with(NobleFir.df,
symbols(x,y,circles=abs(residuals(Biomass_std.lm)), inches=0.3, ylab="Northing", xlab="Easting", main="Errors from Biomass Regression Model")
)
# Chunk 36: test4a1
df <- data.frame(
TreatmentA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
TreatmentB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
# Chunk 37: test4a2
reshapefunc <- function(df,varname){
sample.size <- nrow(df)     # determine sample size
reshape_df <- data.frame(                # "reshape" the data frame so each observation gets its own row (standard format)
Treatment = rep(c("A","B"),each=sample.size),
Value = c(df[,1],df[,2])
)
names(reshape_df)[2] <- varname   # rename the value column to whatever the user specifies
return(reshape_df)
}
unlink('LAB1_cache', recursive = TRUE)
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
devtools::install_github("lionel-/redpen")
install.packages("rlang")
install.packages("rlang")
devtools::install_github("lionel-/redpen")
devtools::install_github("dtkaplan/checkr")
devtools::install_github("lionel-/redpen",force = T)
devtools::install_github("dtkaplan/checkr")
?checkr::check_for_learnr
?checkr
library(help="checkr")
vignette(package="
"checkr")
vignette(package="checkr")
checkr::line_where()
?checkr::line_where
?checkr::for_checkr
?checkr::insist
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
line_where(ex, insist(F == "^"), message = "Didn't find exponentiation")
library(checkr)
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
line_where(ex, insist(F == "^"), message = "Didn't find exponentiation")
?line_binding
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
ex <- for_checkr(quote(z <- 2+2))
ex
line_binding(ex, 2 + 2, passif(TRUE, "The pattern matched."), message = "I was looking for 2+2.")
line_binding(ex, 3 + 3, message = "I was looking for 3 + 3")
line_binding(ex, 2 + 2, passif(Z == "z", "Assignment to {{Z}}."))
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
ex
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
line_where(ex,insist(all(F=="+")))
insist(all(F=="+"))
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
myvec <- c(1:4)
myvec
myvec <- c(1:4)
myvec
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
answer1a <- CoefVar(trees$Height)    # run your new function!
answer1a
answer1a <- CoefVar(trees$Height)    # run your new function!
answer1a
######################
# LAB 1 (possible) answers
######################
#############
## exercise 1a
CoefVar <- function(vector){
cv <- sd(vector,na.rm=TRUE)/mean(vector,na.rm=TRUE)
return(cv)
}
answer1a <- CoefVar(trees$Height)    # run your new function!
answer1a
round(answer1a,3)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
unlink('LAB1_cache', recursive = TRUE)
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
?for_checkr
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
answer1a
V
V(code)
code
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
lm_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
lm_line
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
func_call <- arg_calling(func_line, CoefVar)
func_call
t1 <- data_arg(func_call,
insist(identical(V, test),
"Your data argument {{E}} was not `test`."),
message = "You didn't supply a `data = ` argument to `lm()`.")
data_arg(func_call)
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
code
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
func_call <- arg_calling(func_line, CoefVar)
func_call
data_arg(func_call)
data_arg(code)
data_arg(code[[1]])
data_arg(code[[2]])
data_arg(code[[3]])
code[[3]]
code
code$code[[3]]
data_arg(code$code[[3]])
code$values
code$values[[3]]
?data_arg
data_arg(code)
func_line
vector_arg(func_line)
test<-1
vector_arg(func_line)
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
numeric_arg(code, message = "")
numeric_arg(func_line, message = "")
test <- trees$Height
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_call <- arg_calling(func_line, CoefVar)
func_call
func_call
func_line
func_line$code
func_line$values
func_call$values
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(test)}))
code
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
?line_calling
?arg_calling
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
func_line
named_arg(func_line,"test", message = "The argument to your function should be test")
named_arg(func_line)
code <- for_checkr(quote({test <- trees$Height;CoefVar <- function(vector){sd(vector)/mean(vector)};CoefVar(vector=test)}))
code
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
named_arg(func_line,"test", message = "The argument to your function should be test")
named_arg(func_line,"vector", message = "The argument to your function should be test")
named_arg(func_line,vector, message = "The argument to your function should be test")
named_arg(func_line,test, message = "The argument to your function should be test")
named_arg(func_line,"vector", message = "The argument to your function should be test")
func_line
vector_arg(func_line)
test
function_arg(code)
function_arg(func_line)
?line_binding
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,sd,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,"sd",message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,sd(vector),message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,test,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,test <- trees$Height,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,trees$Height,message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,function(vector){sd(vector)/mean(vector)},message = "Use the function 'sd'")
func_line
#line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,'function(vector){sd(vector)/mean(vector)}',message = "Use the function 'sd'")
func_line
?lines_after
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"))
func_line <- line_binding(code,'function(vector){sd(vector)/mean(vector)}',message = "Use the function 'sd'")
func_call <- line_calling(code, CoefVar, message = "Use CoefVar() to construct the model.")
check(func_call, insist(dplyr::near(V,answer1a,tol=0.001),
"Your solution is {{V}}. This is not the correct result"),
passif(TRUE, "Great job!"))
func_call$values
check(func_call, insist(dplyr::near(V,answer1a,tol=0.001),
message="Your solution is {{V}}. This is not the correct result"),
passif(TRUE, "Great job!"))
func_call
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"),passif(TRUE, "Great job!"))
line_where(func_call, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"),passif(TRUE, "Great job!"))
line_where(code, insist(V==answer1a, "Your solution is {{V}}. This is not the correct result"),passif(TRUE, "Great job!"))
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
rmarkdown::shiny_prerendered_clean('LAB1.Rmd')
install.packages("emdbook")
install.packages("ROCR")
install.packages("party")
install.packages("bnlearn")
install.packages("sparsebn")
install.packages(c("dtw", "forecast", "tseries"))
install.packages(c("GGally", "lavaan"))
install.packages("HDInterval")
install.packages(c("geosphere", "gstat"))
install.packages(c("arm", "ResourceSelection", "sjstats"))
install.packages("Qtools")
install.packages(c("scatterplot3d", "vegan"))
install.packages(c("amt", "aod"))
install.packages("randomForest")
install.packages("Rgraphviz")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
source("http://bioconductor.org/biocLite.R")
install.packages("BiocManager")
# source("http://bioconductor.org/biocLite.R")
# biocLite("Rgraphviz")
BiocManager::install("Rgraphviz")
library("Rgraphviz")
install.packages("RevoUtilsMath")
#install.packages("sparsebn")
library(sparsebn)
unlink('BayesianNetworks_cache', recursive = TRUE)
shiny::runUrl("http://naes.unr.edu/shoemaker/teaching/NRES-746/NRES-746_lab1.zip")
shiny::runUrl("http://naes.unr.edu/shoemaker/teaching/NRES-746/NRES-746_lab1.zip")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
curve(dnorm(x,0,2),-10,10)
curve(dbinom(x,10,0.5),0,10)
plot(xvals,expected_vals,type="l")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  NRES 746, Lecture 3                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  The virtual ecologist                             ####
####     Building data simulation models                ####
############################################################
#############
# Short exercise:
# Generate 50 samples from Normal(mean=10,sd=5)
# Generate 1000 samples from Poisson(mean=50)
# Generate 10 samples from Beta(shape1=0.1,shape2=0.1)
# Try some other distributions and parameters.  NOTE: you can visualize probability densities easily using the "curve" function:
curve(dnorm(x,0,2),-10,10)
# What happens when you try to use a discrete distribution?
############
# SIMULATE DATA GENERATION: decompose into deterministic and stochastic components
##########
# Deterministic component: define function for transforming a predictor variable into an expected response (linear regression)
# Arguments:
# x: vector of covariate values
# a: the intercept of a linear relationship mapping the covariate to an expected response
# b: the slope of a linear relationship mapping the covariate to an expected response
deterministic_component <- function(x,a,b){
linear <- a + b*x   # specify a deterministic, linear functional form
return(linear)
}
xvals = seq(0,100,10)  # define the values of a hypothetical predictor variable (e.g., tree girth)
expected_vals <- deterministic_component(xvals,175,-1.5)   # use the deterministic component to determine the expected response (e.g., tree volume)
expected_vals
plot(xvals,expected_vals)   # plot out the relationship
# plot(xvals,expected_vals,type="l")
plot(xvals,expected_vals,type="l")
##########
# Stochastic component: define a function for transforming an expected (deterministic) response and adding a layer of "noise" on top!
# Arguments:
# x: vector of expected responses
# variance: variance of the "noise" component of your data simulation model
stochastic_component <- function(x,variance){
sd <- sqrt(variance)       # convert variance to standard deviation
stochvals <- rnorm(length(x),x,sd)       # add a layer of "noise" on top of the expected response values
return(stochvals)
}
### Simulate stochastic data!!
sim_vals <- stochastic_component(expected_vals,variance=500)   # try it- run the function to add noise to your expected values.
plot(xvals,sim_vals)     # plot it- it should look much more "noisy" now!
# ALTERNATIVELY:
sim_vals <- stochastic_component(deterministic_component(xvals,175,-1.5),500)    # stochastic "shell" surrounds a deterministic "core"
##########
# Stochastic component: define a function for transforming an expected (deterministic) response and adding a layer of "noise" on top!
# Arguments:
# x: vector of expected responses
# variance: variance of the "noise" component of your data simulation model
stochastic_component <- function(x,variance){
sd <- sqrt(variance)       # convert variance to standard deviation
stochvals <- rnorm(length(x),x,sd)       # add a layer of "noise" on top of the expected response values
return(stochvals)
}
### Simulate stochastic data!!
sim_vals <- stochastic_component(expected_vals,variance=500)   # try it- run the function to add noise to your expected values.
plot(xvals,sim_vals)     # plot it- it should look much more "noisy" now!
# ALTERNATIVELY:
sim_vals <- stochastic_component(deterministic_component(xvals,175,-1.5),500)    # stochastic "shell" surrounds a deterministic "core"
stochastic_component <- function(x,variance){
sd <- sqrt(variance)       # convert variance to standard deviation
stochvals <- rnorm(length(x),0,sd)       # add a layer of "noise" on top of the expected response values
return(x+stochvals)
}
### Simulate stochastic data!!
sim_vals <- stochastic_component(expected_vals,variance=500)   # try it- run the function to add noise to your expected values.
plot(xvals,sim_vals)     # plot it- it should look much more "noisy" now!
##########
# Stochastic component: define a function for transforming an expected (deterministic) response and adding a layer of "noise" on top!
# Arguments:
# x: vector of expected responses
# variance: variance of the "noise" component of your data simulation model
stochastic_component <- function(x,variance){
sd <- sqrt(variance)       # convert variance to standard deviation
stochvals <- rnorm(length(x),x,sd)       # add a layer of "noise" on top of the expected response values
return(stochvals)
}
# alternative: add the "residuals" onto the expected values.
# stochastic_component <- function(x,variance){
#   sd <- sqrt(variance)       # convert variance to standard deviation
#   stochvals <- rnorm(length(x),0,sd)       # generate the 'residuals'
#   return(x+stochvals)             # add a layer of "noise" on top of the expected response values
# }
### Simulate stochastic data!!
sim_vals <- stochastic_component(expected_vals,variance=500)   # try it- run the function to add noise to your expected values.
plot(xvals,sim_vals)     # plot it- it should look much more "noisy" now!
# ALTERNATIVELY:
sim_vals <- stochastic_component(deterministic_component(xvals,175,-1.5),500)    # stochastic "shell" surrounds a deterministic "core"
############
# Goodness-of-fit test!
# Does the data fall into the range of plausble data produced by this fully specified model?
############
# Imagine you have the following "real" data (e.g., tree volumes).
realdata <- data.frame(Volume=c(125,50,90,110,80,75,100,400,350,290,350),Girth=xvals)
plot(realdata$Girth,realdata$Volume)
sqrt(1000)
sqrt(10000)
sqrt(100000)
sqrt(75000)
#############
# Let's simulate many datasets from our hypothesized data generating model (intercept=100,slope=0,variance=75000):
reps <- 1000    # specify number of replicate datasets to generate
samplesize <- nrow(realdata)    # define the number of data points we should generate for each simulation "experiment"
simresults <- array(0,dim=c(samplesize,reps))   # initialize a storage array for results
for(i in 1:reps){       # for each independent simulation "experiment":
exp_vals <- deterministic_component(realdata$Girth,a=100,b=0)          # simulate the expected tree volumes for each measured girth value
sim_vals <- stochastic_component(exp_vals,75000)  # add stochastic noise
simresults[,i] <- sim_vals   # store the simulated data for later
}
# now make a boxplot of the results
boxplot(lapply(1:nrow(simresults), function(i) simresults[i,]),xaxt="n")    # (repeat) make a boxplot of the simulation results
axis(1,at=c(1:samplesize),labels=realdata$Girth)                          # add x axis labels
points(c(1:samplesize),realdata$Volume,pch=20,cex=3,col="red",xaxt="n")     # this time, overlay the "real" data
unlink('LECTURE3_cache', recursive = TRUE)
rmd2rscript("LECTURE1.Rmd")
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE1.Rmd")
rmd2rscript("LECTURE2.Rmd")
rmd2rscript("LECTURE3.Rmd")
rmd2rscript("LECTURE4.Rmd")
rmd2rscript("LECTURE4.Rmd")
rmd2rscript("LECTURE5.Rmd")
