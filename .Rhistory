dat
params <- c("psurv0","b.fare","b.age","b.female","sdage","meanage")
library(jagsUI)
jags(dat, parameters.to.save=params, model.file=fn,
n.chains=3, n.adapt=1000, n.iter=10000, n.burnin=5000, n.thin=2,
parallel=FALSE)
mod1 <- lm(Volume~Girth,trees)
aov(mod1)
mod1 <- lm(Volume~Girth+Height,trees)
aov(mod1)
anova(mod1)
##download data to follow along:
rikz_data <- "https://uoftcoders.github.io/rcourse/data/rikz_data.txt"
download.file(rikz_data, "rikz_data.txt")
rikz_data <- read.table("rikz_data.txt", header = TRUE, sep="\t")
str(rikz_data)
rikz_data$Beach <- as.factor(rikz_data$Beach)
str(rikz_data)
head(rikz_data)
basic.lm <- lm(Richness~ NAP, data = rikz_data)
summary(basic.lm)
library(ggplot2)
# Plot relationship from above model
ggplot(rikz_data, aes(x = NAP, y = Richness)) +
geom_point() +
geom_smooth(method = "lm") +
theme_classic()
# Check assumptions.
par(mfrow=c(2,2))
plot(basic.lm)
# Function to find polygons
find_hull <- function(df) df[chull(df$Richness, df$NAP), ]
# Identify polygons in data
library(plyr)
hulls <- ddply(rikz_data, "Beach", find_hull)
# Plot
ggplot(rikz_data, aes(x = NAP, y = Richness, colour = Beach)) +
geom_point(size = 3) +
theme_classic() +
theme(legend.position = "none") +
scale_colour_brewer(palette="Set1") +
scale_fill_brewer(palette="Set1") +
geom_polygon(data=hulls, aes(fill = Beach), alpha = 0.2)
basic.lm <- lm(Richness ~ NAP + Beach, data = rikz_data)
summary(basic.lm)
# Random intercept model with NAP as fixed effect and Beach as random effect
library(lme4)
mixed_model_IntOnly <- lmer(Richness ~ NAP + (1|Beach),
data = rikz_data, REML = FALSE)
summary(mixed_model_IntOnly)
# Let's predict values based on our model and add these to our dataframe
# These are the fitted values for each beach, which are modelled separately.
rikz_data$fit_InterceptOnly <- predict(mixed_model_IntOnly)
# Let's plot
ggplot(rikz_data, aes(x = NAP, y = Richness, colour = Beach)) +
# Add fixed effect regression line (i.e. NAP)
geom_abline(aes(intercept = `(Intercept)`, slope = NAP),
linewidth = 2,
as.data.frame(t(fixef(mixed_model_IntOnly)))) +
# Add fitted values (i.e. regression) for each beach
geom_line(aes(y = fit_InterceptOnly), size = 1) +
geom_point(size = 3) +
theme_classic() +
theme(legend.position = "none") +
scale_colour_brewer(palette="Set1")
# Random intercept and slope model
mixed_model_IntSlope <- lmer(Richness ~ NAP + (1 + NAP|Beach),
data = rikz_data, REML = FALSE)
summary(mixed_model_IntSlope)
rikz_data$fit_IntSlope <- predict(mixed_model_IntSlope)
ggplot(rikz_data, aes(x = NAP, y = Richness, colour = Beach)) +
geom_abline(aes(intercept = `(Intercept)`, slope = NAP),
size = 2,
as.data.frame(t(fixef(mixed_model_IntSlope)))) +
geom_line(aes(y = fit_IntSlope), size = 1) +
geom_point(size = 3) +
theme_classic() +
theme(legend.position = "none") +
scale_colour_brewer(palette="Set1")
mixed_model_NoFix <- lmer(Richness ~ 1 + (1|Beach),
data = rikz_data, REML = TRUE)
summary(mixed_model_NoFix)
mixed_model_IntOnly <- lmer(Richness ~ NAP*Exposure + (1|Beach), REML = TRUE,
data = rikz_data)
mixed_model_IntSlope <- lmer(Richness ~ NAP*Exposure + (1 + NAP|Beach), REML = TRUE,
data = rikz_data)
library(MuMIn)
AICc(mixed_model_IntOnly, mixed_model_IntSlope)
# Full model with both fixed effects and their interaction
mixed_model_IntOnly_Full <- lmer(Richness ~ NAP*Exposure + (1|Beach), REML = FALSE,
data = rikz_data)
# No interaction
mixed_model_IntOnly_NoInter <- lmer(Richness ~ NAP + Exposure + (1|Beach),
REML = FALSE,
data = rikz_data)
# No interaction or main effect of exposure
mixed_model_IntOnly_NAP <- lmer(Richness ~ NAP + (1|Beach),
REML = FALSE,
data = rikz_data)
# No interaction or main effect of NAP
mixed_model_IntOnly_Exp <- lmer(Richness ~ Exposure + (1|Beach),
REML = FALSE,
data = rikz_data)
# No fixed effects
mixed_model_IntOnly_NoFix <- lmer(Richness ~ 1 + (1|Beach),
REML = FALSE,
data = rikz_data)
AICc(mixed_model_IntOnly_Full, mixed_model_IntOnly_NoInter,
mixed_model_IntOnly_NAP, mixed_model_IntOnly_Exp,
mixed_model_IntOnly_NoFix)
summary(update(mixed_model_IntOnly_Full, REML = TRUE))
library(dharm)
library(DHARMa)
res <- DHARMa::simulateResiduals(mixed_model_IntOnly_Full)
plot(res)
set.seed(123)
# Define parameters
samplesize <- 200         # Number of observations
nsites <- 10              # Number of sites
b_length <- sort(rnorm(samplesize))  # Explanatory variable (body length)
# Generate a random grouping variable 'sites' with replacement
sites <- sample(1:10, samplesize, replace = TRUE)
# Display the count of observations per site
table(sites)
df <- read.csv("Exercise_1.csv")
View(df)
df <- read.csv("Exercise_1.csv")
View(df)
df$id <- as.numeric(as.factor(df$Individual_ID))
df$id
table(df$id)
table(df$Individual_ID)
df$id <- as.factor(as.numeric(as.factor(df$Individual_ID)))
plot(df$Hemoglobin~df$Season)
df$Season
df$Season <- as.factor(df$Season)
plot(df$Hemoglobin~df$Season)
df
df <- df[,-1]
df
hist(df$Hemoglobin)
mod1 <- (Hemoglobin~Season,df)
mod1 <- lm(Hemoglobin~Season,df)
summary(mod1)
hist(mod1$residuals)
library(glmmTMB)
mod2 <- glmmTMB(Hemoglobin~Season+(1|id),family=gaussian())
mod2 <- glmmTMB(Hemoglobin~Season+(1|id),family=gaussian(),data=df)
AIC(mod1,mod2)
library(DHARMa)
res <- simulateResiduals(mod1)
plot(res)
res <- simulateResiduals(mod2)
plot(res)
df <- read.csv("beesurv.csv")
View(df)
table(df$site)
hist(df$visits)
names(df)
plot(visits~temp)
plot(visits~temp,df)
plot(visits~wind,df)
df$site
df$site <- as.factor(df$site)
df$site
mod1 <- glmmTMB(visits~temp+wind+((temp+wind)|site),
family = gamma(link="log"),data=df)
mod1 <- glmmTMB(visits~temp+wind+((temp+wind)|site),
family = Gamma(link="log"),data=df)
mod2 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = Gamma(link="log"),data=df)
summary(mod2)
ranef(mod2)
res <- simulateResiduals(mod2)
plot(res)
df$visits
mod3 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = Gamma,data=df)
mod3 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = nbinom2(link="log"),data=df)
summary(mod3)
summary(mod2)
hist(df$visits)   # definitely non-normal!
df$visits
res <- simulateResiduals(mod3)
plot(res)   # some issues, but not terrible
mod4 <- glmmTMB(log(visits)~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = gaussian(link="identity"),data=df)
summary(mod4)  # not converged
res <- simulateResiduals(mod4)
plot(res)   # some issues, but not terrible
mod5 <- glmmTMB(visits~temp*wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = Gamma(link="log"),data=df)
summary(mod5)
ranef(mod5)
res <- simulateResiduals(mod5)
plot(res)   # some issues, but not terrible
AIC(mod1,mod2,mod3,mod4,mod5)
AIC(mod1,mod2,mod3,mod5) # AIC says mod3 is best
summary(mod3)  # not converged
mod3 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = nbinom1(link="log"),data=df)
summary(mod3)  # not converged
res <- simulateResiduals(mod3)
plot(res)   # some issues, but not terrible
AIC(mod1,mod2,mod3,mod5) # AIC says mod3 is best
mod5 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = genpois(link="log"),data=df)
summary(mod5)
mod6 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = genpois(link="log"),data=df)
summary(mod6)
res <- simulateResiduals(mod6)
plot(res)   # some issues, but not terrible
AIC(mod2,mod3,mod6)
set.seed(123)
# Define parameters
samplesize <- 200         # Number of observations
nsites <- 10              # Number of sites
b_length <- sort(rnorm(samplesize))  # Explanatory variable (body length)
# Generate a random grouping variable 'sites' with replacement
sites <- sample(1:10, samplesize, replace = TRUE)
# Display the count of observations per site
table(sites)
# True intercept parameters
int_true_mean <- 45       # True mean intercept
int_true_sigma <- 10      # True standard deviation of intercepts
int_true_sites <- rnorm(n = nsites, mean = int_true_mean, sd = int_true_sigma)  # True intercept of each site
# Create a matrix to represent the intercept of each snake individual based on its site
sitemat <- matrix(0, nrow = samplesize, ncol = nsites)
for (i in 1:nrow(sitemat)) sitemat[i, sites[i]] <- 1
int_true <- sitemat %*% int_true_sites
# True slope parameter
slope_true <- 10
# Calculate true means and standard deviation
mu <- int_true + slope_true * b_length
sigma <- 5
# Generate response variable 'b_mass' based on normal distributions
b_mass <- rnorm(samplesize, mean = mu, sd = sigma)
# Create a data frame 'snakes3' with explanatory and response variables
snakes3 <- data.frame(b_length = b_length, b_mass = b_mass, site = sites)
# Display the first few rows of the data frame
head(snakes3)
plot(b_mass ~ b_length, col = site, data = snakes3)
# True intercept parameters
int_true_mean <- 45       # True mean intercept
int_true_sigma <- 10      # True standard deviation of intercepts
int_true_sites <- rnorm(n = nsites, mean = int_true_mean, sd = int_true_sigma)  # True intercept of each site
# Create a matrix to represent the intercept of each snake individual based on its site
sitemat <- matrix(0, nrow = samplesize, ncol = nsites)
for (i in 1:nrow(sitemat)) sitemat[i, sites[i]] <- 1
int_true <- sitemat %*% int_true_sites
# True slope parameter
slope_true <- 10
# Calculate true means and standard deviation
mu <- int_true + slope_true * b_length
sigma <- 5
# Generate response variable 'b_mass' based on normal distributions
b_mass <- rnorm(samplesize, mean = mu, sd = sigma)
# Create a data frame 'snakes3' with explanatory and response variables
snakes3 <- data.frame(b_length = b_length, b_mass = b_mass, site = sites)
# Display the first few rows of the data frame
head(snakes3)
# Prepare data for analysis with JAGS, including the number of sites
Nsites <- length(levels(as.factor(snakes3$site)))
jagsdata_s3 <- with(snakes3, list(b_mass = b_mass, b_length = b_length, site = site,
N = length(b_mass), Nsites = Nsites))
filename = "JAGS.txt"
cat("
model{
# Likelihood:
for (i in 1:N){
b_mass[i] ~ dnorm(mu[i], tau)  # Likelihood of the response variable
mu[i] <- alpha + a[site[i]] + beta * b_length[i]  # Model for the mean
}
# Priors:
alpha ~ dnorm(0, 0.01)      # Prior for the overall intercept
sigma_a ~ dunif(0, 100)      # Prior for the standard deviation of random effect
tau_a <- 1 / (sigma_a * sigma_a)  # Convert standard deviation to precision
for (j in 1:Nsites){
a[j] ~ dnorm(0, tau_a)    # Prior for random intercept for each site
}
beta ~ dnorm(0, 0.01)        # Prior for the slope
sigma ~ dunif(0, 100)        # Prior for the standard deviation of fixed effect
tau <- 1 / (sigma * sigma)   # Convert standard deviation to precision
}
",file=filename)
# Initial values function for JAGS
init_values <- function(){
list(alpha = rnorm(1), sigma_a = runif(1), beta = rnorm(1), sigma = runif(1))
}
# Parameters to be saved from the JAGS model
params <- c("alpha", "beta", "sigma", "sigma_a")
# Fit the JAGS model to the data
fit_lm3 <- jags(data = jagsdata_s3, inits = init_values, parameters.to.save = params, model.file = filename,
n.chains = 3, n.iter = 20000, n.burnin = 5000, n.thin = 10, DIC = FALSE)
library(jagsUI)
# Fit the JAGS model to the data
fit_lm3 <- jags(data = jagsdata_s3, inits = init_values, parameters.to.save = params, model.file = filename,
n.chains = 3, n.iter = 20000, n.burnin = 5000, n.thin = 10, DIC = FALSE)
fit_lm3
plot(fit_lm3)
plot(fit_lm3)
coda::autocorr(fit_lm3$samples)
traceplot(fit_lm3,"beta")
?autocorr
plot(fit_lm3)
?autocorr
df <- read.csv("beesurv.csv")
table(df$site)  # 10 sites, 10 observations
hist(df$visits)   # definitely non-normal! no zeroes...
names(df)
plot(visits~temp,df)
plot(visits~wind,df)
df$site <- as.factor(df$site)
mod1 <- glmmTMB(visits~temp+wind+((temp+wind)|site),
family = Gamma(link="log"),data=df)
mod2 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = Gamma(link="log"),data=df)
summary(mod2)
ranef(mod2)
res <- simulateResiduals(mod2)
plot(res)   # some issues, but not terrible
df$visits
mod3 <- glmmTMB(visits~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = nbinom1(link="log"),data=df)
summary(mod3)  # not converged
res <- simulateResiduals(mod3)
plot(res)   # some issues, but not terrible
mod4 <- glmmTMB(log(visits)~temp+wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = gaussian(link="identity"),data=df)
summary(mod4)  # not converged
mod7 <- glmmTMB(visits~temp*wind+(1|site) + ((0+temp)|site) + ((0+wind)|site),
family = poisson(link="log"),data=df)
summary(mod6)
summary(mod7)
res <- simulateResiduals(mod7)
plot(res)   # some issues, but not terrible
AIC(mod2,mod3,mod6,mod7)   # mod 3 and 6 are identical...
plot(visits~temp,df)
plot(visits~wind,df)
ranef(mod2)
library(mgcv) #load the mgcv package
mcycle <- MASS::mcycle #pull in some data; we'll be using this dataset for this example but not the lab
?gam #take a look at the documentation page for the function to see what you can specify - it's a lot!
library(mgcv) #load the mgcv package
mcycle <- MASS::mcycle #pull in some data; we'll be using this dataset for this example but not the lab
library(mgcv) #load the mgcv package
function (x, df1, df2, ncp, log = FALSE)
library(mgcv) #load the mgcv package
mcycle <- MASS::mcycle #pull in some data; we'll be using this dataset for this example but not the lab
View(mcycle)
mcycle <- MASS::mcycle #pull in some data; we'll be using this dataset for this example but not the lab
#now we'll go ahead and fit our spline using the most basic call of the function possible
gam_mod <- gam(accel ~ s(times), data = mcycle) #here, we predict acceleration based on a smooth, nonlinear function of times
plot(gam_mod, residuals = T, pch = 1) #setting residuals=T will include the CIs on the plot
coef(gam_mod)
gam_mod_s1 <- gam(accel ~ s(times), data = mcycle, sp = 0.1) #smoothing by setting a fixed smoothing parameter
gam_mod_s2 <- gam(accel ~ s(times), data = mcycle, method = "REML")
gam_mod_s2
par(mfrow = c(2, 1)) #we'll plot both models side by side to compare
plot(gam_mod_s1, residuals = TRUE, pch = 1)
plot(gam_mod_s1, residuals = TRUE, pch = 1)
par(mfrow = c(2, 1)) #we'll plot both models side by side to compare
plot(gam_mod_s1, residuals = TRUE, pch = 1)
plot(gam_mod_s2, residuals = TRUE, pch = 1)
par(mfrow = c(2, 1)) #we'll plot both models side by side to compare
plot(gam_mod_s1, residuals = TRUE, pch = 1)
plot(gam_mod_s2, residuals = TRUE, pch = 1)
gam_mod_tp <- gam(accel ~ s(times, bs="tp"), data = mcycle)
plot(gam_mod_tp, residuals = T, pch = 1)
gam_mod_cr <- gam(accel ~ s(times, bs="cr"), data = mcycle)
plot(gam_mod_cr, residuals = T, pch = 1)
#you can leave the knots argument blank, as above, or specify it:
gam_mod_cr_3 <- gam(accel ~ s(times, bs="cr",k=3), data = mcycle) #(in this example this is clearly a terrible choice of number of knots)
plot(gam_mod_cr_3, residuals = T, pch=1)
gam_mod_ps <- gam(accel ~ s(times, bs="ps"), data = mcycle)
plot(gam_mod_ps, residuals = T, pch = 1)
library(sp)
data(meuse, package="sp") #load in and inspect dataset
head(meuse)
mod <- gam(cadmium ~ s(x, y) + s(elev), #first, we fit a model where x and y coordinates interact directly and
data = meuse, method = "REML") #elevation is separate
plot(mod)
plot(mod)
tensor_mod <- gam(cadmium ~ te(x, y, elev),  #this model allows x and y coordinates and elevation to interact
data = meuse, method = "REML")  #despite being on different scales
plot(tensor_mod)
tensor_mod2 <- gam(cadmium ~ s(x, y) + s(elev) + ti(x, y, elev), #notice how two regular smooths are fit in addition to
data = meuse, method = "REML")                   #the tensor interaction
mod2da <- gam(cadmium ~ s(dist)+landuse,
data = meuse, method = "REML")
mod_sep <- gam(copper ~ s(dist, by = landuse) + landuse, #notice how landuse is included both inside and outside the smooth
data = meuse, method = "REML") #this gives us different smooths and different intercepts for each value of                                                     the variable
summary(mod_sep)
plot(mod_sep,pages=2)
mod2d_elev <- gam(cadmium ~ s(x, y) + s(elev),
data = meuse, method = "ML")
library(lmtest) #we need to load this package to do the likelihood ratio test
lrtest(mod2d_elev,mod2d)
mod2d <- gam(cadmium ~ s(x,y), data = meuse, method = "REML")
vis.gam(mod2d, view = c("x", "y"), #the view argument allows you to define which variables make the axes
plot.type = "contour", too.far = 0.05)
points(meuse)
#you may need to specify which parts of the data to pass to points, as below (sometimes it just picks the first two columns which is an issue if that's not the part of your model you're plotting)
points(meuse$x,meuse$y)
points(meuse)
#you may need to specify which parts of the data to pass to points, as below (sometimes it just picks the first two columns which is an issue if that's not the part of your model you're plotting)
points(meuse$x,meuse$y)
vis.gam(mod2d, view = c("x", "y"), #the view argument allows you to define which variables make the axes
plot.type = "contour", too.far = 0.05)
points(meuse)
#you may need to specify which parts of the data to pass to points, as below (sometimes it just picks the first two columns which is an issue if that's not the part of your model you're plotting)
points(meuse$x,meuse$y)
df <- read.csv("GAMs_SnakeSpeeds.csv")
library(mgcv)
df <- read.csv("GAMs_SnakeSpeeds.csv")
library(mgcv)
View(df)
hist(df$Speed)
df <- subset(df,Speed>0)
hist(df$Speed)
names(df)
plot(Speed~Mass,df)
plot(Speed~Tail,df)
plot(Speed~Lat,df)
plot(Speed~Long,df)
library(sf)
df <- st_as_sf(df,df(,c("Lat","Long")),crs=4326)
df <- st_as_sf(x=df,df[,c("Lat","Long")],crs=4326)
?st_as_sf
df <- st_as_sf(x=df,coords=df[,c("Lat","Long")],crs=4326)
df <- st_as_sf(df,coords=df[,c("Lat","Long")],crs=4326)
df <- st_as_sf(df,coords=c("Lat","Long"),crs=4326)
plot(df)
names(df)
plot(Speed~SVL)
plot(Speed~SVL,df)
plot(Speed~SVL,df)
plot(Speed~MAMU,df)
plot(Speed~Age)
plot(Speed~Age,df)
hist(df$Age)
table(df$Age)
table(df$Age,df$Speed)
tapply(df$Speed,df$Age,mean)
plot(Speed~Mass,df)
plot(Speed~Tail,df)
plot(Speed~Lat,df)
# plot(Speed~Lat,df)
# plot(Speed~Long,df)
plot(Speed~SVL,df)
plot(Speed~MAMU,df)
df <- read.csv("GAMs_SnakeSpeeds.csv")
library(mgcv)
df <- subset(df,Speed>0) # clean data
hist(df$Speed)
names(df)
plot(Speed~Mass,df) # weak pos
plot(Speed~Tail,df) # pos
# plot(Speed~Lat,df)
# plot(Speed~Long,df)
plot(Speed~SVL,df)
plot(Speed~MAMU,df)
table(df$Age)  # age is categorical
tapply(df$Speed,df$Age,mean) # not much effect of age
plot(Speed~Age,df)
mod1 <- gam(Speed~s(Lat,Long),df)
mod1 <- gam(Speed~s(Lat,Long),data=df)
plot(mod1)
mod1 <- gam(Speed~te(Lat,Long),data=df)
plot(mod1)
vis.gam(mod1)
mod2 <- gam(Speed~s(Tail),data=df)
plot(mod2)
summary(mod2)
coef(mod2)
vis.gam(mod1,view = c("Lat", "Long"), #the view argument allows you to define which variables make the axes
plot.type = "contour")
plot(Speed~Lat,df)
plot(Speed~Long,df)
summary(mod2)
names(df)
mod3 <- gam(Speed~s(SVL) + s(Mass) + s(Tail) + Lat + MAMU,data=df)
hist(residuals.gam(mod3))
plot(mod3)
plot(Speed~SVL,df)
df <- subset(df,SVL>20)
hist(df$Speed)
names(df)
plot(Speed~Mass,df) # weak pos
plot(Speed~Tail,df) # pos
plot(Speed~Lat,df)  # pos
plot(Speed~Long,df)  # little effect
plot(Speed~SVL,df)    # outliers in the svl? what's going on here?
plot(Speed~Long,df)  # little effect
plot(Speed~Lat,df)  # pos
plot(Speed~Tail,df) # pos
plot(Speed~MAMU,df)
mod3 <- gam(Speed~s(SVL) + s(Mass) + s(Tail) + Lat + MAMU,data=df)
plot(mod3)
summary(mod3)
mod4 <- gam(Speed~s(SVL) + s(Mass) + s(MAMU),data=df)
plot(mod4)
mod5 <- gam(Speed~te(SVL,Mass) + s(MAMU) ,data=df )
plot(mod5)
AIC(mod4,mod5)
plot(mod5)
summary(mod5)
vis.gam(mod5,view = c("SVL", "Mass"), #the view argument allows you to define which variables make the axes
plot.type = "contour")
summary(mod5)
