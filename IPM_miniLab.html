<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Behnke-Riecke" />

<meta name="date" content="2016-11-28" />

<title>IPM_lab</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/default.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.9em;
  padding-left: 5px;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">NRES 746</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Schedule
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="schedule.html">Course Schedule</a>
    </li>
    <li>
      <a href="labschedule.html">Lab Schedule</a>
    </li>
    <li>
      <a href="Syllabus.pdf">Syllabus</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="INTRO.html">Introduction to NRES 746</a>
    </li>
    <li>
      <a href="LECTURE1.html">Why focus on algorithms?</a>
    </li>
    <li>
      <a href="LECTURE2.html">Working with probabilities</a>
    </li>
    <li>
      <a href="LECTURE3.html">The Virtual Ecologist</a>
    </li>
    <li>
      <a href="LECTURE4.html">Likelihood</a>
    </li>
    <li>
      <a href="LECTURE5.html">Optimization</a>
    </li>
    <li>
      <a href="LECTURE6.html">Bayesian #1: concepts</a>
    </li>
    <li>
      <a href="LECTURE7.html">Bayesian #2: mcmc</a>
    </li>
    <li>
      <a href="LECTURE8.html">Model Selection</a>
    </li>
    <li>
      <a href="LECTURE9.html">Model Performance Evaluation</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lab exercises
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="LAB1.html">Lab 1: Algorithms in R</a>
    </li>
    <li>
      <a href="LAB2.html">Lab 2: Virtual ecologist</a>
    </li>
    <li>
      <a href="LAB3.html">Lab 3: Likelihood and optimization</a>
    </li>
    <li>
      <a href="LAB4.html">Lab 4: Bayesian inference</a>
    </li>
    <li>
      <a href="LAB5.html">Lab 5: Model selection</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data sets
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TreeData.csv">Tree Data</a>
    </li>
    <li>
      <a href="ReedfrogPred.csv">Reed Frog Predation Data</a>
    </li>
    <li>
      <a href="ReedfrogFuncresp.csv">Reed Frog Func Resp</a>
    </li>
    <li>
      <a href="uta_simulated_data.csv">Uta data</a>
    </li>
    <li>
      <a href="tide_ALL_navd_HH.csv">tide data?</a>
    </li>
    <li>
      <a href="TestDataset2.csv">Ordination minilab: testdataset2</a>
    </li>
    <li>
      <a href="TestHypotheses.csv">Ordination minilab: testhypotheses</a>
    </li>
    <li>
      <a href="PRISM_ppt_1895-2015Mo2.csv">PRISM data for time series lab</a>
    </li>
    <li>
      <a href="final_winter_modeldata2.csv">winter deer data for RSF lab</a>
    </li>
    <li>
      <a href="keeley_rawdata.csv">Keeley data</a>
    </li>
    <li>
      <a href="Nest_basic_ALL.csv">nest basic data</a>
    </li>
    <li>
      <a href="Cap_data_for SA minilab.csv">cap data for SA</a>
    </li>
    <li>
      <a href="JoTrPresence02202008_dryad.txt">Joshua tree data for SDM lab</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Student-led topics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="forWebsite_SEM.html">SEMs</a>
    </li>
    <li>
      <a href="SEM_Minilab_v2.html">SEM mini-lab</a>
    </li>
    <li>
      <a href="GAMs.html">GAMs</a>
    </li>
    <li>
      <a href="RMarkdown_FigureDemo.html">Publication-quality figures in R</a>
    </li>
    <li>
      <a href="Bayesian Networks.pptx">Bayesian Networks</a>
    </li>
    <li>
      <a href="Bayes_Network_Markdown_Final.html">Bayesian Networks mini-lab</a>
    </li>
    <li>
      <a href="GraphTheory.html">Graph Theory</a>
    </li>
    <li>
      <a href="NRES746_IPMs.pptx">Integrated Population Models</a>
    </li>
    <li>
      <a href="TimeSeries_heckler.html">Time Series Analysis</a>
    </li>
    <li>
      <a href="Time_Series_Lab.html">Time-series mini-lab</a>
    </li>
    <li>
      <a href="Spatial_Autocorrelation.html">Spatial Autocorrelation</a>
    </li>
    <li>
      <a href="SA_minilab.html">Spatial Autocorrelation mini-lab</a>
    </li>
    <li>
      <a href="SDM_pres.html">Species Distribution Modeling</a>
    </li>
    <li>
      <a href="IPM_miniLab.html">IPM mini-lab</a>
    </li>
    <li>
      <a href="Final_MiniLabScript.html">RSF mini-lab</a>
    </li>
    <li>
      <a href="MixedModelMinilab.html">Mixed-effects model mini-lab</a>
    </li>
    <li>
      <a href="Minilab_Ordination.html">Ordination mini-lab</a>
    </li>
  </ul>
</li>
<li>
  <a href="Links.html">Links</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">IPM_lab</h1>
<h4 class="author"><em>Behnke-Riecke</em></h4>
<h4 class="date"><em>November 28, 2016</em></h4>

</div>


<div id="integrated-population-models-lab-exercise" class="section level1">
<h1>Integrated Population Models: Lab Exercise</h1>
<p>Behnke-Riecke<br />
NRES 746<br />
December 1, 2016</p>
<div id="shrike-example" class="section level2">
<h2>Shrike Example</h2>
<p>Think about the shrike lifecycle digram from the presentation. We are going to use the stage structured model for this analysis. That means our population is split into juveniles and adults, both of which contribute to the next cohort, and can survive at different rates.<br />
Remember our population equations:<br />
N<sub>juv,t+1</sub> = N<sub>juv,t</sub>s<sub>j,t</sub><em>f</em><sub>t+1</sub> + N<sub>ad,t</sub>s<sub>a,t</sub><em>f</em><sub>t+1</sub><br />
N<sub>ad,t+1</sub> = N<sub>juv,t</sub>s<sub>j,t</sub> + N<sub>ad,t</sub>s<sub>a,t</sub></p>
<p>To get started, let’s call our jags package (note- here we use jagsUI, but you could also use R2jags)</p>
<pre class="r"><code>library(jagsUI)</code></pre>
<pre><code>## Warning: package &#39;jagsUI&#39; was built under R version 3.3.2</code></pre>
<div id="step-1-data-simulation" class="section level3">
<h3>STEP 1: Data Simulation</h3>
<p>Here we provide code (Courtesy of Michael Schaub and Mark Kery) to create a shrike population, based on the lifecycle we defined above. Copy and run this code before you go any further!</p>
<pre class="r"><code># Create population function
create.population &lt;- function(Ni = c(10, 10), phi = matrix(c(rep(0.3, 5), rep(0.55, 5)), ncol = 5, byrow = TRUE), f = matrix(c(rep(1.6, 6), rep(1.6, 6)), ncol = 6, byrow = TRUE), Im = rep(0, 6), seed = NA){
  
  if (is.na(seed) == TRUE) seed = runif(1, 0, 100)
  set.seed(seed)
  
  T &lt;- ncol(phi)            # Number of years
  mAge &lt;- nrow(phi)         # Maximal number of age(stage) classes
  
  # 1. Expand the vital rate matrices, such that the number of age classes corresponds to the number of years
  PHI &lt;- matrix(0, ncol = T, nrow = mAge + T)
  PHI[1:nrow(phi),] &lt;- phi
  u &lt;- mAge + T - nrow(phi)
  if (u &gt; 0){
    for (j in 1:u){
      PHI[nrow(phi)+j,] &lt;- phi[nrow(phi),]
    } # j
  } # if
  
  F &lt;- matrix(0, ncol = T + 1, nrow = mAge + T)
  F[1:nrow(f),] &lt;- f
  u &lt;- mAge + T - nrow(f)
  if (u &gt; 0){
    for (j in 1:u){
      F[nrow(f)+j,] &lt;- f[nrow(f),]
    } # j
  } # if
  
  Nindex &lt;- c(0, cumsum(Ni))
  
  # 2. Create a Leslie matrix to determine approximately how many individuals will be ever alive in the population 
  N &lt;- matrix(data = NA, nrow = mAge, ncol = T + 1)
  N[,1] &lt;- Ni
  A &lt;- array(0, dim = c(mAge, mAge, T))
  for (t in 1:T){
    for (j in 1:mAge){
      A[1,j,t] &lt;- F[j,t] * PHI[1,t]    # First row in Leslie matrix
    } # j
    for (j in 2:mAge){
      A[j,j-1,t] &lt;- PHI[j,t]           # Subdiagonal
    } # j
    A[mAge, mAge, t] &lt;- PHI[mAge, t]
  } # t       
  for (t in 1:T){
    N[,t+1] &lt;- A[,,t]%*%N[,t] + matrix(c(rep(0, mAge-1), Im[t]), ncol = 1)
  } # t
  no.ani &lt;- round(sum(N)*5)              # 5 times as many individuals that were alive
  
  # 3. Define array for each individual
  ind &lt;- array(NA, dim = c(mAge + 4, T + 1, no.ani))   # information about [1-ye, 2-ye, ..., mAge-ye, Juv, Im, Rep, Dead]
  
  # 4. Simulate the fates of individuals already present at t = 1 (in different age classes) and their reproduction   
  # 4.a: Simulate survival of the individuals present at t=1
  # Initialize
  for (a in 1:mAge){
    if (Ni[a]==0) next
    for (i in (Nindex[a]+1):Nindex[a+1]){
      ind[a,1,i] &lt;- 1
    } # i
  } # if
  
  # Simulate survival
  z &lt;- numeric()
  for (a in 1:mAge){
    for (i in (Nindex[a]+1):Nindex[a+1]){
      for (t in 1:T){
        z[t] &lt;- rbinom(1,1,PHI[a+t,t])
      } # t
      Z &lt;- max(sum(cumprod(z)))
      if (Z==0) {
        ind[mAge+4,2,i] &lt;- 1
        next
      } # if
      for (u in 1:Z){
        if (a+u &lt; mAge){
          ind[a+u,u+1,i] &lt;- 1
        } # if
        else {
          ind[mAge,u+1,i] &lt;- 1
        } # else                
      } # u
      # Record year of death (if any)
      if (sum(z)==T) next
      else {
        D &lt;- min(which(z==0))
        ind[mAge+4,D+1,i] &lt;- 1
      } # else          
    } # i
  } # a
  
  # 3.b: Survival of immigrants (in all years, not just of immigrants present at t = 1)
  Nimindex &lt;- c(0, cumsum(Im)) + max(Nindex)
  for (t in 1:(T+1)){
    if (Im[t]==0) next
    for (i in (Nimindex[t]+1):Nimindex[t+1]){
      ind[mAge+2,t,i] &lt;- 1
    } # i
  } # t
  for (t in 1:T){
    if (Im[t]==0) next
    for (i in (Nimindex[t]+1):Nimindex[t+1]){
      z &lt;- numeric()
      for (d in t:T){      
        z[d-t+1] &lt;- rbinom(1,1,PHI[mAge+d,d])
      } # d
      Z &lt;- max(sum(cumprod(z)))
      if (Z==0){
        ind[mAge+4,t+1,i] &lt;- 1
        next
      } # if
      for (u in 1:Z){
        if (t+u &lt;= (T+1)){
          ind[mAge,u+t,i] &lt;- 1
        } # if
        else {next}                
      }  # u
      # Record year of death (if any)
      if (sum(z)==T-t+1) next
      else {
        D &lt;- min(which(z==0))
        ind[mAge+4,D+t,i] &lt;- 1
      } # else          
    } # i
  } # t
  
  # 3.c: Simulate reproduction of all already existing individuals
  for (i in 1:max(Nimindex)){
    for (t in 1:(T+1)){
      g &lt;- which(!is.na(ind[c(1:mAge, mAge+2),t,i]))
      if (length(g)==0) next
      if (g !=8){
        ind[mAge+3,t,i] &lt;- rpois(1,F[g,t])
      } # if
      if (g==8){
        ind[mAge+3,t,i] &lt;- rpois(1,F[mAge,t])
      } # if
    } # t
  } # i
  
  # 4. Simulate the fates of individuals born during the study       
  # - determine the number of nestlings
  # - determine their fate over time
  # - determine their reproduction
  nestl &lt;- numeric()
  nestl[1] &lt;- 0
  for (t in 1:(T+1)){
    # 4.a: Enumerate the number of nestlings
    nestl[t+1] &lt;- sum(ind[mAge+3,t,], na.rm = TRUE)
    ind[mAge+1,t,(max(Nimindex)+max(cumsum(nestl[1:t]))+1):(max(Nimindex)+max(cumsum(nestl[1:(t+1)])))] &lt;- 1
    if (t==(T+1)) break
    
    # 4.b: Model survival of these individuals
    for (i in (max(Nimindex)+max(cumsum(nestl[1:t]))+1):(max(Nimindex)+max(cumsum(nestl[1:(t+1)])))){
      z &lt;- numeric()
      for (d in t:T){
        z[d-t+1] &lt;- rbinom(1,1,PHI[d-t+1,d])
      } # d
      Z &lt;- max(sum(cumprod(z)))
      if (Z==0){
        ind[mAge+4,t+1,i] &lt;- 1
        next
      } # if
      for (u in 1:Z){
        if (u &lt; mAge){
          ind[u,u+t,i] &lt;- 1
        } # if
        else {
          ind[mAge,u+t,i] &lt;- 1
        } # else                
      }  # u
      # Record year of death (if any)
      if (sum(z)==T-t+1) next
      else {
        D &lt;- min(which(z==0))
        ind[mAge+4,D+t,i] &lt;- 1
      } # else          
    } # i
    
    # 4.c: Model reproduction of the surviving individuals
    for (i in (max(Nimindex)+max(cumsum(nestl[1:t]))+1):(max(Nimindex)+max(cumsum(nestl[1:(t+1)])))){
      for(d in t:T+1){       
        g &lt;- which(!is.na(ind[c(1:mAge),d,i]))
        if (length(g)==0) next
        if (g !=8){
          ind[mAge+3,d,i] &lt;- rpois(1,F[g,d])
        } # if
      } # d
    } # i
  } # t
  
  # 5. Enumerate the total number of animals
  Ntotal &lt;- sum(Ni) + sum(ind[mAge+1,1:(T+1),], na.rm = TRUE) + sum(Im)
  # Remove empty cells and reorder the array such that it starts with the Juv
  IND &lt;- ind[,,1:Ntotal]
  IND[1,,] &lt;- ind[mAge+1,,1:Ntotal]
  for (a in 1:mAge){
    IND[a+1,,] &lt;- ind[a,,1:Ntotal]
  } # a
  rnames &lt;- numeric()
  for (a in 1:mAge){
    rnames[a] &lt;- paste(a,&quot;-Year&quot;, sep=&quot;&quot;)
  } # a
  rnames &lt;- c(&quot;Juv&quot;, rnames, &quot;Im&quot;, &quot;Rep&quot;, &quot;Dead&quot;)
  rownames(IND) &lt;- rnames
  
  # Summary statistics: Number of individuals in each class and year, plus immigration rate
  Nu &lt;- matrix(NA, ncol = T+1, nrow = mAge + 4)
  for (t in 1:(T+1)){
    for (a in 1:(mAge+1)){
      Nu[a,t] &lt;- sum(IND[a,t,], na.rm = TRUE)
    } # a
    Nu[mAge+2,t] &lt;- sum(IND[mAge+2,t,], na.rm = TRUE)
    Nu[mAge+3,t] &lt;- sum(Nu[2:(mAge+1),t]) + sum(IND[mAge+2,t,], na.rm = TRUE)
  } # t
  for (t in 2:(T+1)){
    Nu[mAge+4,t] &lt;- sum(IND[mAge+2,t,], na.rm = TRUE) / Nu[mAge+3,t-1]
  } # t
  rnames &lt;- numeric()
  for (a in 1:mAge){
    rnames[a] &lt;- paste(a,&quot;-Year&quot;, sep=&quot;&quot;)
  } # a
  rnames &lt;- c(&quot;Juv&quot;, rnames, &quot;Im&quot;, &quot;Total&quot;, &quot;Imm rate&quot;)
  rownames(Nu) &lt;- rnames
  
  # 6. Output
  return(list(IND = IND, Nu = Nu))
}



# Age specific survival probabilities (juv, adult)
sj &lt;- 0.3
sa &lt;- 0.55

# Fecundity rate (females)
f1 &lt;- 1.6            # productivity of 1 year old females
f2 &lt;- f1             # productivity of females older than one year

# Initial population size per age class
Ni &lt;- c(100, 100)

# Number of years
T &lt;- 10

#We apply function create.population (see appendix) to create the shrike population:

ind &lt;- create.population(phi = matrix(c(rep(sj, T-1), rep(sa, T-1)), ncol = T-1, byrow = TRUE), f = matrix(c(rep(f1, T), rep(f2, T)), ncol = T, byrow = TRUE), Im = rep(0, T), Ni = Ni, seed = 2008)

# Observation error for the population survey
sigma &lt;- 10   


create.survey.bin &lt;- function(Nu, psur, seed = NA){
  
  if (is.na(seed) == TRUE) seed = runif(1, 0, 100)
  set.seed(seed)
  T &lt;- length(Nu)
  SUR &lt;- numeric()
  for (t in 1:T){
    SUR[t] &lt;- rbinom(1, Nu[t], psur[t])
  } # t
  return(SUR)
}

create.survey.norm &lt;- function(Nu, sigma, seed = NA){
  
  if (is.na(seed) == TRUE) seed = runif(1, 0, 100)
  set.seed(seed)
  T &lt;- length(Nu)
  SUR &lt;- numeric()
  for (t in 1:T){
    SUR[t] &lt;- rnorm(1, Nu[t], sigma[t])
  } # t
  return(SUR)
}


# Create the population survey data
count &lt;- round(create.survey.norm(ind$Nu[&quot;Total&quot;,], rep(sigma, T), seed = 1))
# Capture and recapture probabilities
cjuv &lt;- 0.3           # initial capture probability of juveniles
cad &lt;- 0.3            # initial capture probability of adults
prec &lt;- 0.6           # recapture probability 


# Create function for makeing capture history

create.capturehistory &lt;- function(ind, c, p, maxAge = 2, seed = NA){
  
  if (is.na(seed) == TRUE) seed = runif(1, 0, 100)
  set.seed(seed)
  T &lt;- dim(ind)[2]
  nind &lt;- dim(ind)[3]
  nstage &lt;- dim(ind)[1]
  aclasses &lt;- nstage-3
  age &lt;- first &lt;- last &lt;- numeric()
  
  for (i in 1:nind){
    g &lt;- which(!is.na(ind[1:(aclasses+1),,i]), arr.ind = TRUE)
    age[i] &lt;- g[1,1]
    first[i] &lt;- g[1,2]
    h &lt;- which(ind[1:(aclasses+1),,i]==1, arr.ind = TRUE)
    last[i] &lt;- max(h[,2])
  } # i
  
  ch.true &lt;- ch &lt;- matrix(0, ncol = T, nrow = nind)
  for (i in 1:nind){
    ch.true[i,first[i]:last[i]] &lt;- 1
  } # i
  # Recode age
  age[age &gt; maxAge] &lt;- maxAge
  
  # Sampling
  # Expand c and p (to higher age classes)
  C &lt;- matrix(0, ncol = T, nrow = max(c(maxAge, nrow(c))) + T)
  C[1:nrow(c),] &lt;- c
  u &lt;- max(c(maxAge, nrow(c))) + T - nrow(c)
  if (u &gt; 0){
    for (j in 1:u){
      C[nrow(c)+j,] &lt;- c[nrow(c),]
    } # j
  } # if
  
  P &lt;- matrix(0, ncol = T-1, nrow = max(c(maxAge, nrow(p))) + T)
  P[1:nrow(p),] &lt;- p
  u &lt;- max(c(maxAge, nrow(p))) + T - nrow(p)
  if (u &gt; 0){
    for (j in 1:u){
      P[nrow(p)+j,] &lt;- p[nrow(p),]
    } # j
  } # if
  
  for (i in 1:nind){
    # First capture
    ch[i,first[i]] &lt;- rbinom(1, 1, C[age[i],first[i]])
    if (first[i]==last[i]) next
    # Recapture (conditional on first capture)
    for (t in (first[i]+1):last[i]){
      ch[i,t] &lt;- rbinom(1, 1, P[(age[i]+t-first[i]),t-1]) * ch[i,first[i]]
    } # t
  } # i
  
  # Remove individuals that have never been captured/marked
  incl &lt;- which(rowSums(ch)&gt;=1)
  ch &lt;- ch[incl,]
  age &lt;- age[incl]
  return(list(ch = ch, age = age))  
}


marray.age &lt;- function(ch, age, mAge = 1){
  
  # 1. Helper functions
  # 1.1. Function to create a m-array based on capture-histories (ch)
  marray &lt;- function(ch){
    nind &lt;- nrow(ch)
    n.occasions &lt;- ncol(ch)
    m.array &lt;- matrix(data = 0, ncol = n.occasions+1, nrow = n.occasions)
    # Calculate the number of released individuals at each time period
    m.array[,1] &lt;- colSums(ch)
    for (i in 1:nind){
      pos &lt;- which(ch[i,]==1)
      g &lt;- length(pos)
      if (g==1) next
      for (z in 1:(g-1)){
        m.array[pos[z],pos[z+1]] &lt;- m.array[pos[z],pos[z+1]] + 1
      } # z
    } # i
    # Calculate the number of individuals never recaptured
    for (t in 1:n.occasions){
      m.array[t,n.occasions+1] &lt;- m.array[t,1] - sum(m.array[t,2:n.occasions])
    } # t
    out &lt;- m.array[1:(n.occasions-1),2:(n.occasions+1)]
    return(out)
  }
  
  # 1.2. Function to remove histories without any capture from a capture-recapture matrix
  clean.ch &lt;- function(ch){
    incl &lt;- which(rowSums(ch)&gt;=1)
    ch &lt;- ch[incl,]
    return(ch)
  }
  
  # 1.3. Function to remove the first capture in a capture-recapture matrix
  rm.first &lt;- function(ch) {
    get.first &lt;- function(x) min(which(x==1))
    first &lt;- apply(ch, 1, get.first)
    for (i in 1:nrow(ch)){
      ch[i,first[i]] &lt;- 0
    }
    return(ch)
  }
  
  # 1.4. Function to calculate the occasion of first capture
  get.first &lt;- function(x) min(which(x==1))
  
  
  # 2. Calculations   
  if (is.matrix(ch)==FALSE) ch &lt;- matrix(ch, nrow = 1)   
  maxAge &lt;- max(c(max(age), mAge))
  nind &lt;- nrow(ch)
  n.occasions &lt;- ncol(ch)
  
  first &lt;- apply(ch, 1, get.first)
  age.matrix &lt;- matrix(0, ncol = n.occasions, nrow = nind)
  for (i in 1:nind){
    age.matrix[i,first[i]:n.occasions] &lt;- 1:(n.occasions-first[i]+1)+(age[i]-1)
  }
  age.matrix[age.matrix &gt; maxAge] &lt;- maxAge
  
  # Recode capture history
  ch.rec &lt;- ch
  for (i in 1:nind){
    h &lt;- which(ch.rec[i,]==1)
    for (j in 1:length(h)){
      ch.rec[i,h[j]] &lt;- j
    } # j
  } # i
  ch.rec[ch.rec &gt; maxAge] &lt;- maxAge
  
  ch.split &lt;- array(0, dim = c(nrow(ch), ncol(ch), maxAge))
  for (a in 1:maxAge){
    for (i in 1:nind){
      j &lt;- which(ch.rec[i,]==a | ch.rec[i,]==(a+1))
      if (length(j)==0) next
      ch.split[i,j[1:2],age.matrix[i,j[1]]] &lt;- 1
      if (length(j)&gt;1){
        ch.split[i,j[2:length(j)],age.matrix[i,j[2]]] &lt;- 1
      }
    } # i
  } # a
  
  marr &lt;- array(0, dim = c(n.occasions-1, n.occasions, maxAge))
  for (a in 1:(maxAge-1)){
    for (i in 1:nind){
      u &lt;- which(ch.split[i,,a]==1)
      if (length(u)==0) next
      if (u[1]==n.occasions) next
      if (length(u)==1) marr[u,n.occasions,a] &lt;- marr[u,n.occasions,a] + 1
      if (length(u)==2) marr[u[1],u[2]-1,a] &lt;- marr[u[1],u[2]-1,a] + 1
    } # i
  } # a
  a &lt;- maxAge
  
  if (is.matrix(ch.split[,,a])==FALSE){ 
    ch.split1 &lt;- matrix(ch.split[,,a], nrow = 1)
    marr[,,a] &lt;- marray(ch.split1)
  } # if
  else marr[,,a] &lt;- marray(ch.split[,,a])      
  return(marr)
}


# Create the capture histories and the corresponding m-arrays
ch &lt;- create.capturehistory(ind$IND, c = matrix(c(rep(cjuv, T), rep(cad, T)), nrow = 2, byrow = TRUE), p = matrix(c(rep(prec, T-1), rep(prec, T-1)), nrow = 2, byrow = TRUE), seed = 1)
marray &lt;- marray.age(ch$ch, ch$age)

#Finally data on productivity are generated. Here we assume that a nest is detected with a certain probability and if the nest is found, its output (i.e. the number of fledglings) is recorded without error.

# Probability to find a brood whose reproductive ouput is recorded, detection 
pprod &lt;- 0.3

create.reproduction &lt;- function(ind, prep, seed = NA){
  
  if (is.na(seed) == TRUE) seed = runif(1, 0, 100)
  set.seed(seed)
  r &lt;- dim(ind)[1] - 1
  maxAge &lt;- dim(ind)[1] - 4
  T &lt;- dim(ind)[2]
  rep &lt;- year &lt;- age &lt;- numeric()
  le &lt;- 0
  for (t in 1:T){
    z &lt;- which(!is.na(ind[r,t,]))
    for (i in 1:length(z)){
      j &lt;- le + i
      h &lt;- rbinom(1, 1, prep[t])
      if (h==1){
        rep[j] &lt;- ind[r,t,z[i]]
        year[j] &lt;- t
        age[j] &lt;- which(!is.na(ind[2:(maxAge+2),t,z[i]]))
      } # if
      else {
        rep[j] &lt;- NA
        year[j] &lt;- NA
        age[j] &lt;- NA
      } # else  
    } # i
    le &lt;- length(rep)
  } # t
  age[age==(maxAge+1)] &lt;- maxAge   # re-adjust age of immigrants to maximal age
  k &lt;- which(!is.na(rep))
  rep.ind &lt;- cbind(rep[k], year[k], age[k])
  colnames(rep.ind) &lt;- c(&quot;Reproduction&quot;, &quot;Year&quot;, &quot;Age of mother&quot;)
  rep.agg &lt;- matrix(NA, nrow = T, ncol = 2)
  for (t in 1:T){
    rep.agg[t,1] &lt;- sum(rep.ind[rep.ind[,2]==t,1])
    rep.agg[t,2] &lt;- length(rep.ind[rep.ind[,2]==t,1])
  }
  colnames(rep.agg) &lt;- c(&quot;Juveniles&quot;, &quot;Surveyed broods&quot;)
  
  return(list(rep.ind = rep.ind, rep.agg = rep.agg))
}


# Create productivity data
P &lt;- create.reproduction(ind$IND, rep(pprod, T), seed = 1)</code></pre>
<div id="view-mark-recapture-data" class="section level4">
<h4>View Mark-recapture data</h4>
<p>We have 10 years of data on banding and recapturing shrikes. The data is summarized in an m-array, which tallies the individual capture histories.</p>
<pre><code>## , , 1
## 
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]   22    4    1    0    0    0    0    0    0    71
##  [2,]    0   19    2    0    0    0    0    0    0    77
##  [3,]    0    0   20    7    0    0    0    1    0    75
##  [4,]    0    0    0   27    2    1    0    0    0    74
##  [5,]    0    0    0    0   21    5    0    0    0    96
##  [6,]    0    0    0    0    0   25    4    1    0    89
##  [7,]    0    0    0    0    0    0   19    3    0    81
##  [8,]    0    0    0    0    0    0    0   20    6    96
##  [9,]    0    0    0    0    0    0    0    0   23    96
## 
## , , 2
## 
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]   30    2    0    1    0    0    0    0    0    34
##  [2,]    0   15    6    0    2    0    0    0    0    29
##  [3,]    0    0   23    4    0    0    0    0    0    13
##  [4,]    0    0    0   17    0    1    0    0    0    34
##  [5,]    0    0    0    0   21    4    0    0    0    31
##  [6,]    0    0    0    0    0   19    1    1    0    25
##  [7,]    0    0    0    0    0    0   18    3    1    33
##  [8,]    0    0    0    0    0    0    0   10    5    27
##  [9,]    0    0    0    0    0    0    0    0   14    25</code></pre>
</div>
<div id="view-count-data" class="section level4">
<h4>View Count data</h4>
<p>We counted breeding pairs each year for 10 years.</p>
<pre><code>##  [1] 194 191 180 235 233 202 218 236 244 254</code></pre>
</div>
<div id="productivity-data" class="section level4">
<h4>Productivity data</h4>
<p>We detected nests and monitored them to see how many chicks fledged per nest.</p>
<pre><code>##       Juveniles Surveyed broods
##  [1,]        98              62
##  [2,]        95              49
##  [3,]       102              59
##  [4,]       106              69
##  [5,]       118              74
##  [6,]        98              59
##  [7,]        92              60
##  [8,]       128              82
##  [9,]       109              67
## [10,]       108              72</code></pre>
</div>
</div>
<div id="step-2-bugs-model-specification" class="section level3">
<h3>STEP 2: BUGS model specification</h3>
<p>Now we need to write our individual models in BUGS language so that Jags knows what to do with them! Here is the model we went through in class, with all 3 kinds of data.</p>
<pre class="r"><code>cat(file = &quot;ShrikeIPM.jags&quot;, &quot;
    model { 
    # Priors and constraints
    mean.sj ~ dunif(0, 1)
    mean.sa ~ dunif(0, 1)
    mean.p ~ dunif(0, 1)
    mean.f ~ dunif(0, 10)
    
    for (t in 1:(n.occasions-1)){
    sj[t] &lt;- mean.sj   #time dependence in likelihood, but not here
    sa[t] &lt;- mean.sa
    p[t] &lt;- mean.p
    }
    
    sigma.obs ~ dunif(0.5, 50)
    tau.obs &lt;- pow(sigma.obs, -2)
    
    # State-space model for count data
    # Model for the initial population size: discrete uniform priors
    N[1,1] ~ dunif(1, 300)
    N[2,1] ~ dunif(1, 300)
    
    # Process model over time
    for (t in 1:(n.occasions-1)){
    N[1,t+1] &lt;- mean.f * mean.sj * (N[1,t] + N[2,t])
    N[2,t+1] &lt;- mean.sa * (N[1,t] + N[2,t])
    }
    
    # Observation model
    for (t in 1:n.occasions){
    count[t] ~ dnorm(N[1,t] + N[2,t], tau.obs)
    }
    
    # Poisson regression model for productivity data
    for (i in 1:n.J){
    J[i] ~ dpois(mean.f)
    }
    
    # Capture-recapture model (multinomial likelihood)
    # Define the multinomial likelihood
    for (t in 1:(n.occasions-1)){
    marr.j[t,1:n.occasions] ~ dmulti(pr.j[t,], rel.j[t])
    marr.a[t,1:n.occasions] ~ dmulti(pr.a[t,], rel.a[t])
    }
    # Define the cell probabilities of the m-arrays
    # Main diagonal
    for (t in 1:(n.occasions-1)){
    q[t] &lt;- 1-p[t]   # Probability of non-recapture
    pr.j[t,t] &lt;- sj[t]*p[t]
    pr.a[t,t] &lt;- sa[t]*p[t]
    # Above main diagonal
    for (j in (t+1):(n.occasions-1)){
    pr.j[t,j] &lt;- sj[t]*prod(sa[(t+1):j])*prod(q[t:(j-1)])*p[j]
    pr.a[t,j] &lt;- prod(sa[t:j])*prod(q[t:(j-1)])*p[j]
    } #j
    # Below main diagonal
    for (j in 1:(t-1)){
    pr.j[t,j] &lt;- 0
    pr.a[t,j] &lt;- 0
    } #j
    } #t
    # Last column: probability of non-recapture
    for (t in 1:(n.occasions-1)){
    pr.j[t,n.occasions] &lt;- 1-sum(pr.j[t,1:(n.occasions-1)])
    pr.a[t,n.occasions] &lt;- 1-sum(pr.a[t,1:(n.occasions-1)])
    } #t
    
    # Derived parameters
    # Annual population growth rate
    for (t in 1:(n.occasions-1)){
    ann.growth.rate[t] &lt;- (N[1,t+1] + N[2,t+1]) / (N[1,t] + N[2,t])    
    }
    # Total population size
    for (t in 1:n.occasions){
    Ntot[t] &lt;- N[1,t] + N[2,t]
    }
    }
    &quot;)</code></pre>
<pre class="r"><code># Bundle data
bugs.data &lt;- list(marr.j = marray[,,1], marr.a = marray[,,2], n.occasions = T, rel.j = rowSums(marray[,,1]), rel.a = rowSums(marray[,,2]), J = P$rep.ind[,1], n.J = nrow(P$rep.ind), count = count)</code></pre>
<div id="step-3-more-info-jags-needs" class="section level4">
<h4>STEP 3: More info JAGS needs</h4>
<pre class="r"><code># Initial values
inits &lt;- function(){list(mean.sj = runif(1, 0, 0.5), mean.sa = runif(1, 0, 1))}
#sometimes need initials for population sizes as well. 

# Parameters monitored
parameters &lt;- c(&quot;mean.sj&quot;, &quot;mean.sa&quot;, &quot;mean.p&quot;, &quot;mean.f&quot;, &quot;N&quot;, &quot;sigma.obs&quot;, &quot;ann.growth.rate&quot;, &quot;Ntot&quot;)

# MCMC settings
ni &lt;- 12000; nt &lt;- 6; nb &lt;- 2000; nc &lt;- 3</code></pre>
</div>
<div id="step-4-running-jags" class="section level4">
<h4>STEP 4: Running JAGS</h4>
<pre class="r"><code># Call JAGS from R (jagsUI)
ShrikeIPM &lt;- jags(bugs.data, inits, parameters, &quot;ShrikeIPM.jags&quot;, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)</code></pre>
<pre><code>## 
## Processing function input.......</code></pre>
<pre><code>## Warning in process.input(data, parameters.to.save, inits, n.chains,
## n.iter, : Number of iterations saved after thinning is not an integer; JAGS
## will round it up.</code></pre>
<pre><code>## 
## Done. 
##  
## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
## Graph information:
##    Observed stochastic nodes: 681
##    Unobserved stochastic nodes: 7
##    Total graph size: 1220
## 
## Initializing model
## 
## Adaptive phase, 100 iterations x 3 chains 
## If no progress bar appears JAGS has decided not to adapt 
##  
## 
##  Burn-in phase, 2000 iterations x 3 chains 
##  
## 
## Sampling from joint posterior, 10000 iterations x 3 chains 
##  
## 
## Calculating statistics....... 
## 
## Done.</code></pre>
</div>
</div>
<div id="results" class="section level3">
<h3>Results!</h3>
<pre class="r"><code>print(ShrikeIPM, 3)</code></pre>
<pre><code>## JAGS output for model &#39;ShrikeIPM.jags&#39;, generated by jagsUI.
## Estimates based on 3 chains of 12000 iterations,
## burn-in = 2000 iterations and thin rate = 6,
## yielding 5001 total samples from the joint posterior. 
## MCMC ran for 0.236 minutes at time 2016-12-01 11:14:54.
## 
##                        mean     sd     2.5%      50%    97.5% overlap0 f
## mean.sj               0.297  0.013    0.271    0.297    0.323    FALSE 1
## mean.sa               0.551  0.019    0.513    0.552    0.590    FALSE 1
## mean.p                0.665  0.027    0.613    0.666    0.718    FALSE 1
## mean.f                1.613  0.046    1.525    1.612    1.705    FALSE 1
## N[1,1]              106.308 54.100    7.865  111.825  189.947    FALSE 1
## N[2,1]               84.164 53.471    4.911   77.719  184.604    FALSE 1
## N[1,2]               91.189  5.483   80.735   91.023  102.387    FALSE 1
## N[2,2]              105.013  6.588   92.509  104.863  118.281    FALSE 1
## N[1,3]               93.945  5.191   83.969   93.866  104.381    FALSE 1
## N[2,3]              108.178  6.101   96.426  108.056  120.399    FALSE 1
## N[1,4]               96.795  5.011   87.010   96.769  106.955    FALSE 1
## N[2,4]              111.448  5.701  100.340  111.369  122.698    FALSE 1
## N[1,5]               99.740  4.983   90.050   99.642  109.769    FALSE 1
## N[2,5]              114.828  5.437  104.257  114.712  125.580    FALSE 1
## N[1,6]              102.784  5.139   92.714  102.760  113.099    FALSE 1
## N[2,6]              118.322  5.366  107.833  118.254  129.071    FALSE 1
## N[1,7]              105.931  5.494   95.283  105.858  116.863    FALSE 1
## N[2,7]              121.933  5.533  110.991  121.972  132.888    FALSE 1
## N[1,8]              109.185  6.047   97.503  109.080  120.937    FALSE 1
## N[2,8]              125.667  5.959  113.931  125.644  137.669    FALSE 1
## N[1,9]              112.549  6.782   99.633  112.421  125.955    FALSE 1
## N[2,9]              129.527  6.636  116.407  129.512  142.836    FALSE 1
## N[1,10]             116.028  7.679  101.180  115.863  131.318    FALSE 1
## N[2,10]             133.518  7.538  118.552  133.486  148.524    FALSE 1
## sigma.obs            19.128  5.796   11.336   17.959   34.566    FALSE 1
## ann.growth.rate[1]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[2]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[3]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[4]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[5]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[6]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[7]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[8]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## ann.growth.rate[9]    1.031  0.010    1.010    1.031    1.050    FALSE 1
## Ntot[1]             190.472 10.831  169.556  190.095  212.658    FALSE 1
## Ntot[2]             196.202  9.566  177.319  195.994  215.434    FALSE 1
## Ntot[3]             202.123  8.364  185.570  202.051  218.814    FALSE 1
## Ntot[4]             208.243  7.327  193.836  208.339  222.686    FALSE 1
## Ntot[5]             214.568  6.624  201.257  214.708  227.764    FALSE 1
## Ntot[6]             221.106  6.468  207.963  221.279  233.827    FALSE 1
## Ntot[7]             227.865  7.007  213.405  227.973  241.603    FALSE 1
## Ntot[8]             234.852  8.210  218.205  234.981  250.666    FALSE 1
## Ntot[9]             242.076  9.936  221.558  242.304  261.522    FALSE 1
## Ntot[10]            249.546 12.055  224.783  249.763  273.344    FALSE 1
## deviance           2357.136  4.054 2351.610 2356.350 2367.143    FALSE 1
##                     Rhat n.eff
## mean.sj            1.001  4359
## mean.sa            1.003   673
## mean.p             1.000  3247
## mean.f             1.002   815
## N[1,1]             1.024    95
## N[2,1]             1.025    96
## N[1,2]             1.000  3162
## N[2,2]             1.002   979
## N[1,3]             1.001  2479
## N[2,3]             1.002   832
## N[1,4]             1.001  2034
## N[2,4]             1.003   718
## N[1,5]             1.001  1781
## N[2,5]             1.003   645
## N[1,6]             1.001  1687
## N[2,6]             1.003   619
## N[1,7]             1.001  1727
## N[2,7]             1.003   646
## N[1,8]             1.001  1883
## N[2,8]             1.003   734
## N[1,9]             1.001  2144
## N[2,9]             1.002   888
## N[1,10]            1.001  2500
## N[2,10]            1.002  1115
## sigma.obs          1.000  5001
## ann.growth.rate[1] 1.000  5001
## ann.growth.rate[2] 1.000  5001
## ann.growth.rate[3] 1.000  5001
## ann.growth.rate[4] 1.000  5001
## ann.growth.rate[5] 1.000  5001
## ann.growth.rate[6] 1.000  5001
## ann.growth.rate[7] 1.000  5001
## ann.growth.rate[8] 1.000  5001
## ann.growth.rate[9] 1.000  5001
## Ntot[1]            1.000  5001
## Ntot[2]            1.000  5001
## Ntot[3]            1.000  4318
## Ntot[4]            1.000  3615
## Ntot[5]            1.001  3224
## Ntot[6]            1.001  3354
## Ntot[7]            1.001  4291
## Ntot[8]            1.000  5001
## Ntot[9]            1.000  5001
## Ntot[10]           1.000  5001
## deviance           1.001  5001
## 
## Successful convergence based on Rhat values (all &lt; 1.1). 
## Rhat is the potential scale reduction factor (at convergence, Rhat=1). 
## For each parameter, n.eff is a crude measure of effective sample size. 
## 
## overlap0 checks if 0 falls in the parameter&#39;s 95% credible interval.
## f is the proportion of the posterior with the same sign as the mean;
## i.e., our confidence that the parameter is positive or negative.
## 
## DIC info: (pD = var(deviance)/2) 
## pD = 8.2 and DIC = 2365.354 
## DIC is an estimate of expected predictive error (lower is better).</code></pre>
<p>Let’s look at a few of our chains and posteriors.</p>
<pre class="r"><code>par(mfrow = c(2,2))
traceplot(ShrikeIPM,parameters=c(&quot;mean.sj&quot;, &quot;mean.sa&quot;, &quot;mean.p&quot;, &quot;mean.f&quot;))</code></pre>
<p><img src="IPM_miniLab_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code>par(mfrow = c(2,2))
plot(density(ShrikeIPM$sims.list$mean.sj), xlab=&quot;Juvenile Survival&quot;, main=&quot;&quot;)
abline(v=.3, col=&quot;red&quot;)
plot(density(ShrikeIPM$sims.list$mean.sa), xlab=&quot;Adult Survival&quot;, main=&quot;&quot;)
abline(v=.55, col=&quot;red&quot;)
plot(density(ShrikeIPM$sims.list$mean.p), xlab=&quot;Detection&quot;, main=&quot;&quot;)
abline(v=.6, col=&quot;red&quot;)
plot(density(ShrikeIPM$sims.list$mean.f), xlab=&quot;Fecundity&quot;, main=&quot;&quot;)
abline(v=1.6, col=&quot;red&quot;)</code></pre>
<p><img src="IPM_miniLab_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>Let’s make a graph of our estimated population trend compared to our count data</p>
<pre class="r"><code>u &lt;- col2rgb(&quot;grey92&quot;)
col.pol &lt;- rgb(u[1], u[2], u[3], alpha = 75, maxColorValue = 255)
par(cex = 1.2)
plot(ShrikeIPM$mean$Ntot, type = &quot;n&quot;, ylim = range(c(ShrikeIPM$q2.5$Ntot, ShrikeIPM$q97.5$Ntot)), ylab = &quot;Population size&quot;, xlab = &quot;Year&quot;, las = 1, cex = 1.5)
points(ShrikeIPM$mean$Ntot, type = &quot;b&quot;, col = &quot;black&quot;, pch = 16, lty = 1, cex = 1.5)
points(count, type = &quot;b&quot;, col = &quot;red&quot;, pch = 1, lty = 2, cex = 1.5)
polygon(c(1:T, T:1), c(ShrikeIPM$q2.5$Ntot, ShrikeIPM$q97.5$Ntot[T:1]), border = NA, col = col.pol)
legend(&quot;topleft&quot;, legend = c(&quot;Counts&quot;, &quot;Estimates&quot;), pch = c(1, 16), col = c(&quot;red&quot;, &quot;black&quot;), lty = c(2, 1), bty = &quot;n&quot;)</code></pre>
<p><img src="IPM_miniLab_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
</div>
</div>
<div id="now-for-the-questions" class="section level2">
<h2>Now for the questions!</h2>
<div id="question-1" class="section level3">
<h3>Question 1</h3>
<p>Take a look at the mcmc chains and the posterior distributions from the model. Do we have convergence? How can you tell?</p>
</div>
<div id="question-2" class="section level3">
<h3>Question 2</h3>
<p>Now take the above jags model and modify it by removing the fecundity data and then run it. The program will use the shared information to calcuate fecundity. (Hint, you will still need the prior on fecundity). How does the new estimate of mean f compare to the one from the first model? How has the variance changed?</p>
</div>
<div id="question-3" class="section level3">
<h3>Question 3</h3>
<p>Let’s look at a model with only count data (no longer and integrated model!) so we can compare it to our first two models. Did the model converge? If not, run it for longer! Now compare the estimates and their standard deviations to the model with all data types and the model with just two. Are they different? How?</p>
</div>
<div id="question-4" class="section level3">
<h3>Question 4</h3>
<p>What concerns might you have about running models without explicit data for some of the parameters?</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
