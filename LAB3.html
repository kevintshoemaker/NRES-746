<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="NRES 746" />


<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />

<title>Lab 3</title>


<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>

<!-- taken from https://github.com/rstudio/rmarkdown/blob/67b7f5fc779e4cfdfd0f021d3d7745b6b6e17149/inst/rmd/h/default.html#L296-L362 -->
<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->



</head>

<body>



<div class="pageContent band">
<div class="bandContent page">

<div class="topics">

<div id="section-maximum-likelihood-and-optimization" class="section level2">
<h2>Maximum likelihood and optimization</h2>
<p>These next few weeks are focused on fitting models, specifically estimating model parameters and confidence intervals, using likelihood-based techniques (maximum likelihood and Bayesian model fitting). Estimating model parameters means finding the values of a set of parameters that best ‘fit’ the data. <em>Likelihood</em> is a metric that represents the probability of drawing your particular data set given a fully specified model (e.g., a particular data-generating model with a particular set of parameter values). This lab is designed to take two lab sessions to complete.</p>
<p>As with all lab reports, your answers will either take the form of R functions (submitted as an R script) or short written responses (submitted together in a Word document). The R functions (and only the functions- not your testing code) should be stored in an R script file (‘.R’ extension). You don’t need to follow any naming convention for your R script as long as you submit via WebCampus.</p>
<p>Please submit the R script and the Word document via WebCampus by midnight on the due date (one week after the final lab session allocated for this topic – here, <em>Oct. 25, 2021</em>). You can work in groups but please submit the materials individually.</p>
<p>First, take a little time to review the <a href="http://kevintshoemaker.github.io/NRES-746/LECTURE4.html">likelihood lecture</a>!</p>
</div>
<div id="section-example-reed-frog-predation-data" class="section level2">
<h2>Example: reed frog predation data</h2>
<p>First, load the reed frog predation data from the Bolker book- it can be found <a href="http://kevintshoemaker.github.io/NRES-746/ReedfrogPred.csv">here</a>. Save this file to your working directory.</p>
<p>This dataset represents predation data for <em>Hyperolius spinigularis</em> (Vonesh and Bolker 2005). You can read more about this data set in the Bolker book.</p>
<pre class="r"><code>###### Read in the reed frog data set

#rfp &lt;- read.csv(&quot;ReedfrogPred.csv&quot;)

########
# alternatively, load the data using the &#39;emdbook&#39; package:

library(emdbook)</code></pre>
<pre><code>## Warning: package &#39;emdbook&#39; was built under R version 4.1.1</code></pre>
<pre class="r"><code>rfp &lt;- ReedfrogPred

head(rfp)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["density"],"name":[1],"type":["int"],"align":["right"]},{"label":["pred"],"name":[2],"type":["fct"],"align":["left"]},{"label":["size"],"name":[3],"type":["fct"],"align":["left"]},{"label":["surv"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["propsurv"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"10","2":"no","3":"big","4":"9","5":"0.9","_rn_":"1"},{"1":"10","2":"no","3":"big","4":"10","5":"1.0","_rn_":"2"},{"1":"10","2":"no","3":"big","4":"7","5":"0.7","_rn_":"3"},{"1":"10","2":"no","3":"big","4":"10","5":"1.0","_rn_":"4"},{"1":"10","2":"no","3":"small","4":"9","5":"0.9","_rn_":"5"},{"1":"10","2":"no","3":"small","4":"9","5":"0.9","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Parameter estimation is simplest when the data represent a collection of independent observations, with each observation having the same set of parameters. Because predation on tadpoles is size and density-dependent, we will subset these data to a single size class (‘small’) and density (10) for all treatments including a predator. Subset your data now:</p>
<pre class="r"><code>##### Take a subset of the data

rfp_sub &lt;- subset(rfp, (rfp$pred==&#39;pred&#39;)&amp;(rfp$size==&quot;small&quot;)&amp;(rfp$density==10))
rfp_sub</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["density"],"name":[1],"type":["int"],"align":["right"]},{"label":["pred"],"name":[2],"type":["fct"],"align":["left"]},{"label":["size"],"name":[3],"type":["fct"],"align":["left"]},{"label":["surv"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["propsurv"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"10","2":"pred","3":"small","4":"7","5":"0.7","_rn_":"13"},{"1":"10","2":"pred","3":"small","4":"5","5":"0.5","_rn_":"14"},{"1":"10","2":"pred","3":"small","4":"9","5":"0.9","_rn_":"15"},{"1":"10","2":"pred","3":"small","4":"9","5":"0.9","_rn_":"16"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>For each individual, the per-trial probability of being eaten by a predator is a binomial process (i.e., they can survive or die during the interval). Recall that the likelihood that k out of N individuals are eaten as a function of the per capita predation probability p is:</p>
<p><span class="math inline">\(Prob(k|p,N) = \binom{N}{k}p^{k}(1-p)^{N-k}\)</span></p>
<p>Since the observations are independent, the joint likelihood of the whole data set is the product of the likelihood of each individual observation. So, if we have n observations, each with the same total number of tadpoles N, and the number of tadpoles killed in the ith observation is ki, then the likelihood is:</p>
<p><span class="math inline">\(L = \prod_{i=1}^{n}\binom{N}{k_{i}}p^{k_{i}}(1-p)^{N-k_{i}}\)</span></p>
<p>Here we assume the data are binomially distributed – the binomial distribution is the natural choice for data that are represented as k ‘successes’ out of N ’trials. We conventionally work in terms of the log-likelihood (LL), which is:</p>
<p><span class="math inline">\(LL = \sum_{i=1}^{n}\left [log\binom{N}{k}+k_{i}log(p)+(N-k_{i})log(1-p) \right ]\)</span></p>
<p>In R this would be</p>
<pre class="r"><code>killed &lt;- rfp_sub$density-rfp_sub$surv
N=rfp_sub$density
p=0.5
sum(dbinom(killed, size=N, prob=p, log=TRUE))    # expression of data likelihoodb(log scale)</code></pre>
<p>There is only one parameter in this calculation, <em>p</em>, because we know how many individuals we started with (<em>N</em> = 10 for each trial) and how many survived in each trial (k = 7, 5, 9, and 9). So we want to solve for the most likely value of <em>p</em> given our observations of <em>N</em> and <em>surv</em>. In essence we do this by picking a possible value of <em>p</em> (which can only range from 0 to 1), calculating the log-likelihood using the equation above, picking another value of p, completing the equation, etc. until we exhaust all possible values of p and identify the one having the highest likelihood value. Of course R has useful built in functions to help us optimize the likelihood function!</p>
<p>The “dbinom()” function calculates the binomial likelihood for a specified data set, specifically a vector of the number of successes (or events) k, probability p, and number of trials N. Specify your vector of successes (here a success means being eaten by a predator!):</p>
<pre class="r"><code>num_killed &lt;- rfp_sub$density-rfp_sub$surv     # specify vector of &quot;successes&quot; (being eaten!)
num_killed</code></pre>
<pre><code>## [1] 3 5 1 1</code></pre>
<p>Given our observed <em>k</em> (number killed), and <em>N</em> = 10 for each trial, what is the likelihood that <em>p</em> = 0.5 for each of our trials?</p>
<pre class="r"><code>dbinom(num_killed,size=10,prob=0.5)  # evaluate data likelihood with p=0.5</code></pre>
<pre><code>## [1] 0.117187500 0.246093750 0.009765625 0.009765625</code></pre>
<p>[1] 0.117187500 0.246093750 0.009765625 0.009765625</p>
<p>We can see that given our data, fixed sample size, and model (with <em>p</em> = 0.5), our observed outcomes are very unlikely.</p>
<p>What is the likelihood of observing all 4 of our outcomes, i.e, the joint probability of our data?</p>
<pre class="r"><code>prod(dbinom(num_killed,size=10,prob=0.5))    # joint data likelihood</code></pre>
<pre><code>## [1] 2.750312e-06</code></pre>
<p>The joint likelihood values will be less than 1, and gets smaller and smaller each time we add more data (can you see why?). This is why we prefer to work with log-likelihoods (which yield larger numbers having better mathematical properties). And taking the log of a value &lt;1 yields a negative number, which is why we often see that our log likelihood values are negative.</p>
<p>For now, we can build on this above process to estimate the likelihood function over the entire possible parameter space (probability of being eaten- which can range from 0 to 1).</p>
<p>First we make a sequence of 100 possible parameter values from 0.01 to 1.</p>
<pre class="r"><code>p &lt;- seq(0.01, 1, length=100)     # prepare for visualizing the likelihood across parameter space</code></pre>
<p>Then we make an empty storage vector for the likelihoods we’ll calculate</p>
<pre class="r"><code>Lik &lt;- numeric(length=100)</code></pre>
<p>Now for the <strong>for</strong> loop! For every value of p (a sequence of 100 values) we will calculate the binomial probability and store it in the ‘Lik’ vector.</p>
<pre class="r"><code>#########
# plot out the likelihood

for(i in 1:100){
  Lik[i] &lt;- prod(dbinom(num_killed,size=10,prob=p[i]))
}
plot(Lik~p,lty=&quot;solid&quot;,type=&quot;l&quot;, xlab=&quot;Predation Probability&quot;, ylab=&quot;Likelihood&quot;)</code></pre>
<p><img src="LAB3_files/figure-html/unnamed-chunk-10-1.png" width="624" /></p>
<p>But we want to maximize the log-likelihood:</p>
<pre class="r"><code>########
# plot out the log-likelihood

p &lt;- seq(0.01, 1, by=0.01)
LogLik &lt;- numeric(length=100)
for(i in 1:100){
  LogLik[i] &lt;- sum(dbinom(num_killed, size=10, 
  prob=p[i],log=TRUE))
}
plot(LogLik~p,lty=&quot;solid&quot;,type=&quot;l&quot;, xlab=&quot;Predation Probability&quot;, ylab=&quot;Log Likelihood&quot;)</code></pre>
<p><img src="LAB3_files/figure-html/unnamed-chunk-11-1.png" width="624" /></p>
<p>We can ask R to tell us at which value of p the Log-Likelihood is maximized:</p>
<pre class="r"><code>p[which(LogLik==max(LogLik))]     # MLE for probability of predation</code></pre>
<pre><code>## [1] 0.25</code></pre>
<p>And we can add an “abline()” to indicate the maximum Log-Likelihood estimate:</p>
<pre class="r"><code>plot(LogLik~p,lty=&quot;solid&quot;,type=&quot;l&quot;, xlab=&quot;Predation Probability&quot;, ylab=&quot;Log Likelihood&quot;)
abline(v=0.25,lwd=3)</code></pre>
<p><img src="LAB3_files/figure-html/unnamed-chunk-13-1.png" width="624" /></p>
<p>Alternatively, we can use the optim() or mle2() functions to find the maximum likelihood estimate. Although we seek the most likely, or maximum likelihood estimate, in practice we generally minimize the negative log-likelihood. To do so, first write a function to calculate the binomial negative log-likelihood function and estimate parameter p.</p>
<pre class="r"><code>###########
# Write a likelihood function

#    p: probability of predation per trial (param to estimate)
#    k: number killed per trial   (data)
#    N: number of tadpoles per trial (data)

binomNLL1 &lt;- function(p, k, N) {
  -sum(dbinom(k, size=N, prob=p, log=TRUE))
}</code></pre>
<p>As we did in class, you can use the ‘optim()’ function to minimize your negative log-likelihood function (‘binomNLL1()’) given a vector of starting parameters and your data. The starting parameters need not be accurate, but do need to be reasonable for the function to work, that’s why we spent time in class eyeballing curves (also read the Bolker book for a discussion of the ‘method of moments’, which can help you get reasonable starting values!). Given that there is only one estimable parameter, <em>p</em>, in the binomial function, you need only provide a starting estimate for it. Calculate the negative log-likelihood:</p>
<pre class="r"><code>#####
# use &quot;optim()&quot; to find the MLE

opt1 &lt;- optim(fn=binomNLL1, par = c(p=0.5), N = 10, k = num_killed, method = &quot;BFGS&quot;)   # use &quot;optim()&quot; to estimate the parameter value that maximizes the likelihood function </code></pre>
<pre><code>## Warning in dbinom(k, size = N, prob = p, log = TRUE): NaNs produced

## Warning in dbinom(k, size = N, prob = p, log = TRUE): NaNs produced

## Warning in dbinom(k, size = N, prob = p, log = TRUE): NaNs produced

## Warning in dbinom(k, size = N, prob = p, log = TRUE): NaNs produced

## Warning in dbinom(k, size = N, prob = p, log = TRUE): NaNs produced</code></pre>
<p>You may get several warning messages, can you think why? opt1 returns a list that stores information about your optimization process.</p>
<pre class="r"><code>opt1    # check out the results of &quot;optim()&quot;</code></pre>
<pre><code>## $par
##         p 
## 0.2500002 
## 
## $value
## [1] 7.571315
## 
## $counts
## function gradient 
##       17        7 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<p>The important bits are whether or not the process achieved convergence and the parameter estimate that was converged upon.</p>
<pre class="r"><code>opt1$convergence</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Here a value of 0 means convergence has been achieved, a value of 1 means the process failed to converge. There is more info about convergence and alternative optimization options in Chapter 7 of the Bolker book.</p>
<p>Your best fit estimate of p is:</p>
<pre class="r"><code>opt1$par  # MLE</code></pre>
<pre><code>##         p 
## 0.2500002</code></pre>
<p>This numerically computed answer is (almost exactly) equal to the theoretical answer of 0.25. The value of the function you optimized, binomNLL1, is:</p>
<pre class="r"><code>opt1$value     # max. likelihood (actually minimum negative-log-likelihood)</code></pre>
<pre><code>## [1] 7.571315</code></pre>
<p>which is the negative log-likelihood for the model. And, as we already know, the absolute likelihood of this particular outcome (5, 3, 1 and 1 out of 10 tadpoles eaten in four replicates) is quite low, even for this simple four-observation scenario:</p>
<pre class="r"><code>exp(-opt1$value)   # convert to likelihood</code></pre>
<pre><code>## [1] 0.0005150149</code></pre>
<p>Plot your observed outcomes against your predictions under the maximum likelihood model:</p>
<pre class="r"><code>hist(num_killed,xlim=c(0,10),freq=F)
curve(dbinom(x,prob=opt1$par,size=10),add=T,from=0,to=10,n=11)</code></pre>
<p><img src="LAB3_files/figure-html/unnamed-chunk-21-1.png" width="624" /></p>
<p>Note that “freq=F” scales the y-axis of a histogram to “density”, which allows us to overlay probability density functions.</p>
</div>
<div id="section-exercise-3.1" class="section level2">
<h2>Exercise 3.1</h2>
<p>Develop a function that returns the data likelihood (<em>likelihood function</em>) for the following scenario (introduced in lecture): you visit three known-occupied wetland sites ten times and for each site you record the number of visits for which a particular frog species is detected (at least one call within a 5 minute period). Assuming that all sites are occupied continuously, compute the likelihood of these data: [3,2 and 6 detections for sites 1, 2, and 3 respectively] for a given detection probability <span class="math inline">\(p\)</span>. Assume that all sites have the same detection probability (<em>p</em>, which is our free parameter). Using this likelihood function, answer the following questions:</p>
</div>
<div id="section-exercise-3.1a." class="section level2">
<h2><strong>Exercise 3.1a</strong>.</h2>
<p>Write a function called “NLL_frogOccupancy()” for computing the data likelihood (actually, negative log-likelihood) for the above scenario.</p>
<ul>
<li><strong>input</strong>:
<ul>
<li>params = a scalar (floating point) specifying a proposed value (initial value) for the parameter “p” (probability of detection for a single visit – which happens to be the only free parameter in this model)<br />
</li>
<li>data = a vector of integers with number of elements (length) equal to the number of sites, representing the number of times the species was detected out of N visits.</li>
<li>N = an integer representing the total number of visits conducted at each site (default= 10 visits)</li>
</ul></li>
<li><strong>suggested algorithm</strong>:
<ul>
<li>up to you! (HINT: use binomial distribution)</li>
</ul></li>
<li><strong>return</strong>:
<ul>
<li>the negative log likelihood of all observations</li>
</ul></li>
</ul>
<p>Include your function in your submitted r script!</p>
<p>You can use this “sandbox” (below) to develop and test your function!</p>
<div class="tutorial-exercise" data-label="q3_1a" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>NLL_frogOccupancy &lt;- function(params,data,N){
    # [add code here!]
}
#NLL_frogOccupancy(params=0.5,data=c(3,2,6),N=10)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>And test your function! For example:</p>
<pre class="r"><code>NLL_frogOccupancy(params=0.5,data=c(3,2,6),N=10)   # test your function</code></pre>
<pre><code>## [1] 6.853154</code></pre>
</div>
<div id="section-exercise-3.1b." class="section level2">
<h2><strong>Exercise 3.1b</strong>.</h2>
<p>In your Word document, respond briefly to the following questions:</p>
<ol style="list-style-type: decimal">
<li>What is the maximum likelihood estimate for the <em>p</em> (detection probability) parameter? How did you use your likelihood function to get your answer (briefly)?<br />
</li>
<li>Using the “rule of 2”, what is the approximate 95% confidence interval for the <em>p</em> parameter. Include a figure (plot) in your Word document illustrating how you got your answer.</li>
</ol>
</div>
<div id="section-adding-a-deterministic-relationship" class="section level2">
<h2>Adding a Deterministic Relationship</h2>
<p>So we’ve looked at how to obtain the likelihood of getting our dataset given a stochastic model (the binomial distribution), but now we want to consider more interesting ecological questions like when the mean or variance of the model parameters vary among groups or depend upon covariates. Recall that we subset our data above because we expected survival to be (in part) density-dependent. Here we’ll consider how to model the probability of tadpole survival as a function of the initial density of tadpoles in the population. To do so, we need to incorporate a deterministic function into our stochastic model.</p>
<p>Save the reed frog functional response dataset to your working directory- it can be found <a href="http://kevintshoemaker.github.io/NRES-746/ReedfrogFuncresp.csv">here</a>.</p>
<p>First, examine the first few lines:</p>
<pre class="r"><code>#####
# 3.2a

#rffr &lt;- read.csv(&quot;ReedfrogFuncResp.csv&quot;,row.names = 1)
  # alternative: 
rffr &lt;- emdbook::ReedfrogFuncresp     # from Bolker&#39;s &quot;emdbook&quot; package
  # ?Reedfrog      # learn more about this dataset
head(rffr)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Initial"],"name":[1],"type":["int"],"align":["right"]},{"label":["Killed"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"5","2":"1","_rn_":"1"},{"1":"5","2":"2","_rn_":"2"},{"1":"10","2":"5","_rn_":"3"},{"1":"10","2":"6","_rn_":"4"},{"1":"15","2":"10","_rn_":"5"},{"1":"15","2":"9","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Let’s look at the distribution of the data (probability of being killed).</p>
<pre class="r"><code>hist(rffr$Killed/rffr$Initial)</code></pre>
<p><img src="LAB3_files/figure-html/unnamed-chunk-22-1.png" width="624" /></p>
<p>Based on what we know mechanistically about the data, we’ll use a binomial distribution to describe the observed number killed.</p>
<p>Plot the number killed by the initial density (using plot()) to see what sort of deterministic function would describe the pattern. It looks like it could be linear, but because we know that this is a predation response, and that predators become handling-limited (saturated) at high prey densities. On page 182 Bolker indicates that if predation rate= <span class="math inline">\(aN/(1+ahN)\)</span> (Holling Type II functional response), this means that the per-capita predation rate of tadpoles decreases hyperbolically with tadpole density <span class="math inline">\((= a/(1 + ahN))\)</span>. We’ll use this deterministic function for our data.<br />
First, let’s see what that curve would look like over our data points with an initial guess at the parameters (we always need an initial guess to seed our optimization algorithms). Recall that the a parameter of this hyperbolic function indicates the initial slope, which we’ll guess to be around 0.5, and the h parameter indicates 1/asymptote, which we fiddled around with to match the data (so try 1/80).</p>
<p><img src="LAB3_files/figure-html/dataq3_2a0-1.png" width="624" /></p>
<p>This looks pretty good, but we want to actually fit the line to the data instead of making guesses, and we’ll use likelihood to do that. Just like before, we’ll write a <em>negative log likelihood function</em>, but this time we’ll incorporate the deterministic model!</p>
</div>
<div id="section-exercise-3.2a." class="section level2">
<h2><strong>Exercise 3.2a</strong>.</h2>
<p>Reed frog functional response challenge #1: write a likelihood function for the Holling-II functional response!</p>
<p>Write a function called “binomNLL2()” for computing the data likelihood for this model. This likelihood function should reflect that the data are drawn from a binomial distribution (either killed or not), and that the probability of predation (the number killed divided by the initial number) is explained by the Holling type II equation.</p>
<ul>
<li><strong>input</strong>:
<ul>
<li>params = vector of initial values for the params to estimate (length 2: a and h from the Holling type II functional response- in that order)<br />
</li>
<li>N = a vector of the initial tadpole densities</li>
<li>k = a vector representing the number of tadpoles killed (eaten by dragonfly larvae).</li>
</ul></li>
<li><strong>suggested algorithm</strong>:
<ul>
<li>up to you! Make sure you use the Holling type II deterministic function to represent the expected number killed at each density level. Use the ‘dbinom()’ function to represent the stochastic process that generated these data. Note that the probability of being eaten (p parameter in the binomial distribution) can be computed as the expected number killed divided by the total initial density.</li>
</ul></li>
<li><strong>return</strong>:
<ul>
<li>the negative log-likelihood of the data under this model</li>
</ul></li>
</ul>
<p>Include your function in your submitted r script!</p>
<p>You can use this “sandbox” (below) to develop and test your function!</p>
<div class="tutorial-exercise" data-label="q3_2a" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>binomNLL2 &lt;- function(params,N,k){
    # [add code here!]
}
# binomNLL2(c(a=0.4,h=1/200),c(5,10,15),c(3,5,6))</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>You can test your function using something like the following:</p>
<pre class="r"><code>binomNLL2(c(a=0.4,h=1/200),c(5,10,15),c(3,5,6))</code></pre>
<pre><code>## [1] 4.706114</code></pre>
<p>Now we can find the parameter values that best describe these data using ‘optim()’. We’ll use the same initial values for a and h that we used to plot the curve. N is the initial number of tadpoles, and k is the number of tadpoles killed.</p>
<pre class="r"><code>opt2 &lt;- suppressWarnings( optim(fn=binomNLL2,  par=c(a=0.5,h=(1/80)), N=rffr$Initial, k=rffr$Killed)   )  #use default simplex algorithm
opt2</code></pre>
<pre><code>## $par
##          a          h 
## 0.52593924 0.01660613 
## 
## $value
## [1] 46.72136
## 
## $counts
## function gradient 
##       53       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<p>The results are not that different from our starting values, so we made a good guess!</p>
</div>
<div id="section-exercise-3.2b." class="section level2">
<h2><strong>Exercise 3.2b</strong>.</h2>
<p>Write a function called “Rffuncresp()” for computing the maximum-likelihood estimates and plotting the goodness-of-fit for this model.</p>
<ul>
<li><strong>input</strong>:
<ul>
<li>params = vector of initial values for the params to estimate (length 2: a and h from the Holling type II functional response- in that order)<br />
</li>
<li>data = a matrix of 2 columns and one row per observation. The first column should represent the initial tadpole densities, and the second column should represent the number killed (eaten by dragonfly larvae).</li>
</ul></li>
<li><strong>suggested algorithm</strong>:
<ul>
<li>Compute the MLE for the a and h parameters of the Holling Type II relationship.<br />
</li>
<li>Plot the observed number killed (y axis) vs the initial densities<br />
</li>
<li>Overlay a line to visualize the predictions based on the MLE parameters.</li>
<li>Finally, visualize “plug-in prediction intervals” around your MLE line to make a plot like Figure 6.5a in the Bolker book. You can use “qbinom()” to define the 95% quantiles of the binomial distribution for every point along your curve (see below).</li>
</ul></li>
<li><strong>return</strong>:
<ul>
<li>a named vector of length 2 containing the MLEs for the a and h parameters, in that order (with names “a” and “h”).</li>
</ul></li>
</ul>
<p>Include your function in your submitted r script!</p>
<p>You can use this “sandbox” (below) to develop and test your function!</p>
<div class="tutorial-exercise" data-label="q3_2b" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>Rffuncresp &lt;- function(params,data){
    # [add code here!]
}
#Rffuncresp(params=c(a=0.5,h=(1/30)),data=rffr)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>You can test the function using something like this:</p>
<pre class="r"><code>inits &lt;- c(a=0.6,h=(1/60))    # test the function
Rffuncresp(params=inits,data=rffr)</code></pre>
<p><img src="LAB3_files/figure-html/test3.2b-1.png" width="624" /></p>
<pre><code>##          a          h 
## 0.52592194 0.01660555</code></pre>
<p>NOTE: the “prediction interval” you are asked to generate here is sometimes called a <em>“plug-in” prediction interval</em>, and is a quick and dirty way to assess goodness-of-fit. Essentially, you just take the best-fit model (with parameter values at their MLE values) and use the 0.025 and 0.975 quantiles of the stochastic process (here, the binomial distribution) to define the range of data that would generally be produced under this model. NOTE: In “qbinom()”, for the “prob” argument, you can use the ratio of the x and y values to get a probability value from 0-1. For example:</p>
<pre class="r"><code>########
# how to generate plug-in prediction intervals

xvec &lt;- seq(40,80,5)
yvec &lt;- 0.5/(1+0.5*0.015*xvec) * xvec
upper&lt;-qbinom(0.975,prob=yvec/xvec, size=xvec) 
lower&lt;-qbinom(0.025,prob=yvec/xvec, size=xvec)

upper
lower</code></pre>
</div>
<div id="section-exercise-3.2c." class="section level2">
<h2><strong>Exercise 3.2c</strong>.</h2>
<p>In your Word document, respond briefly to the following questions:</p>
<ol style="list-style-type: decimal">
<li><p>Try some different starting values for the <em>a</em> and <em>h</em> parameters. Can you find any starting values that are so bad they cause the optimization algorithm (default algorithm used by “optim()” function in R) to fail?</p></li>
<li><p>Bolker calls the prediction interval you generated above a <em>plug-in prediction interval</em>. In what way(s) is this interval different than a <em>true</em> prediction interval? (hint: are there are any sources of error that the plug-in prediction interval ignores?)</p></li>
</ol>
</div>
<div id="section-review-of-the-mle-process" class="section level2">
<h2>Review of the MLE process</h2>
<p><strong>Step 1</strong>. Identify the response and explanatory variables (e.g., Predation probability and Initial Population Size). Just stating what the response and explanatory variables are will help you start modeling.</p>
<p><strong>Step 2</strong>. Determine the stochastic distribution (e.g., Binomial). In this case, the stochastic distribution was easy to identify because we chose it mechanistically. Other times it may not be so clear what the best distribution is, and looking at the histogram and plotting different distributions over the top will be helpful.</p>
<p><strong>Step 3</strong>. Specify the deterministic function (e.g., Holling type II). Again, we chose this function mechanistically, but we could have chosen different functions just by looking at the plot of the points.</p>
<p><strong>Step 4</strong>. Specify the likelihood of the data given our deterministic expectations and the stochastic distribution. Our negative <em>log likelihood function</em> combined the stochastic and deterministic elements together by having the stochastic parameter (in this case the binomial probability, <em>p</em>) be dependent upon the deterministic parameters.</p>
<p><strong>Step 5</strong>. Make a guess for the initial parameters (e.g., <em>a</em>=0.5, <em>h</em>=1/80). You need to have an initial guess at the parameters to make ‘optim()’ work, and we plotted the Holling curve to make our guess. Sometimes you will also need to make a guess at the parameters for the stochastic distribution. In these cases, the <em>method of moments</em> is often the best option (see Bolker book for details).</p>
<p><strong>Step 6</strong>. Estimate the best-fit parameters using maximum likelihood. We used optim() to search through all possible value combinations of parameters <em>a</em> and <em>h</em> to estimates for those parameters that correspond to the minimum negative log-likelihood.</p>
<p><strong>Step 7</strong>. Add confidence or prediction intervals around your estimates to represent uncertainty. We calculated some <em>plug-in estimates</em> to put “pseudo-prediction intervals” around our estimates based on the stochastic distribution.</p>
</div>
<div id="section-exploring-likelihood-surfaces-and-confidence-regions" class="section level2">
<h2>Exploring Likelihood Surfaces and Confidence Regions</h2>
<p>Let’s continue the myxomatosis virus titer example from the <a href="LECTURE5.html">optimization lecture</a>. The difference is that this time we’ll model a deterministic process (decay of viral loads over time) in addition to the stochastic process. Our goal is to fit a model to data on viral titers through time for the viruses that are grade 1 (lowest virulence). Biological common sense, and data from other titer levels, tells us to expect titer levels to start at zero, increase over time to a peak, and then to decline. Given those expectations, we’ll fit a Ricker model to these data, following Bolker’s example and extending it just a bit.</p>
<p>Our goals are to:</p>
<ul>
<li>Find the maximum likelihood estimates of the parameters of the Ricker model fit to the myxomytosis data.<br />
</li>
<li>Visualize the fit of this model to the data by:
<ul>
<li>Plotting the data</li>
<li>Adding the predicted Ricker curve</li>
<li>Adding plug-in confidence intervals</li>
<li>Plot the 2-dimensional likelihood surface for the parameters of the Ricker and add the bivariate 95% confidence interval</li>
</ul></li>
</ul>
<p>You can add the data from the ‘emdbook’ package:</p>
<pre class="r"><code>#######
# Exercise 3.3a

########
# Myxomatosis data

library(emdbook)
data(MyxoTiter_sum)      # load the data
head(MyxoTiter_sum)   </code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["grade"],"name":[1],"type":["int"],"align":["right"]},{"label":["day"],"name":[2],"type":["int"],"align":["right"]},{"label":["titer"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"2","3":"5.207","_rn_":"1"},{"1":"1","2":"2","3":"5.734","_rn_":"2"},{"1":"1","2":"2","3":"6.613","_rn_":"3"},{"1":"1","2":"3","3":"5.997","_rn_":"4"},{"1":"1","2":"3","3":"6.612","_rn_":"5"},{"1":"1","2":"3","3":"6.810","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Select just the grade 1 titers:</p>
<pre class="r"><code>myxdat &lt;- subset(MyxoTiter_sum, grade==1)    # select just the least virulent strain

plot(myxdat$titer~myxdat$day,xlim=c(0,10))    # visualize the relationship</code></pre>
<p><img src="LAB3_files/figure-html/answerq3_3a2-1.png" width="624" /></p>
</div>
<div id="section-exercise-3.3a." class="section level2">
<h2><strong>Exercise 3.3a</strong>.</h2>
<p><strong>Fit a Ricker model to the myxomatosis data</strong> (see below for step-by step instructions)</p>
<p>Write a function called “NLL_myxRicker()” for computing the data likelihood and plotting the goodness-of-fit for this model.</p>
<ul>
<li><strong>input</strong>:
<ul>
<li>params = vector of initial values for the params to estimate (length 3: <em>a</em> and <em>b</em> params from the Ricker model [see below], and the “shape” parameter of the Gamma distribution)<br />
</li>
<li>data = a matrix of 2 columns and one row per observation. The first column should represent the days since infection, and the second column should represent the virus titer.</li>
</ul></li>
<li><strong>suggested algorithm</strong>:
<ul>
<li>Compute the deterministic function: use a Ricker deterministic equation to model the expected (mean) virus titer as a function of days since infection</li>
<li>Compute the “scale” parameter of the Gamma distribution as a function of (1) mean virus titer and (2) the “shape” parameter of the Gamma distribution [NOTE: the variance and the mean of the Gamma distribution are dependent- so we can’t simply model the expected value and the noise separately! See below for more details]</li>
<li>Compute the sum of the negative log-likelihoods of all observations (use the “dgamma()” function)</li>
</ul></li>
<li><strong>return</strong>:
<ul>
<li>the sum of the negative log-likelihoods of all observations (a single number representing the data likelihood)</li>
</ul></li>
</ul>
<p>This task (develop likelihood function) can be broken down into a few steps, just like we did above!</p>
<p>Our question is: how does a virus titer change in rabbits as a function of time since infection? This is almost exactly the same problem as we just did (above), but we’re using different distributions and functions. To solve the problem, you’ll need to go through the same steps outlined above.</p>
<p><strong>Step 1</strong>. <em>Identify the response and explanatory variables</em>. The response is the virus titer and the explanatory variable is the days since infection.</p>
<p><strong>Step 2</strong>. <em>Determine the stochastic distribution.</em><br />
Start by plotting the histogram of the response variable. Bolker suggests a gamma distribution – does it look like a gamma would work? Write down the parameters for the gamma distribution (page 133). (For the gamma distribution, use with the shape and scale parameters (not the rate)).</p>
<p><strong>Step 3</strong>. <em>Specify the deterministic function</em>.<br />
Plot the data points (hint: look at figure 6.5b). Bolker suggests the Ricker curve – does it look like the Ricker curve would work? Write down the equation and parameters for the Ricker curve (page 94).</p>
<p><strong>Step 4</strong>. <em>Specify the likelihood of the data given our deterministic expectations and the stochastic distribution.</em> Take a moment to think how the parameters of the stochastic distribution are determined by the parameters of the deterministic function. For the gamma distribution, both the shape and scale parameters are related to the mean of the distribution, i.e., mean = shape × scale (page 133). So how will you specify that the deterministic function (the Ricker model) should represent the mean? What parameters do you need your (negative) log-likelihood function to estimate? Write out your negative log-likelihood function to solve for the likelihood.</p>
<p>ASIDE: the mean and variance of the gamma distribution are inter-related: the shape parameter can be specified as: <span class="math inline">\(\frac{mean^2}{var}\)</span> and the scale parameter can be specified as <span class="math inline">\(\frac{var}{mean}\)</span>!</p>
<p>Include your function in your submitted r script!</p>
<p>You can use this “sandbox” (below) to develop and test your function!</p>
<div class="tutorial-exercise" data-label="q3_3a" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>NLL_myxRicker &lt;- function(params,data){
    # [add code here!]
}
#NLL_myxRicker(params=c(a=2,b=0.1,shape=80),data=myxdat[,-1])</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>You can test your function using something like this:</p>
<pre class="r"><code>NLL_myxRicker(params=c(a=4,b=0.2,shape=40),data=myxdat[,-1])   # test the function</code></pre>
<pre><code>## [1] 35.39427</code></pre>
</div>
<div id="section-exercise-3.3b." class="section level2">
<h2><strong>Exercise 3.3b</strong>.</h2>
<p>Write a function called “MyxRicker()” for computing the maximum likelihood estimates and plotting the goodness-of-fit for this model.</p>
<ul>
<li><strong>input</strong>:
<ul>
<li>params = vector of initial values for the params to estimate (length 3: <em>a</em> and <em>b</em> params from the Ricker model [see below], and the “shape” parameter of the Gamma distribution)<br />
</li>
<li>data = a matrix of 2 columns and one row per observation. The first column should represent the days since infection, and the second column should represent the virus titer.</li>
</ul></li>
<li><strong>suggested algorithm</strong>:
<ul>
<li>Compute the MLE for the <em>a</em>, <em>b</em>, and <em>shape</em> parameters for the Ricker/Gamma model (use “optim()” with the likelhood function you just wrote and the initial values in “params”).<br />
</li>
<li>Plot the observed virus titer (y axis) vs the days since infection (x axis).<br />
</li>
<li>Overlay a line to visualize your predictions from the Ricker model (expected values) based on the MLE parameters (just the Ricker parameters).</li>
<li>Finally, visualize “plug-in prediction intervals” around your MLE line to make a plot like Figure 6.5a in the Bolker book. Hint: use “qgamma()” to define the 95% quantiles of the Gamma distribution for every point along your curve (see below).</li>
</ul></li>
<li><strong>return</strong>:
<ul>
<li>a named vector of length 3 containing the MLE for the a, b, and shape parameters, in that order (with names “a”,“b”, and “shape” )</li>
</ul></li>
</ul>
<p>To complete this exercise will involve going through the final steps (5-7) in the process outlined above:</p>
<p><strong>Step 5</strong>. <em>Make a guess for the initial parameters</em>. We need initial parameters to put into “optim()”. Remember that the Ricker curve parameters can be estimated based on the initial slope and maximum (see pg. 95). Try plotting the curve over the points to get an approximate fit. There really isn’t any easier way to get there than trial and error for the deterministic function.</p>
<p><strong>Step 6</strong>. <em>Estimate the best fit parameters using maximum likelihood</em>.<br />
Now use ‘optim()’ to get your maximum likelihood parameter estimates.</p>
<p><strong>Step 7</strong>. <em>Add confidence/prediction intervals around your estimates</em>.<br />
After your run of ‘optim()’ (did you achieve convergence?), plot your fitted Ricker curve to your data. Revisit the earlier prediction interval code to add <em>plug-in</em> prediction intervals around your predicted curve based on gamma distributed errors (should resemble Figure 6.5b on page 184 of text).</p>
<p>Use the “qgamma()” function to build your plug-in intervals!</p>
<pre class="r"><code>########
# Plug-in prediction intervals!

upper&lt;-qgamma(0.975,shape=?, scale=?)   # remember that the mean of the gamma distribution is shape*scale
lower&lt;-qgamma(0.025,shape=?, scale=?)</code></pre>
<p>Include your function in your submitted r script!</p>
<p>You can use this “sandbox” (below) to develop and test your function!</p>
<div class="tutorial-exercise" data-label="q3_3b" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>MyxRicker &lt;- function(params,data){
    # [add code here!]
}
#MyxRicker(params=c(a=1,b=0.1,shape=30),data=myxdat[,-1])</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>And as always, make sure to test your function code using something like this:</p>
<pre class="r"><code>MyxRicker(params=c(a=2,b=0.2,shape=30),data=myxdat[,-1])   # test the function</code></pre>
<p><img src="LAB3_files/figure-html/testq3_3b-1.png" width="624" /></p>
<pre><code>##          a          b      shape 
##  3.5611591  0.1713262 90.5287907</code></pre>
</div>
<div id="section-exercise-3.4-2-dimensional-likelihood-surface" class="section level2">
<h2>Exercise 3.4: 2-dimensional likelihood surface</h2>
<p>Making “plug-in” confidence intervals looks nice on the plot (and is a useful, quick-and-dirty way to assess goodness-of-fit), but if we also want to visualize parameter uncertainty (and not just uncertainty arising from the randomness of the stochastic or residual error component) we need to consider other plausible parameter values from our <em>n</em>-dimensional likelihood surface (with as many dimensions as there are free parameters).</p>
</div>
<div id="section-exercise-3.4a." class="section level2">
<h2><strong>Exercise 3.4a</strong>.</h2>
<p>Make a function called “MyxRicker_ci()” that takes any two parameters from your myxomatosis model as inputs (holding any remaining parameters constant) and visualizes how the likelihood changes across this 2-dimensional parameter space. What we’ll end up with will look something like Figure 6.7 in the Bolker book.</p>
<p>NOTE: my testing code will only test your function with the parameters “a” and “b”, so you can hard-code your function with these parameters as the ones defining your 2-D parameter space (holding the ‘shape’ parameter constant)</p>
<ul>
<li><strong>input</strong>:
<ul>
<li>LikFunc = a likelihood function for the Myxomatosis data (use the function you developed for Exercise 3a [NLL_myxRicker()])</li>
<li>params = vector of initial values for the params to estimate (length 3: <em>a</em> and <em>b</em> params from the Ricker model [see below], and the “shape” parameter of the Gamma distribution)</li>
<li>params_selected = character vector of length 2 (character strings) indicating which two parameters to visualize (holding the other one constant) (the vector should contain two of the following text strings: “a”, “b”, and “shape”) (note that my testing code will set this argument as c(“a”,“b”))<br />
</li>
<li>data = a matrix of 2 columns and one row per observation. The first column should represent the days since infection, and the second column should represent the virus titer.</li>
<li>param1_lims = a vector of length 2 specifying the lower and upper bounds of the first parameter specified in “params_selected” (range over which you want to evaluate the likelihood)</li>
<li>param2_lims = a vector of length 2 specifying the lower and upper bounds of the second parameter specified in “params_selected” (range over which you want to evaluate the likelihood)</li>
</ul></li>
<li><strong>suggested algorithm</strong>:
<ul>
<li>Compute the MLE for the <em>a</em>, <em>b</em>, and <em>shape</em> parameters for the Ricker/Gamma model (use “optim()” with the likelhood function and the initial values in “params”)<br />
</li>
<li>Set the “constant/fixed” variable (the one not in “params_selected”) to its maximum likelihood estimate (which you just computed).<br />
</li>
<li>For each of the two parameters in “parameters_selected”, develop a vector of length 50 that ranges from the lower to the upper bound.</li>
<li>Loop over the two dimensions specified in “params_selected” (e.g., using a nested ‘for’ loop, iterating through both vectors computed in the previous step), characterizing all of parameter space from the lower to upper bounds of both parameters. For each “chunk/pixel” of parameter space, compute and store the likelihood (holding the third parameter at its MLE).<br />
</li>
<li>Use the “image()” function to visualize 2D parameter space, using “topo.colors” to define the colors.<br />
</li>
<li>Use the “contour()” function to draw contour lines at 2, 4, 6, 8, and 10 log-likelihood units from the MLE point.</li>
<li>For each parameter in “params_selected”, compute the approximate 95% “profile likelihood”, using the “rule of 2”. For each parameter, loop across possible parameter values and store the maximum log-likelihood value across all possible values of the other parameter. Record the range of parameter values that fall within approximately 2 log-likelihood units of the maximum log-likelihood value.</li>
</ul></li>
<li><strong>return</strong>:
<ul>
<li>a data frame with two columns (for each parameter in “params_selected”) and two rows (representing the lower bound and the upper bound of the approximate 95% profile likelihood interval for each parameter (respectively).</li>
</ul></li>
</ul>
<p>Include your function in your submitted r script!</p>
<p>You can use this “sandbox” (below) to develop and test your function!</p>
<div class="tutorial-exercise" data-label="q3_4a" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>MyxRicker_ci &lt;- function(LikFunc,params,params_selected,data,param1_lims,param2_lims){
    # [add code here!]
}
# MyxRicker_ci(LikFunc = NLL_myxRicker, params=c(a=1,b=0.3,shape=50), params_selected = c(&quot;a&quot;,&quot;b&quot;), 
#                                  data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5))</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Try testing your code- something like this:</p>
<pre class="r"><code>#  test: Ricker params &quot;a&quot; and &quot;b&quot;   [make sure this one works]
testab &lt;- MyxRicker_ci(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c(&quot;a&quot;,&quot;b&quot;), data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5))</code></pre>
<p><img src="LAB3_files/figure-html/testq3_4a-1.png" width="624" /></p>
<pre class="r"><code># test: Ricker param &quot;a&quot; and gamma &quot;shape&quot;  [if this works, you fully implemented the suggested algorithm!]
testas &lt;- MyxRicker_ci(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c(&quot;a&quot;,&quot;shape&quot;), data=myxdat[,-1], param1_lims= c(1,8),param2_lims=c(10,150))</code></pre>
<p><img src="LAB3_files/figure-html/testq3_4a-2.png" width="624" /></p>
<p>And here is the output from the functions (approximate profile likelihood confidence intervals):</p>
<pre class="r"><code>testab</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["var1"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["var2"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"3.246465","2":"0.1535354"},{"1":"3.875758","2":"0.1881818"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>testas</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["var1"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["var2"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"3.474747","2":"51.0101"},{"1":"3.686869","2":"147.1717"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="section-optional-exercise-5-profile-likelihood-using-optim" class="section level2">
<h2>Optional exercise 5: profile likelihood using “optim()”</h2>
<p>Construct <em>profile likelihood</em> confidence intervals for any one selected parameter using repeated calls to the “optim()” function. You will need to modify your likelihood functions and “optim()” commands to estimate only the parameters <em>other than</em> the one you are trying to get a CI for (because you’ll be fixing that parameter at many values on either side of the MLE).</p>
<p>–End of lab 3–</p>

<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
library(gradethis)
library(dplyr)
tutorial_options(
  exercise.reveal_solution = FALSE
)
gradethis_setup(
  pass.praise = TRUE,
  fail.encourage = TRUE,
  fail.hint = TRUE
)
knitr::opts_chunk$set(echo = TRUE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_setup_chunk("__setup__", c("library(learnr)", "library(gradethis)", "library(dplyr)", 
"tutorial_options(", "  exercise.reveal_solution = FALSE", ")", 
"gradethis_setup(", "  pass.praise = TRUE,", "  fail.encourage = TRUE,", 
"  fail.hint = TRUE", ")", "knitr::opts_chunk$set(echo = TRUE)"
), overwrite = FALSE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_setup_chunk("__setup__", c("library(learnr)", "library(gradethis)", "library(dplyr)", 
"tutorial_options(", "  exercise.reveal_solution = FALSE", ")", 
"gradethis_setup(", "  pass.praise = TRUE,", "  fail.encourage = TRUE,", 
"  fail.hint = TRUE", ")", "knitr::opts_chunk$set(echo = TRUE)"
), overwrite = FALSE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_setup_chunk("__setup__", c("library(learnr)", "library(gradethis)", "library(dplyr)", 
"tutorial_options(", "  exercise.reveal_solution = FALSE", ")", 
"gradethis_setup(", "  pass.praise = TRUE,", "  fail.encourage = TRUE,", 
"  fail.hint = TRUE", ")", "knitr::opts_chunk$set(echo = TRUE)"
), overwrite = FALSE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-q3_1a-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-q3_1a-code-editor`)), session)
output$`tutorial-exercise-q3_1a-output` <- renderUI({
  `tutorial-exercise-q3_1a-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache("q3_1a", list(setup = NULL, chunks = list(list(label = "q3_1a", code = "NLL_frogOccupancy <- function(params,data,N){\n    # [add code here!]\n}\n#NLL_frogOccupancy(params=0.5,data=c(3,2,6),N=10)\n", 
    opts = list(label = "\"q3_1a\"", exercise = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure(c("", 
    "grade_this({", "  fail_if(!length(.result(params=0.25,data=c(3,1,3,4),N=10))==1, \"your function output should be a single number\")", 
    "  pass_if(near(.result(params=0.25,data=c(3,1,3,4),N=10),", 
    "              .solution(params=0.25,data=c(3,1,3,4),N=10),0.0000001))", 
    "  fail()", "})", "", ""), chunk_opts = list(label = "q3_1a-check", 
        echo = F)), solution = structure(c("", "#########", "# Exercise 3.1a", 
    "", "NLL_frogOccupancy <- function(params=0.5,data=c(3,2,6),N=10){", 
    "  -sum(dbinom(data,prob=params,size = N,log=T))", "}", ""
    ), chunk_opts = list(label = "q3_1a-solution", echo = FALSE, 
        context = "data")), options = list(eval = FALSE, echo = TRUE, 
        results = "markup", tidy = FALSE, tidy.opts = NULL, collapse = FALSE, 
        prompt = FALSE, comment = NA, highlight = FALSE, strip.white = TRUE, 
        size = "normalsize", background = "#F7F7F7", cache = 0, 
        cache.path = "LAB3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "LAB3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6.5, fig.height = 4, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 624, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, tutorial = TRUE, 
        exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = FALSE, label = "q3_1a", exercise = TRUE, 
        code = c("NLL_frogOccupancy <- function(params,data,N){", 
        "    # [add code here!]", "}", "#NLL_frogOccupancy(params=0.5,data=c(3,2,6),N=10)", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "q3_1a, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r"))
</script>
 
<script type="application/shiny-prerendered" data-context="data">

NLL_frogOccupancy <- function(params=0.5,data=c(3,2,6),N=10){
  -sum(dbinom(data,prob=params,size = N,log=T))
}

</script>
 
<script type="application/shiny-prerendered" data-context="data">

#####
# 3.2a

#rffr <- read.csv("ReedfrogFuncResp.csv",row.names = 1)
  # alternative: 
rffr <- emdbook::ReedfrogFuncresp     # from Bolker's "emdbook" package
  # ?Reedfrog      # learn more about this dataset
head(rffr)

</script>
 
<script type="application/shiny-prerendered" data-context="data">

#########
# define a Holling type II functional response, with an initial guess about parameter values

Holl2<-function(x, a, h){(a*x)/(1+(a*h*x))}
plot(rffr$Killed~rffr$Initial)
curve(Holl2(x, a=0.5, h=1/80), add=TRUE,col="red")

</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-q3_2a-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-q3_2a-code-editor`)), session)
output$`tutorial-exercise-q3_2a-output` <- renderUI({
  `tutorial-exercise-q3_2a-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache("q3_2a", list(setup = NULL, chunks = list(list(label = "q3_2a", code = "binomNLL2 <- function(params,N,k){\n    # [add code here!]\n}\n# binomNLL2(c(a=0.4,h=1/200),c(5,10,15),c(3,5,6))\n", 
    opts = list(label = "\"q3_2a\"", exercise = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure(c("", 
    "grade_this({", "  fail_if(!length(.result(params=c(0.25,0.01),N=c(5,10,15,20),k=c(4,5,8,9)))==1, \"your function output should be a single number\")", 
    "  pass_if(near(.result(params=c(0.25,0.01),N=c(5,10,15,20),k=c(4,5,8,9)),", 
    "              .solution(params=c(0.25,0.01),N=c(5,10,15,20),k=c(4,5,8,9)),0.0000001))", 
    "  fail()", "})", "", ""), chunk_opts = list(label = "q3_2a-check", 
        echo = F)), solution = structure(c("", "###########", 
    "# Write a likelihood function", "", "#    params: vector of params to estimate (a and h from the Holling type II functional response)", 
    "#    k: number killed per trial   (data)", "#    N: number of tadpoles per trial (data)", 
    "", "binomNLL2<-function(params,N,k){", "\ta=params[1]", 
    "\th=params[2]", "\tpredprob=a/(1+a*h*N)\t", "\t-sum(dbinom(k,prob=predprob,size=N,log=TRUE))", 
    "}", ""), chunk_opts = list(label = "q3_2a-solution", echo = FALSE, 
        context = "data")), options = list(eval = FALSE, echo = TRUE, 
        results = "markup", tidy = FALSE, tidy.opts = NULL, collapse = FALSE, 
        prompt = FALSE, comment = NA, highlight = FALSE, strip.white = TRUE, 
        size = "normalsize", background = "#F7F7F7", cache = 0, 
        cache.path = "LAB3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "LAB3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6.5, fig.height = 4, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 624, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, tutorial = TRUE, 
        exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = FALSE, label = "q3_2a", exercise = TRUE, 
        code = c("binomNLL2 <- function(params,N,k){", "    # [add code here!]", 
        "}", "# binomNLL2(c(a=0.4,h=1/200),c(5,10,15),c(3,5,6))", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "q3_2a, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r"))
</script>
 
<script type="application/shiny-prerendered" data-context="data">

binomNLL2<-function(params,N,k){
	a=params[1]
	h=params[2]
	predprob=a/(1+a*h*N)	
	-sum(dbinom(k,prob=predprob,size=N,log=TRUE))
}

</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-q3_2b-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-q3_2b-code-editor`)), session)
output$`tutorial-exercise-q3_2b-output` <- renderUI({
  `tutorial-exercise-q3_2b-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache("q3_2b", list(setup = NULL, chunks = list(list(label = "q3_2b", code = "Rffuncresp <- function(params,data){\n    # [add code here!]\n}\n#Rffuncresp(params=c(a=0.5,h=(1/30)),data=rffr)\n", 
    opts = list(label = "\"q3_2b\"", exercise = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure(c("", 
    "grade_this({", "  fail_if(!length(.result(params=inits,data=rffr))==2, \"your function output should be a named vector with two elements\")", 
    "  fail_if(!names(.result(params=inits,data=rffr))==c(\"a\",\"h\"), \"your function output should be a named vector with two elements\")", 
    "  pass_if(near(.result(params=inits,data=rffr[-4,]),", "              .solution(params=inits,data=rffr[-4,]),0.0000001))", 
    "  fail()", "})", "", ""), chunk_opts = list(label = "q3_2b-check", 
        echo = F)), solution = structure(c("", "quantilefunc <- function(x,pars,q){    # helper function for plotting quantiles", 
    "  ifelse(x>0.5,", "    qbinom(q,prob=Holl2(round(x),pars[\"a\"],pars[\"h\"])/round(x),size=round(x)),", 
    "    0", "  )", "}", "", "inits <- c(a=0.6,h=(1/60))", "Rffuncresp <- function(params=inits,data=rffr){", 
    "  temp <- suppressWarnings( optim(fn=binomNLL2,  par=inits, N=data[,1], k=data[,2])   )", 
    "  MLE <- temp$par", "  plot(data[,2]~data[,1],ylab=\"Killed\",xlab=\"Init Density\")", 
    "  #curve(Holl2(x,inits[\"a\"],inits[\"h\"]),add=T,col=\"red\")  # overlay initial values?", 
    "  curve(Holl2(x,MLE[\"a\"],MLE[\"h\"]),add=T,col=\"green\",lwd=2)", 
    "  curve(quantilefunc(x,pars=MLE,0.975),add=T,col=\"green\",lty=2)", 
    "  curve(quantilefunc(x,pars=MLE,0.025),add=T,col=\"green\",lty=2)", 
    "  return(MLE)", "}", ""), chunk_opts = list(label = "q3_2b-solution", 
        echo = FALSE)), options = list(eval = FALSE, echo = TRUE, 
        results = "markup", tidy = FALSE, tidy.opts = NULL, collapse = FALSE, 
        prompt = FALSE, comment = NA, highlight = FALSE, strip.white = TRUE, 
        size = "normalsize", background = "#F7F7F7", cache = 0, 
        cache.path = "LAB3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "LAB3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6.5, fig.height = 4, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 624, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, tutorial = TRUE, 
        exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = FALSE, label = "q3_2b", exercise = TRUE, 
        code = c("Rffuncresp <- function(params,data){", "    # [add code here!]", 
        "}", "#Rffuncresp(params=c(a=0.5,h=(1/30)),data=rffr)", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "q3_2b, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r"))
</script>
 
<script type="application/shiny-prerendered" data-context="data">

quantilefunc <- function(x,pars,q){    # helper function for plotting quantiles
  ifelse(x>0.5,
    qbinom(q,prob=Holl2(round(x),pars["a"],pars["h"])/round(x),size=round(x)),
    0
  )
}

inits <- c(a=0.6,h=(1/60))
Rffuncresp <- function(params=inits,data=rffr){
  temp <- suppressWarnings( optim(fn=binomNLL2,  par=inits, N=data[,1], k=data[,2])   )
  MLE <- temp$par
  plot(data[,2]~data[,1],ylab="Killed",xlab="Init Density")
  #curve(Holl2(x,inits["a"],inits["h"]),add=T,col="red")    # overlay initial values?
  curve(Holl2(x,MLE["a"],MLE["h"]),add=T,col="green",lwd=2)
  curve(quantilefunc(x,pars=MLE,0.975),add=T,col="green",lty=2)
  curve(quantilefunc(x,pars=MLE,0.025),add=T,col="green",lty=2)
  return(MLE)
}

</script>
 
<script type="application/shiny-prerendered" data-context="data">

#######
# Exercise 3.3a

########
# Myxomatosis data

library(emdbook)
data(MyxoTiter_sum)      # load the data
head(MyxoTiter_sum)   

</script>
 
<script type="application/shiny-prerendered" data-context="data">

myxdat <- subset(MyxoTiter_sum, grade==1)    # select just the least virulent strain

plot(myxdat$titer~myxdat$day,xlim=c(0,10))    # visualize the relationship

</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-q3_3a-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-q3_3a-code-editor`)), session)
output$`tutorial-exercise-q3_3a-output` <- renderUI({
  `tutorial-exercise-q3_3a-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache("q3_3a", list(setup = NULL, chunks = list(list(label = "q3_3a", code = "NLL_myxRicker <- function(params,data){\n    # [add code here!]\n}\n#NLL_myxRicker(params=c(a=2,b=0.1,shape=80),data=myxdat[,-1])\n", 
    opts = list(label = "\"q3_3a\"", exercise = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure(c("", 
    "grade_this({", "  fail_if(!length(.result(params=c(a=4,b=0.2,shape=40),data=myxdat[,-1]))==1, \"your function output should be a single number\")", 
    "  pass_if(near(.result(params=c(a=4,b=0.3,shape=41),data=myxdat[,-1]),", 
    "              .solution(params=c(a=4,b=0.3,shape=41),data=myxdat[,-1]),0.0000001))", 
    "  fail()", "})", "", ""), chunk_opts = list(label = "q3_3a-check", 
        echo = F)), solution = structure(c("", "", "Ricker <- function(x,a,b){", 
    "  a*x*exp(-b*x)", "}", "", "NLL_myxRicker <- function(params=c(a=1,b=0.2,shape=1),data=myxdat[,-1]){", 
    "  exp_titer <- Ricker(data[,1],params[\"a\"],params[\"b\"])", 
    "  scale <- exp_titer/params[\"shape\"]", "  -sum(dgamma(data[,2],shape=params[\"shape\"],scale=scale,log=TRUE))", 
    "}", ""), chunk_opts = list(label = "q3_3a-solution", echo = FALSE, 
        context = "data")), options = list(eval = FALSE, echo = TRUE, 
        results = "markup", tidy = FALSE, tidy.opts = NULL, collapse = FALSE, 
        prompt = FALSE, comment = NA, highlight = FALSE, strip.white = TRUE, 
        size = "normalsize", background = "#F7F7F7", cache = 0, 
        cache.path = "LAB3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "LAB3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6.5, fig.height = 4, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 624, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, tutorial = TRUE, 
        exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = FALSE, label = "q3_3a", exercise = TRUE, 
        code = c("NLL_myxRicker <- function(params,data){", "    # [add code here!]", 
        "}", "#NLL_myxRicker(params=c(a=2,b=0.1,shape=80),data=myxdat[,-1])", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "q3_3a, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r"))
</script>
 
<script type="application/shiny-prerendered" data-context="data">


Ricker <- function(x,a,b){
  a*x*exp(-b*x)
}

NLL_myxRicker <- function(params=c(a=1,b=0.2,shape=1),data=myxdat[,-1]){
  exp_titer <- Ricker(data[,1],params["a"],params["b"])
  scale <- exp_titer/params["shape"]
  -sum(dgamma(data[,2],shape=params["shape"],scale=scale,log=TRUE))
}

</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-q3_3b-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-q3_3b-code-editor`)), session)
output$`tutorial-exercise-q3_3b-output` <- renderUI({
  `tutorial-exercise-q3_3b-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache("q3_3b", list(setup = NULL, chunks = list(list(label = "q3_3b", code = "MyxRicker <- function(params,data){\n    # [add code here!]\n}\n#MyxRicker(params=c(a=1,b=0.1,shape=30),data=myxdat[,-1])\n", 
    opts = list(label = "\"q3_3b\"", exercise = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure(c("", 
    "grade_this({", "  fail_if(!length(.result(params=c(a=2,b=0.2,shape=30),data=myxdat[-5,-1]))==3, \"your function output should be a named vector with three elements\")", 
    "  fail_if(!names(.result(params=c(a=2,b=0.2,shape=30),data=myxdat[-5,-1]))==c(\"a\",\"b\",\"shape\"), \"your function output should be a named vector with three elements\")", 
    "  pass_if(near(.result(params=c(a=2,b=0.22,shape=31),data=myxdat[-5,-1]),", 
    "              .solution(params=c(a=2,b=0.22,shape=31),data=myxdat[-5,-1]),0.0000001))", 
    "  fail()", "})", "", ""), chunk_opts = list(label = "q3_3b-check", 
        echo = F)), solution = structure(c("", "##########", 
    "# 3.3b", "", "MyxRicker <- function(params=c(a=2,b=0.2,shape=30),data=myxdat[,-1]){", 
    "  temp <- optim(NLL_myxRicker,par = params,data=data)", 
    "  MLE <- temp$par", "  plot(data[,2]~data[,1],xlab=\"days\",ylab=\"titer\",xlim=c(0,10),ylim=c(0,10))", 
    "  curve(Ricker(x,MLE[\"a\"],MLE[\"b\"]),add=T,col=\"green\",lwd=2)", 
    "  curve(qgamma(0.975,shape=MLE[\"shape\"],scale=Ricker(x,MLE[\"a\"],MLE[\"b\"])/MLE[\"shape\"]),0.01,10,add=T,col=\"green\",lty=2)", 
    "  curve(qgamma(0.025,shape=MLE[\"shape\"],scale=Ricker(x,MLE[\"a\"],MLE[\"b\"])/MLE[\"shape\"]),0.01,10,add=T,col=\"green\",lty=2)", 
    "  return(MLE)", "}", ""), chunk_opts = list(label = "q3_3b-solution", 
        echo = FALSE, context = "data")), options = list(eval = FALSE, 
        echo = TRUE, results = "markup", tidy = FALSE, tidy.opts = NULL, 
        collapse = FALSE, prompt = FALSE, comment = NA, highlight = FALSE, 
        strip.white = TRUE, size = "normalsize", background = "#F7F7F7", 
        cache = 0, cache.path = "LAB3_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "LAB3_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, tutorial = TRUE, exercise.timelimit = 60, 
        exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = FALSE, label = "q3_3b", exercise = TRUE, 
        code = c("MyxRicker <- function(params,data){", "    # [add code here!]", 
        "}", "#MyxRicker(params=c(a=1,b=0.1,shape=30),data=myxdat[,-1])", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "q3_3b, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r"))
</script>
 
<script type="application/shiny-prerendered" data-context="data">

MyxRicker <- function(params=c(a=2,b=0.2,shape=30),data=myxdat[,-1]){
  temp <- optim(NLL_myxRicker,par = params,data=data)
  MLE <- temp$par
  plot(data[,2]~data[,1],xlab="days",ylab="titer",xlim=c(0,10),ylim=c(0,10))
  curve(Ricker(x,MLE["a"],MLE["b"]),add=T,col="green",lwd=2)
  curve(qgamma(0.975,shape=MLE["shape"],scale=Ricker(x,MLE["a"],MLE["b"])/MLE["shape"]),0.01,10,add=T,col="green",lty=2)
  curve(qgamma(0.025,shape=MLE["shape"],scale=Ricker(x,MLE["a"],MLE["b"])/MLE["shape"]),0.01,10,add=T,col="green",lty=2)
  return(MLE)
}

</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-q3_4a-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-q3_4a-code-editor`)), session)
output$`tutorial-exercise-q3_4a-output` <- renderUI({
  `tutorial-exercise-q3_4a-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache("q3_4a", list(setup = NULL, chunks = list(list(label = "q3_4a", code = "MyxRicker_ci <- function(LikFunc,params,params_selected,data,param1_lims,param2_lims){\n    # [add code here!]\n}\n# MyxRicker_ci(LikFunc = NLL_myxRicker, params=c(a=1,b=0.3,shape=50), params_selected = c(\"a\",\"b\"), \n#                                  data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5))\n", 
    opts = list(label = "\"q3_4a\"", exercise = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure(c("", 
    "grade_this({", "  fail_if(!dim(.result(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c(\"a\",\"b\"), data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5)))==c(2,2), \"your function output should be a data frame with two rows and two columns\")", 
    "  pass_if(near(.result(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c(\"a\",\"b\"), data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5)),", 
    "              .solution(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c(\"a\",\"b\"), data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5)),0.1))", 
    "  fail()", "})"), chunk_opts = list(label = "q3_4a-check", 
        echo = F)), solution = structure(c("", "###############", 
    "# exercise 3.4", "", "MyxRicker_ci <- function(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c(\"a\",\"b\"), data=myxdat[,-1], param1_lims= c(0.1,10),param2_lims=c(0.01,1)){", 
    "  temp <- optim(LikFunc,par = params,data=data)", "  MLE <- temp$par", 
    "  ML <- temp$value", "  notselected <- setdiff(names(MLE),params_selected)", 
    "  notselected_ndx <- which(names(MLE)==notselected)", "  param_ndx <- match(params_selected,names(MLE))", 
    "  ", "  var1 <- seq(param1_lims[1],param1_lims[2],length=100)", 
    "  var2 <- seq(param2_lims[1],param2_lims[2],length=100)", 
    "  ", "  pars <- params", "  pars[notselected_ndx] <- MLE[notselected]", 
    "  likarr <- matrix(NA,nrow=length(var1),ncol=length(var2))", 
    "  v1=1;v2=1", "  for(v1 in 1:length(var1)){", "    pars[param_ndx[1]] <- var1[v1]", 
    "    for(v2 in 1:length(var2)){", "      pars[param_ndx[2]] <- var2[v2]", 
    "      likarr[v1,v2] <- -NLL_myxRicker(params=pars,data=data)", 
    "    }", "  }", "  ", "  image(x=var1,y=var2,z=likarr,zlim=c(-130,-29),col=topo.colors(12))", 
    "  contour(x=var1,y=var2,z=likarr,levels=(-ML-c(2,4,6,8,10)),add=TRUE,lwd=1,col=gray(0.3))", 
    "  ", "  ci1 <- range(var1[apply(likarr,1,max)>(-ML-2)])", 
    "  ci2 <- range(var2[apply(likarr,2,max)>(-ML-2)])", "  ", 
    "  out<- data.frame(var1 = ci1,var2=ci2)", "  return(out)", 
    "}", ""), chunk_opts = list(label = "q3_4a-solution", echo = FALSE, 
        context = "data")), options = list(eval = FALSE, echo = TRUE, 
        results = "markup", tidy = FALSE, tidy.opts = NULL, collapse = FALSE, 
        prompt = FALSE, comment = NA, highlight = FALSE, strip.white = TRUE, 
        size = "normalsize", background = "#F7F7F7", cache = 0, 
        cache.path = "LAB3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "LAB3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6.5, fig.height = 4, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 624, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, tutorial = TRUE, 
        exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = FALSE, label = "q3_4a", exercise = TRUE, 
        code = c("MyxRicker_ci <- function(LikFunc,params,params_selected,data,param1_lims,param2_lims){", 
        "    # [add code here!]", "}", "# MyxRicker_ci(LikFunc = NLL_myxRicker, params=c(a=1,b=0.3,shape=50), params_selected = c(\"a\",\"b\"), ", 
        "#                                  data=myxdat[,-1], param1_lims= c(0.1,9),param2_lims=c(0.01,0.5))", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "q3_4a, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r"))
</script>
 
<script type="application/shiny-prerendered" data-context="data">

###############
# exercise 3.4

MyxRicker_ci <- function(LikFunc = NLL_myxRicker, params=c(a=2,b=0.2,shape=30), params_selected = c("a","b"), data=myxdat[,-1], param1_lims= c(0.1,10),param2_lims=c(0.01,1)){
  temp <- optim(LikFunc,par = params,data=data)
  MLE <- temp$par
  ML <- temp$value
  notselected <- setdiff(names(MLE),params_selected)
  notselected_ndx <- which(names(MLE)==notselected)
  param_ndx <- match(params_selected,names(MLE))
  
  var1 <- seq(param1_lims[1],param1_lims[2],length=100)
  var2 <- seq(param2_lims[1],param2_lims[2],length=100)
  
  pars <- params
  pars[notselected_ndx] <- MLE[notselected]
  likarr <- matrix(NA,nrow=length(var1),ncol=length(var2))
  v1=1;v2=1
  for(v1 in 1:length(var1)){
    pars[param_ndx[1]] <- var1[v1]
    for(v2 in 1:length(var2)){
      pars[param_ndx[2]] <- var2[v2]
      likarr[v1,v2] <- -NLL_myxRicker(params=pars,data=data)
    }
  }
  
  image(x=var1,y=var2,z=likarr,zlim=c(-130,-29),col=topo.colors(12))
  contour(x=var1,y=var2,z=likarr,levels=(-ML-c(2,4,6,8,10)),add=TRUE,lwd=1,col=gray(0.3))
  
  ci1 <- range(var1[apply(likarr,1,max)>(-ML-2)])
  ci2 <- range(var2[apply(likarr,2,max)>(-ML-2)])
  
  out<- data.frame(var1 = ci1,var2=ci2)
  return(out)
}

</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["1.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalistirma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"Ipuçlari\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki Ipucu\",\"hintprev\":\"Önceki Ipucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Bastan Baslamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabi onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Bastan Baslamak\",\"areyousure\":\"Bastan baslamak istediginizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalisin\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sinav\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"<U+0001F3C3>\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"<U+0001F4A1>\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"<U+0001F3AF>\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"<U+0001F4CB>\",\"startover\":\"<U+23EE>\",\"startovertitle\":\"Start Over\",\"continue\":\"<U+2705>\",\"submitanswer\":\"<U+0001F197>\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"<U+2B05>\",\"nexttopic\":\"<U+27A1>\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"<U+0001F501>\"},\"text\":{\"startover\":\"<U+23EE>\",\"areyousure\":\"<U+0001F914>\",\"youmustcomplete\":\"<U+26A0><U+FE0F> <U+0001F449> <U+0001F9D1><U+200D><U+0001F4BB>\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"<U+0001F4BB>\",\"enginecap\":\"$t(text.code) {{engine}}\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.10"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["4.4.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.10.1.9011"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.1.9011"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]}},"value":[{"type":"character","attributes":{},"value":["assertthat","backports","base","bbmle","bdsmatrix","bslib","checkmate","coda","compiler","crayon","curl","datasets","DBI","digest","dplyr","ellipsis","emdbook","evaluate","fansi","fastmap","generics","glue","gradethis","graphics","grDevices","grid","highr","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","lattice","learnr","lifecycle","magrittr","markdown","MASS","Matrix","methods","mime","mvtnorm","numDeriv","pillar","pkgconfig","plyr","promises","purrr","R6","Rcpp","rlang","rmarkdown","rprojroot","sass","shiny","stats","stats4","stringi","stringr","tibble","tidyselect","tools","utf8","utils","vctrs","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["0.2.1","1.2.1","4.1.0","1.0.24","1.3-4","0.2.5.1","2.0.0","0.19-4","4.1.0","1.4.1","4.3.2","4.1.0","1.1.1","0.6.27","1.0.7","0.3.2","1.3.12","0.14","0.5.0","1.1.0","0.1.0","1.4.2","0.2.3.9001","4.1.0","4.1.0","4.1.0","0.9","0.5.1.1","1.5.3","1.6.2","0.1.4","1.7.2","1.33","1.3.0","0.20-44","0.10.1.9011","1.0.0","2.0.1","1.1","7.3-54","1.3-3","4.1.0","0.11","1.1-2","2016.8-1.1","1.6.2","2.0.3","1.8.6","1.2.0.1","0.3.4","2.5.1","1.0.7","0.4.11","2.10","2.0.2","0.4.0","1.6.0","4.1.0","4.1.0","1.7.3","1.4.0","3.1.3","1.1.1","4.1.0","1.2.2","4.1.0","0.3.8","2.4.2","0.25","1.8-4","2.2.1"]}]}]}
</script>
<!--/html_preserve-->
</div>

</div> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h2 class="title toc-ignore" style="display:none;">Lab 3</h2>
<h4 class="author"><em>NRES 746</em></h4>
<h4 class="date"><em>Fall 2021</em></h4>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</div> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>
