<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="NRES 746" />

<meta name="date" content="2016-10-26" />

<title>Lab Exercise 5 (optional)</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/default.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.9em;
  padding-left: 5px;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">NRES 746</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Schedule
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="schedule.html">Course Schedule</a>
    </li>
    <li>
      <a href="labschedule.html">Lab Schedule</a>
    </li>
    <li>
      <a href="Syllabus.pdf">Syllabus</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="INTRO.html">Introduction to NRES 746</a>
    </li>
    <li>
      <a href="LECTURE1.html">Why focus on algorithms?</a>
    </li>
    <li>
      <a href="LECTURE2.html">Working with probabilities</a>
    </li>
    <li>
      <a href="LECTURE3.html">The Virtual Ecologist</a>
    </li>
    <li>
      <a href="LECTURE4.html">Likelihood</a>
    </li>
    <li>
      <a href="LECTURE5.html">Optimization</a>
    </li>
    <li>
      <a href="LECTURE6.html">Bayesian #1: concepts</a>
    </li>
    <li>
      <a href="LECTURE7.html">Bayesian #2: mcmc</a>
    </li>
    <li>
      <a href="LECTURE8.html">Model Selection</a>
    </li>
    <li>
      <a href="LECTURE9.html">Model Performance Evaluation</a>
    </li>
    <li>
      <a href="LECTURE10.html">Machine Learning</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lab exercises
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="LAB1.html">Lab 1: Algorithms in R</a>
    </li>
    <li>
      <a href="LAB2.html">Lab 2: Virtual ecologist</a>
    </li>
    <li>
      <a href="LAB3.html">Lab 3: Likelihood and optimization</a>
    </li>
    <li>
      <a href="LAB4.html">Lab 4: Bayesian inference</a>
    </li>
    <li>
      <a href="LAB5.html">Lab 5: Model selection</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data sets
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TreeData.csv">Tree Data</a>
    </li>
    <li>
      <a href="ReedfrogPred.csv">Reed Frog Predation Data</a>
    </li>
    <li>
      <a href="ReedfrogFuncresp.csv">Reed Frog Func Resp</a>
    </li>
    <li>
      <a href="uta_simulated_data.csv">Uta data</a>
    </li>
    <li>
      <a href="tide_ALL_navd_HH.csv">tide data?</a>
    </li>
    <li>
      <a href="TestDataset2.csv">Ordination minilab: testdataset2</a>
    </li>
    <li>
      <a href="TestHypotheses.csv">Ordination minilab: testhypotheses</a>
    </li>
    <li>
      <a href="PRISM_ppt_1895-2015Mo2.csv">PRISM data for time series lab</a>
    </li>
    <li>
      <a href="final_winter_modeldata2.csv">winter deer data for RSF lab</a>
    </li>
    <li>
      <a href="keeley_rawdata.csv">Keeley data</a>
    </li>
    <li>
      <a href="Nest_basic_ALL.csv">nest basic data</a>
    </li>
    <li>
      <a href="Cap_data_for SA minilab.csv">cap data for SA</a>
    </li>
    <li>
      <a href="JoTrPresence02202008_dryad.txt">Joshua tree data for SDM lab</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Student-led topics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="forWebsite_SEM.html">SEMs</a>
    </li>
    <li>
      <a href="SEM_Minilab_v2.html">SEM mini-lab</a>
    </li>
    <li>
      <a href="GAMs.html">GAMs</a>
    </li>
    <li>
      <a href="RMarkdown_FigureDemo.html">Publication-quality figures in R</a>
    </li>
    <li>
      <a href="Bayesian Networks.pptx">Bayesian Networks</a>
    </li>
    <li>
      <a href="Bayes_Network_Markdown_Final.html">Bayesian Networks mini-lab</a>
    </li>
    <li>
      <a href="GraphTheory.html">Graph Theory</a>
    </li>
    <li>
      <a href="NRES746_IPMs.pptx">Integrated Population Models</a>
    </li>
    <li>
      <a href="TimeSeries_heckler.html">Time Series Analysis</a>
    </li>
    <li>
      <a href="Time_Series_Lab.html">Time-series mini-lab</a>
    </li>
    <li>
      <a href="Spatial_Autocorrelation.html">Spatial Autocorrelation</a>
    </li>
    <li>
      <a href="SA_minilab.html">Spatial Autocorrelation mini-lab</a>
    </li>
    <li>
      <a href="SDM_pres.html">Species Distribution Modeling</a>
    </li>
    <li>
      <a href="IPM_miniLab.html">IPM mini-lab</a>
    </li>
    <li>
      <a href="Final_MiniLabScript.html">RSF mini-lab</a>
    </li>
    <li>
      <a href="MixedModelMinilab.html">Mixed-effects model mini-lab</a>
    </li>
    <li>
      <a href="Minilab_Ordination.html">Ordination mini-lab</a>
    </li>
  </ul>
</li>
<li>
  <a href="Links.html">Links</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Lab Exercise 5 (optional)</h1>
<h4 class="author"><em>NRES 746</em></h4>
<h4 class="date"><em>October 26, 2016</em></h4>

</div>


<div id="model-selection" class="section level2">
<h2>Model selection!</h2>
<p>This exercise was modified from a lab by J. Weiss: see <a href="https://www.unc.edu/courses/2006spring/ecol/145/001/docs/lectures/lecture19.htm">here</a></p>
<div id="new-r-conceptscommands" class="section level3">
<h3>New R concepts/commands</h3>
<p><strong>ifelse</strong> tests each element of a vector with respect to a condition (first argument). If the condition tests TRUE the second argument is returned. If the condition tests FALSE, the third argument is returned. The result is a vector of the same length as the input vector.</p>
<p><strong>min</strong> returns the minimum value from a vector or matrix</p>
<p><strong>NULL</strong> is not a function but is a reserved word used to identify the value of an object of length zero</p>
<p><strong>round</strong> rounds its argument to the number of decimals specified.</p>
<p><strong>t</strong> is the transpose function. It switches the rows and columns of a matrix.</p>
<p><strong>angle=</strong> (argument to barplot) specifies the angle of the hatch marks in the bars of barplots.</p>
<p><strong>beside=</strong> (argument to barplot) when TRUE creates side-by-side bar plots rather than stacked bar plots</p>
<p><strong>density=</strong> (argument to barplot) controls the spacing of hatch marks in hatched bars</p>
<p><strong>legend.txt=</strong> (argument to barplot) when TRUE adds a legend to a bar plot when multiple groups are plotted</p>
</div>
<div id="the-crawley-slug-data-set" class="section level3">
<h3>The Crawley slug data set</h3>
<p>We use a data set that appears on Michael Crawley’s web site for his text Statistical Computing (Crawley 2002).</p>
<p>Get the data</p>
<pre class="r"><code>slugs&lt;-read.table( &#39;http://www.bio.ic.ac.uk/research/mjcraw/statcomp/data/slugsurvey.txt&#39;, header=TRUE)
head(slugs)</code></pre>
<pre><code>##   slugs   field
## 1     3 Nursery
## 2     0 Nursery
## 3     0 Nursery
## 4     0 Nursery
## 5     0 Nursery
## 6     1 Nursery</code></pre>
<p>Crawley describes these data as follows (Crawley 2002, p. 542).</p>
<blockquote>
<p>“Count data were obtained on the number of slugs found beneath 40 tiles placed in a stratified random grid over each of two permanent grasslands. This was part of a pilot study in which the question was simply whether the mean slug density differed significantly between the two grasslands.” My interpretation of this is that the experiment was extraordinarily simple. Rocks of standard shape and size were laid out in two fields and at some point later in time the fields were revisited and the number of slugs under each rock was recorded. The data we are given are the raw counts, i.e., the individual slug counts for each rock. Thus we have a total of 80 observations, 40 from each field type. A value of 0 means no slugs were found under that rock. Crawley then spends a chapter of his textbook trying one statistical test after another to test the hypothesis of no mean difference in slugs between the two field types. In the end his conclusion is ambiguous. Some tests say there is a difference, some say there isn’t. I submit that the problem posed by Crawley is essentially an uninteresting one. Any two populations in nature will typically differ with respect to whatever characteristic we care to measure. Whether that difference can be deemed statistically significant is not a statement about nature, but instead is a statement about the sample size used in the study. With enough data any difference, no matter how small, will achieve “statistical significance”. A far more useful approach is to determine some way to characterize the differences in slug distribution that exist and then assess whether that characterization tells us anything interesting about slugs and/or nature in general. Our goal in this exercise is find a statistical model that fits the data and provides insight into the distribution of slugs. I use this exercise as an illustration of how AIC can be used to select models.</p>
</blockquote>
<p>First we summarize the distribution of slugs under rocks in the two field types.</p>
<pre class="r"><code>table(slugs$slugs,slugs$field)</code></pre>
<pre><code>##     
##      Nursery Rookery
##   0       25       9
##   1        5       9
##   2        2       8
##   3        2       5
##   4        2       2
##   5        1       4
##   6        1       1
##   7        1       0
##   8        0       1
##   9        0       1
##   10       1       0</code></pre>
<p>A bar plot of the two distributions would be useful. We have a number of choices. If we apply the <em>barplot</em> function to the tabled values we get two stacked bar plots (Fig. 1).</p>
<pre class="r"><code>out &lt;- table(slugs$slugs,slugs$field)
barplot(out)</code></pre>
<p><img src="LAB5_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>On the other hand if we first transpose the table so that the field categories define the rows of our table, we can obtain an ordinary bar plot in which the bars representing counts in the two fields appear side by side and are inter-nested among each other.</p>
<pre class="r"><code>barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), col=c(&#39;black&#39;,&#39;red&#39;), legend.text=TRUE, xlab=&#39;# of slugs&#39;, ylab=&#39;frequency&#39;)</code></pre>
<p><img src="LAB5_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>The transpose function is t(). Setting the <em>beside</em> option to TRUE creates the side by side display. (The alternative would be a set of stacked bars.) I use the angle option to get bars filled with hatch marks rather than solid fill. The angles specified are the angles the hatch marks make with the horizontal. Since the transposed table has two rows I need a different angle for each row (field type). The <em>density</em> option controls how closely spaced the hatch marks are displayed. It also is a vector of length two. The <em>legend.text</em> option adds a legend that identifies the field type.</p>
<p>We can also customize the legend in the usual way as shown in the code below (resulting graph not shown). This is an alternative to using the legend.text=TRUE option.</p>
<pre class="r"><code>coords&lt;-barplot(t(out), beside=TRUE, angle=c(45,135), density=c(20,20), ylim=c(0,27), col=c(&#39;black&#39;,&#39;red&#39;), xlab=&#39;# of slugs&#39;, ylab=&#39;frequency&#39;)
box()
legend(coords[1,8], 26, c(&#39;nursery&#39;,&#39;rookery&#39;), density=c(20,20), angle=c(45,135), fill=c(&#39;black&#39;,&#39;red&#39;), cex=c(.8,.8),bty=&#39;n&#39;)</code></pre>
<pre><code>## Warning in if (xc &lt; 0) text.width &lt;- -text.width: the condition has length
## &gt; 1 and only the first element will be used</code></pre>
<p><img src="LAB5_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Based on the bar charts the distributions look quite different. Observe the large fraction of zeros seen among the nursery slugs. We might be able to generate distributions that resemble these two by varying the dispersion parameter in a negative binomial distribution (while holding the mean fixed).</p>
<p>In considering what probability model might be appropriate for these data, I view any of the following as possible candidates. (Separate and common refer to the two field types.)</p>
<div id="poisson" class="section level4">
<h4>Poisson</h4>
<ol style="list-style-type: lower-alpha">
<li>common λ</li>
<li>separate λ</li>
</ol>
</div>
<div id="negative-binomial" class="section level4">
<h4>Negative binomial</h4>
<ol style="list-style-type: lower-alpha">
<li>common μ and θ</li>
<li>separate μ and common θ</li>
<li>common μ and separate θ</li>
<li>separate μ and θ</li>
</ol>
</div>
<div id="normal-log-transform" class="section level4">
<h4>normal, log transform</h4>
<ol style="list-style-type: lower-alpha">
<li>common μ and σ</li>
<li>separate μ and common σ</li>
<li>common μ and separate σ</li>
<li>separate μ and σ</li>
</ol>
</div>
<div id="normal-square-root-transform-same-4-possibilities-as-logarithm-models" class="section level4">
<h4>normal, square root transform (same 4 possibilities as logarithm models)</h4>
</div>
<div id="zip-model-zero-inflated-poisson" class="section level4">
<h4>ZIP model (zero-inflated Poisson)</h4>
<ol style="list-style-type: lower-alpha">
<li>common λ and θ</li>
<li>separate λ and common θ</li>
<li>common λ and separate θ</li>
<li>separate λ and θ</li>
</ol>
</div>
<div id="zinb-model-9-possible-models" class="section level4">
<h4>ZINB model (9 possible models)</h4>
<p>The ZIP model I use in this exercise is the zero-inflated Poisson model of Lambert (1992). We could also consider fitting the hurdle model but without additional predictors to examine there would not be much point.</p>
<p>Fitting this many models is clearly overkill and some of them could be dismissed out of hand. Burnham &amp; Anderson (2002) would clearly disapprove of this approach as they would argue we should only be fitting those models that can be biologically motivated. I fit so many models here largely to illustrate the mechanics of model-building and the use of AIC to compare models, and only secondarily in order to learn something about the ecology of slugs.</p>
</div>
</div>
<div id="poisson-models" class="section level3">
<h3>Poisson models</h3>
<div id="common-means-model" class="section level4">
<h4>Common means model</h4>
<p>Construct likelihood function and optimize:</p>
<pre class="r"><code>poi.1&lt;-function(data,p) -sum(log(dpois(data$slugs,lambda=p)))</code></pre>
<p>In finding the MLE we need an initial estimate for λ. Since we know λ is the mean of the distribution, I calculate the mean number of slugs found under rocks.</p>
</div>
</div>
</div>
<div id="initial-estimate" class="section level1">
<h1>initial estimate</h1>
<pre class="r"><code>mean(slugs$slugs)</code></pre>
<pre><code>## [1] 1.775</code></pre>
<p>We can fit the model using the <em>nlm</em> function (newton minimization algorithm). I save the output as out1 for use later on in model comparison. From the code and gradient of the output we see that the model converged. The estimate of λ returned is indeed the mean slug count.</p>
<pre class="r"><code>out1 &lt;- nlm(function(p) poi.1(slugs,p),2)</code></pre>
<pre><code>## Warning in dpois(data$slugs, lambda = p): NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) poi.1(slugs, p), 2): NA/Inf replaced by maximum
## positive value</code></pre>
<pre class="r"><code>out1</code></pre>
<pre><code>## $minimum
## [1] 176.8383
## 
## $estimate
## [1] 1.774999
## 
## $gradient
## [1] 1.07282e-06
## 
## $code
## [1] 1
## 
## $iterations
## [1] 5</code></pre>
<div id="separate-means-poisson-model" class="section level4">
<h4>Separate means Poisson model</h4>
<p>In this model we allow the slugs from the two different field types to each have their own value of the parameter λ. Although we could just fit the models separately to the two groups of slugs, that approach would not be very efficient nor would it generalize well to more complicated models we’ll want to fit later. Although field type would appear to be a character variable, it is in fact a factor variable in R. Factor variables are actually numeric variables of a special sort. We’ll take advantage of this specialness later, for the moment we’ll only make use of their intrinsic numerical character. The numerical coding of the variable field can be seen as follows.</p>
<pre class="r"><code>as.numeric(slugs$field)</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [36] 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
## [71] 2 2 2 2 2 2 2 2 2 2</code></pre>
<p>So the nursery slugs are coded 1 and the rookery slugs are coded 2. (The coding is done alphabetically by default.) I make use of this fact to fit a separate λ for each field. I display the function below and then go into the details.</p>
<pre class="r"><code>poi.2&lt;-function(data,p) {
  field.dummy&lt;-as.numeric(data$field)-1
  mylambda&lt;-p[1]+p[2]*field.dummy
  negloglike&lt;- -sum(log(dpois(data$slugs,lambda=mylambda)))
  negloglike
}</code></pre>
<p>The first line of the body of the function (after the function declaration line) subtracts 1 from the numeric coding of field. This changes its current values of 1 and 2 to the new values 0 and 1. The nursery slugs are now coded 0 and the rookery slugs are coded 1. I name the new coding field.dummy because the coding I’m using for nominal data is generally called dummy coding. The second line creates a variable called mylambda that is defined in terms of field.dummy. Since field.dummy is a vector, mylambda will also be a vector. As the value of field.dummy changes among the observations, the value of mylambda will also change. For nursery slugs field.dummy equals 0. Thus for nursery slugs mylambda has the value:</p>
<blockquote>
<p>mylambda = p[1] + p[2]*0 = p[1]</p>
</blockquote>
<p>For rookery slugs field.dummy equals 1. Thus for rookery slugs mylambda has the value</p>
<blockquote>
<p>mylambda = p[1] + p[2]*1 = p[1] + p[2]</p>
</blockquote>
<p>In summary we have the following.</p>
<p>So we see that p[1] is the value of λ for nursery slugs. Since the value of λ for rookery slugs is p[1]+p[2] we see that p[2] represents the difference in the value of λ between nursery and rookery slugs. Since λ is the mean, p[2] is the mean slug count difference between nursery and rookery slugs. The third line in the body of the function is the usual definition of the negative loglikelihood for a Poisson model. Notice that it uses mylambda as the value for λ. Hence the value for λ will differ depending upon field type. The last line is a print statement. Specifying the name of a variable all by itself causes R to print its contents. This last line is crucial because otherwise R will not return a value. In order to use the function I first need initial estimates for the components of p. To get these I calculate the mean number of slugs in the two field types. I use the tapply function for this.</p>
<pre class="r"><code>tapply(slugs$slugs,slugs$field,mean)</code></pre>
<pre><code>## Nursery Rookery 
##   1.275   2.275</code></pre>
<p>The mean difference is 1. Hence I use 1.2 as the estimate for p[1] (the mean for nursery slugs) and 1 for p[2] (the mean difference).</p>
<p>Let’s optimize!</p>
<pre class="r"><code>out2 &lt;- nlm(function(p) poi.2(slugs,p),c(1.2,1))
out2</code></pre>
<pre><code>## $minimum
## [1] 171.1275
## 
## $estimate
## [1] 1.2749997 0.9999997
## 
## $gradient
## [1]  1.125723e-05 -1.506351e-06
## 
## $code
## [1] 1
## 
## $iterations
## [1] 8</code></pre>
<p>I check the gradient and code to verify the model has converged.</p>
<p>Both components are approximately zero as they should be and the estimates are nearly exactly what we would expect. We can examine the negative loglikelihoods of the two models we’ve fit thus far.</p>
<pre class="r"><code>out1$minimum</code></pre>
<pre><code>## [1] 176.8383</code></pre>
<pre class="r"><code>out2$minimum</code></pre>
<pre><code>## [1] 171.1275</code></pre>
<p>So we see that the separate means model is an improvement. Its minimum negative loglikelihood value is smaller (hence the value of its loglikelihood is larger). Since the goal in maximum likelihood estimation is to maximize the probability of observing the data we did observe, model 2 does a better job of this. A more honest comparison of models is to use AIC. I write a function that calculates the AIC of a model. The AIC formula is -2LL + 2k</p>
<p>The following function implements this formula for these data.</p>
<pre class="r"><code>my.aic&lt;-function(output) -2*(-output$minimum) + 2*length(output$estimate)</code></pre>
<p>The extra minus sign in front of output$minimum converts the negative loglikelihood we obtain from nlm to loglikelihood. I use the length function applied to the estimate to count the number of parameters, K, that were estimated. Applying this function to the two models we’ve fit thus far, I obtain the following.</p>
<pre class="r"><code>my.aic(out1)</code></pre>
<pre><code>## [1] 355.6766</code></pre>
<pre class="r"><code>my.aic(out2)</code></pre>
<pre><code>## [1] 346.2551</code></pre>
<p>The second model has the smaller AIC and should be preferred. The difference in AIC is substantial indicating there is very little support for the first model.</p>
</div>
<div id="negative-binomial-models" class="section level3">
<h3>Negative binomial models</h3>
<p>The negative binomial probability model has two parameters, μ and θ, the mean and dispersion. One, neither, or both of these parameters could be allowed to vary across field types yielding 3-parameter, 2-parameter, and 4-parameter models.</p>
</div>
<div id="zip-models" class="section level3">
<h3>ZIP models</h3>
<p>The zero-inflated Poisson model (excess zeros mixture model) is presented in the Bolker book. The probability formula derived there is reproduced below.</p>
<p>Recall that this is the heterogeneous zeros model. The model assumes zero counts arise from two sources. The first source contributes a fraction θ to the probability of a zero count. The remaining fraction derives from a Poisson distribution. As with the negative binomial models there are four models we could consider here. We can let θ and λ be the same in the two field types. We can let λ differ in the two field types but estimate a common θ. We can let θ differ in the two field types but estimate a common λ. We can estimate separate values of λ and θ in the two field types. I consider each of these in turn.</p>
<div id="common-mean-and-zero-fraction-zip-model" class="section level4">
<h4>Common mean and zero fraction ZIP model</h4>
<p>The function for obtaining the negative loglikelihood of the common λ and θ ZIP model is given below.</p>
<pre class="r"><code>#common lambda and theta
  
zip1&lt;-function(data,p) {
  lambda&lt;-p[1]
  theta&lt;-p[2]
  zero.term&lt;-sum(log(theta+(1-theta)* dpois(data$slugs[data$slugs==0], lambda)))
  nonzero.term&lt;-sum(log((1- theta)* dpois(data$slugs[data$slugs&gt;0], lambda)))
  negloglike&lt;- -(zero.term+nonzero.term)
  negloglike
}</code></pre>
<p>The first two lines of the body of the function serve no purpose here except to identify the parameter order. I include them because they make it easy to generalize this function to the three other ZIP models we will fit. Because the ZIP model has a different probability formula for the zero and nonzero counts I need separate lines in the function for these calculations, zero.term and nonzero.term. You should see that these two lines are a direct translation of the formula given above into R code. To ensure that zero.term is only calculated for observations in which the slug count is zero, I use the Boolean expression data<span class="math inline">\(slugs[data\)</span>slugs==0]inside the dpois function. This selects only the slug counts that equal zero. Likewise to use only the nonzero counts in the nonzero.term formula I use the Boolean expression data<span class="math inline">\(slugs[data\)</span>slugs&gt;0]to select those counts that are greater than zero. Finally I add the two terms and place a negative sign in front of the sum to yield the negative loglikelihood. A sensible initial estimate for λ is the mean of the nonzero slug counts. This will only approximate the final estimate because some of the zero counts also come from the Poisson part of the model. A sensible initial estimate for θ is the fraction of zeros. This will only approximate the final estimate of θ because some of the zeros do come from the Poisson part of the model.</p>
<pre class="r"><code>mean(slugs$slugs[slugs$slugs&gt;0])</code></pre>
<pre><code>## [1] 3.086957</code></pre>
<pre class="r"><code>table(slugs$slugs)[1]/sum(table(slugs$slugs))</code></pre>
<pre><code>##     0 
## 0.425</code></pre>
<p>I use λ = 3 and θ = 0.4 as my initial estimates.</p>
<pre class="r"><code>out7 &lt;- nlm(function(p) zip1(slugs,p),c(3,.4))</code></pre>
<pre><code>## Warning in log(theta + (1 - theta) * dpois(data$slugs[data$slugs == 0], :
## NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) zip1(slugs, p), c(3, 0.4)): NA/Inf replaced by
## maximum positive value</code></pre>
<pre class="r"><code>out7</code></pre>
<pre><code>## $minimum
## [1] 150.4711
## 
## $estimate
## [1] 2.920557 0.392239
## 
## $gradient
## [1] 2.724850e-07 4.831691e-07
## 
## $code
## [1] 1
## 
## $iterations
## [1] 5</code></pre>
<p>I check the gradient and code to verify the model has converged.</p>
<p>Both components are approximately zero as they should be. From the estimate of θ we see that most of the zeros, 0.392/0.425 or 92% are ascribed to come from a separate distribution and only a small percentage are estimated to come from the Poisson distribution.</p>
<p>I calculate the AIC.</p>
<pre class="r"><code>my.aic(out7)</code></pre>
<pre><code>## [1] 304.9422</code></pre>
<p>Comparing this to the two Poisson models we see there has been a substantial reduction in AIC. So far the ZIP model is clearly the best. Separate means and common zero fraction ZIP model</p>
<p>The function to fit a ZIP model in which the two fields are allowed to have a separate mean but a common zero fraction is shown next.</p>
<pre class="r"><code># different lambda, same theta 
zip2&lt;-function(data,p) {
  field.dummy&lt;-as.numeric(slugs$field)-1
  mylambda&lt;-p[1]+p[3]*field.dummy
  theta&lt;-p[2]
  zero.term&lt;-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
  nonzero.term&lt;-sum(ifelse(data$slugs&gt;0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
  negloglike&lt;- -(zero.term+nonzero.term)
  negloglike
}</code></pre>
<p>The first part of this function resembles the Poisson model. I create a 0-1 variable field.dummy that records the field type. Then I use it to generate a different value of λ for each field type. The parameter p[3] is the difference in the value of λ between rookery and nursery slugs. I use a new concept, the ifelse construction, to define the zero.term and nonzero.term. The ifelse function has three arguments and has the basic form: ifelse(condition,x,y) The first argument specifies a condition to test. This is a Boolean expression. In my first use of ifelse the condition I test is data$slugs==0. So I’m testing if the slug count is zero or not. The second argument is the calculation to carry out and return if the condition is TRUE. Here I specify the corresponding formula for the ZIP model to use when the count is zero. The third argument is the value to return when the condition is FALSE. I choose to return the value of 0 when the condition is FALSE. Since I end up summing the values returned by the ifelse function, a return value of zero will contribute nothing to the sum. I then do a similar set of calculations for the nonzero terms.</p>
<p>Note: a more efficient but perhaps less readable way of doing this would have been to combine the zero.term and nonzero.term lines into a single line as follows.</p>
<pre class="r"><code>negloglike&lt;- -sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),log((1-theta)* dpois(data$slugs,lambda=mylambda))))</code></pre>
<p>Thus in this version if the slug count is zero we calculate the loglikelihood term for zero counts. If the count is not zero we calculate the loglikelihood term for nonzero counts. The full function would be the following.</p>
<pre class="r"><code>zip2.alt&lt;-function(data,p) {
  field.dummy&lt;-as.numeric(slugs$field)-1
  mylambda&lt;-p[1]+p[3]*field.dummy
  theta&lt;-p[2]
  negloglike&lt;- -sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),log((1-theta)*dpois(data$slugs,lambda=mylambda))))
  negloglike
}</code></pre>
<p>The <em>ifelse</em> function acts on vectors one element at a time and returns a vector of results. The use of the ifelse function is preferable to subsetting the data like was done in the first ZIP function because it makes the code more portable. The portability arises because when we write the remaining ZIP functions we will only need to change the way mylambda and theta are defined. The rest of the function will remain the same. To use the subsetting Boolean expressions approach that I used before I would have to not only subset data$slugs but also the mylambda vector. Later on when we let θ vary between fields we would have to add a Boolean expression to subset theta also. Using the ifelse construction it is not necessary to worry about subsetting at all. The ifelse condition takes care of it for us. The first ZIP function we wrote, zip1, could have been written using the ifelse construction, but there was no compelling reason to do so at the time. To obtain initial values for the fit, I calculate the mean for nonzero counts separately for nursery and rookery slugs.</p>
<pre class="r"><code>tapply(slugs$slugs[slugs$slugs&gt;0],slugs$field[slugs$slugs&gt;0],mean)</code></pre>
<pre><code>##  Nursery  Rookery 
## 3.400000 2.935484</code></pre>
<p>Based on this output we should estimate p[1] to be 3.4 and p[3] to be about –0.4, the rookery mean minus the nursery mean. I fit the model using these initial values and 0.42 as the initial guess for the zero fraction.</p>
<pre class="r"><code>out8 &lt;- nlm(function(p) zip2(slugs,p),c(3.4,.42,-.4))</code></pre>
<pre><code>## Warning in dpois(data$slugs, lambda = mylambda): NaNs produced</code></pre>
<pre><code>## Warning in log(theta + (1 - theta) * dpois(data$slugs, lambda = mylambda)):
## NaNs produced</code></pre>
<pre><code>## Warning in dpois(data$slugs, lambda = mylambda): NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) zip2(slugs, p), c(3.4, 0.42, -0.4)): NA/Inf
## replaced by maximum positive value</code></pre>
<pre><code>## Warning in log(theta + (1 - theta) * dpois(data$slugs, lambda = mylambda)):
## NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) zip2(slugs, p), c(3.4, 0.42, -0.4)): NA/Inf
## replaced by maximum positive value</code></pre>
<pre class="r"><code>out8</code></pre>
<pre><code>## $minimum
## [1] 150.4209
## 
## $estimate
## [1]  3.0578696  0.3950236 -0.1890004
## 
## $gradient
## [1] 9.164487e-06 2.501110e-05 6.536993e-06
## 
## $code
## [1] 1
## 
## $iterations
## [1] 15</code></pre>
</div>
<div id="separate-zero-fraction-and-common-mean-zip-model" class="section level4">
<h4>Separate zero fraction and common mean ZIP model</h4>
<p>The code for this model is a simple modification of the code for the separate means ZIP model. This time I include the field.dummy variable in the definition of theta rather than in the definition of mylambda.</p>
<pre class="r"><code>#different theta
zip3&lt;-function(data,p){
  field.dummy&lt;-as.numeric(data$field)-1
  mylambda&lt;-p[1]
  theta&lt;-p[2]+p[3]*field.dummy
  zero.term&lt;-sum(ifelse(data$slugs==0,log(theta+(1-theta)* dpois(data$slugs,lambda=mylambda)),0))
  nonzero.term&lt;-sum(ifelse(data$slugs&gt;0,log((1-theta)* dpois(data$slugs,lambda=mylambda)),0))
  negloglike&lt;- -(zero.term+nonzero.term)
  negloglike
}</code></pre>
<p>To obtain initial values for p[2] and p[3] I calculate the zero fractions in the two field types. (I divide by 40 because that’s how many observations there were in each field.)</p>
<pre class="r"><code>table(slugs$slugs,slugs$field)[1,]/40</code></pre>
<pre><code>## Nursery Rookery 
##   0.625   0.225</code></pre>
<p>Thus I can use 0.6 as an estimate of p[2] and –0.4 as an estimate of p[3].</p>
<pre class="r"><code>out9 &lt;- nlm(function(p) zip3(slugs,p),c(3,.6,-.4))</code></pre>
<pre><code>## Warning in log(theta + (1 - theta) * dpois(data$slugs, lambda = mylambda)):
## NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) zip3(slugs, p), c(3, 0.6, -0.4)): NA/Inf
## replaced by maximum positive value</code></pre>
<pre><code>## Warning in log(theta + (1 - theta) * dpois(data$slugs, lambda = mylambda)):
## NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) zip3(slugs, p), c(3, 0.6, -0.4)): NA/Inf
## replaced by maximum positive value</code></pre>
<pre class="r"><code>out9</code></pre>
<pre><code>## $minimum
## [1] 143.7118
## 
## $estimate
## [1]  2.9205557  0.6036338 -0.4227899
## 
## $gradient
## [1] -1.210612e-05 -8.867573e-06  2.870593e-06
## 
## $code
## [1] 1
## 
## $iterations
## [1] 8</code></pre>
<p>From the output we can see that the estimates converged and roughly to the values we anticipated.</p>
</div>
<div id="separate-zero-fraction-and-separate-means-zip-model" class="section level4">
<h4>Separate zero fraction and separate means ZIP model</h4>
<p>This is a homework exercise.</p>
</div>
<div id="log-transformed-normal-models" class="section level4">
<h4>Log-transformed normal models</h4>
<p>Common mean and variance log-transformed normal model</p>
<p>Historically log transformations were carried out on count data in the hopes that the resulting distribution would be approximately normal and heteroscedasticity reduced. (Given the large fraction of zeros in the slug data we clearly won’t be able to transform our way to normality here, but I continue anyway.) Since our count data contain zero values we first need to add a small value to each observation so that the logarithm is defined. I choose to add 1 to each value. The function below constructs the negative loglikelihood. The variable t.y is the log-transformed response. I use the dnorm function, which is the normal density function of R, to construct the likelihood. Its arguments are the value at which to compute the density and the mean and standard deviation of the desired normal distribution.</p>
<pre class="r"><code>norm.neglike&lt;-function(data,p) {
  t.y&lt;-log(data$slugs+1)
  mu&lt;-p[1]
  my.sd&lt;-p[2] 
  negloglike&lt;- -sum(log(dnorm(t.y,mean=mu,sd=my.sd)))
  negloglike
}</code></pre>
<p>For initial values of the parameters I calculate the mean and standard deviation of the log-transformed counts.</p>
<pre class="r"><code>mean(log(slugs$slugs+1))</code></pre>
<pre><code>## [1] 0.733247</code></pre>
<pre class="r"><code>sd(log(slugs$slugs+1))</code></pre>
<pre><code>## [1] 0.7414184</code></pre>
<p>Using these I fit the model.</p>
<pre class="r"><code>out.norm &lt;- nlm(function(p) norm.neglike(slugs,p),c(.73,.74))</code></pre>
<pre><code>## Warning in dnorm(t.y, mean = mu, sd = my.sd): NaNs produced</code></pre>
<pre><code>## Warning in nlm(function(p) norm.neglike(slugs, p), c(0.73, 0.74)): NA/Inf
## replaced by maximum positive value</code></pre>
<pre class="r"><code>out.norm</code></pre>
<pre><code>## $minimum
## [1] 89.07672
## 
## $estimate
## [1] 0.7332465 0.7367695
## 
## $gradient
## [1] -6.679102e-07  2.032152e-06
## 
## $code
## [1] 1
## 
## $iterations
## [1] 4</code></pre>
<p>From the output we can conclude the algorithm converged.</p>
<p>As was discussed in lecture, the reported value of negative loglikelihood, 89.07672, is not comparable to that reported for the models that use an untransformed response. We can use the MLEs we obtained here but we need to construct the loglikelihood from scratch. The likelihood for the untransformed response when the log-transformed response is assumed to be normally distributed was developed in lecture 18 and is shown below.</p>
<p>In our case, c = 1. The function below calculates the negative loglikelihood using this formula. It takes two arguments: the name of the data set containing the counts and the name of output file from nlm that contains the maximum likelihood estimates.</p>
<pre class="r"><code>#calculate negative loglikelihood for AIC
norm.like&lt;-function(data,out) {
  t.y&lt;-log(data$slugs+1)
  mu&lt;-out$estimate[1]
  my.sd&lt;-out$estimate[2]
  negloglike&lt;- -sum(log(dnorm(t.y,mean=mu, sd=my.sd)*1/(data$slugs+1)))
  out&lt;-list(negloglike,out$estimate)
  names(out)&lt;-c(&quot;minimum&quot;,&quot;estimate&quot;)
  out
}</code></pre>
<p>The function returns the value of the negative loglikelihood at the MLEs as well as the values of the MLEs. The format of the output was constructed to agree with the output returned by nlm. Using the function I generate the correct negative loglikelihood from which I compute the AIC.</p>
<pre class="r"><code>out20 &lt;- norm.like(slugs,out.norm)
out20</code></pre>
<pre><code>## $minimum
## [1] 147.7365
## 
## $estimate
## [1] 0.7332465 0.7367695</code></pre>
<p>Separate mean and common variance log-transformed normal model</p>
<p>If I calculate the means of the log-transformed response in each field type separately, they look quite different.</p>
<pre class="r"><code>tapply(log(slugs$slugs+1),slugs$field,mean)</code></pre>
<pre><code>##   Nursery   Rookery 
## 0.4967358 0.9697582</code></pre>
<p>The function below constructs the negative loglikelihood for a log-transformed model in which the means are allowed to differ in the two field types, but the standard deviation is assumed to be the same. I use the same format that I used in the comparable ZIP model.</p>
<pre class="r"><code>norm.neglike2&lt;-function(data,p) {
  t.y&lt;-log(data$slugs+1)
  field.dummy&lt;-as.numeric(data$field)-1
  mu&lt;-p[1]+field.dummy*p[3]
  my.sd&lt;-p[2]
  negloglike&lt;- -sum(log(dnorm(t.y,mean=mu,sd=my.sd)))
  negloglike
}</code></pre>
<p>Based on calculated means above I guess initial values for the parameters and fit the model.</p>
<pre class="r"><code>outnorm2 &lt;- nlm(function(p) norm.neglike2(slugs,p),c(.5,.7,.5))</code></pre>
<pre><code>## Warning in nlm(function(p) norm.neglike2(slugs, p), c(0.5, 0.7, 0.5)): NA/
## Inf replaced by maximum positive value</code></pre>
<pre class="r"><code>outnorm2</code></pre>
<pre><code>## $minimum
## [1] 84.7266
## 
## $estimate
## [1] 0.4967359 0.6977763 0.4730215
## 
## $gradient
## [1]  2.432898e-05  1.453770e-05 -2.644640e-05
## 
## $code
## [1] 1
## 
## $iterations
## [1] 6</code></pre>
<p>The model converged. I next modify the function constructed in the previous section for the negative loglikelihood of the untransformed response. The only change I make is in the line defining the variable mu.</p>
<pre class="r"><code>norm.like2&lt;-function(data,out) {
  t.y&lt;-log(data$slugs+1)
  field.dummy&lt;-as.numeric(data$field)-1
  mu&lt;-out$estimate[1]+field.dummy*out$estimate[3]
  my.sd&lt;-out$estimate[2]
  negloglike&lt;- -sum(log(dnorm(t.y,mean=mu, 
    sd=my.sd)*1/(data$slugs+1)))
  out&lt;-list(negloglike,out$estimate)
  names(out)&lt;-c(&quot;minimum&quot;,&quot;estimate&quot;)
  out
}</code></pre>
<p>Finally I use the function to calculate the negative loglikelihood for the different means model and the AIC. Observe that AIC obtained is the lowest so far, even lower than the ZIP model with different zero fractions.</p>
<pre class="r"><code>out21 &lt;- norm.like2(slugs,outnorm2)
my.aic(out21)</code></pre>
<pre><code>## [1] 292.7727</code></pre>
<pre class="r"><code>my.aic(out9)</code></pre>
<pre><code>## [1] 293.4236</code></pre>
<blockquote>
<p>[1] 293.4236</p>
</blockquote>
</div>
<div id="square-root-transformed-normal-models" class="section level4">
<h4>Square root-transformed normal models</h4>
<p>This is a homework exercise. The formula for the likelihood appears in Lecture 18.</p>
</div>
</div>
<div id="carrying-out-the-burnham-anderson-protocol-of-model-comparison" class="section level3">
<h3>Carrying out the Burnham &amp; Anderson protocol of model comparison</h3>
<p>I begin by constructing a variable that contains the names of all the models we have fit.</p>
<pre class="r"><code>model.names&lt;-c(&#39;Pois.common&#39;,&#39;Pois.mean&#39;,&#39;Zip.common&#39;, &#39;Zip.mean&#39;,&#39;Zip.theta&#39;,&#39;lognormal&#39;,&#39;lognormal.mean&#39;)</code></pre>
<p>Next I concatenate all the model results in a single list object. It is necessary to make the object a list because the individual model results are already lists. Lists are objects whose elements are heterogeneous, often of different type or of different length.</p>
<pre class="r"><code>models&lt;-list(out1,out2,out7,out8,out9,out20,out21)</code></pre>
<p>I next write a function that takes the list of model names, the total number of observations in our sample (n), and the list of model results and constructs the model summary table recommended by Burnham &amp; Anderson (2002). (See also the numerical example in Lecture 17.)</p>
<pre class="r"><code>AIC.func&lt;-function(model.list,n,modelnames) {
  output&lt;-NULL
  for (i in 1:length(model.list)) {
    cur.model&lt;-model.list[[i]]
    LL&lt;- -cur.model$minimum
    K&lt;-length(cur.model$estimate)
    AIC&lt;- -2*LL + 2*K
    AICc&lt;-AIC + 2*K*(K+1)/(n-K-1)
    output&lt;-rbind(output,c(LL,K,AIC,AICc))
  }
  colnames(output)&lt;-c(&#39;LogL&#39;,&#39;K&#39;,&#39;AIC&#39;,&#39;AICc&#39;)
  minAICc&lt;-min(output[,&quot;AICc&quot;])
  deltai&lt;-output[,&quot;AICc&quot;]-minAICc
  rel.like&lt;-exp(-deltai/2)
  wi&lt;-round(rel.like/sum(rel.like),3)
  out&lt;-data.frame(modelnames,output,deltai,wi)[order(deltai,decreasing = F),]
  out
}</code></pre>
<div id="some-comments-on-the-function" class="section level4">
<h4>Some comments on the function</h4>
<p>The first line of the function creates an empty object called output. NULL is the keyword that identifies empty content. I need for this object to exist in the first run of the for loop that follows. The for loop is a standard looping construct in R. It is not the most efficient way to program but it is often an easy way to carry out repetitive tasks. A for loop resembles a function in that the body of the for loop is enclosed in curly braces. If the body of the loop consists of a single line then the curly braces are not needed. Following the key word for is an expression enclosed in parentheses that defines how the loop is to be performed. The expression used here is: i in 1:length(model.list) and serves a number of functions. It identifies the variable i as the looping variable. The code that follows the key word in says the first time through the loop i will have the value one. The last time through the loop i will have a value equal to the length of the list object called model.list. Each time the loop is completed the value of i will be incremented by one. The expression is essentially a test condition. When it turns out that if i were to be incremented one by it would no longer be in the specified range, the loop will not be performed. Each time the program reaches the end of the body of the loop it returns to the top of the loop and tests the condition. If i is still in the specified range, 1 to length(model.list), i will be incremented by one and the loop run again. After the loop runs once with i = length(model.list), the loop stops executing and the program moves to first line following the loop. In the first line of the body of the loop I assign to cur.model the results from one of our model fittings. Notice that to reference elements in a list it is necessary to use double bracket notation. Thus, e.g., model.list[[1]] is the first element in a list of elements contained in the list object model.list. The rest of the code just implements the calculations recommended by Burnham and Anderson (2002). Note: At one point I reference a column of a matrix by using its name, e.g., output[,“AICc”]. I use R’s min function to obtain the minimum element of a vector. I use R’s round function to display only 3 decimal places in the Akaike weights. The data.frame function is used to arrange variables in a matrix format when not all of the variables are numeric or character. Here the vector modelnames contains character data while the rest of the columns to be displayed contain numeric values. The usual recommendation is not to use loops in R (or S-Plus). R is a vector-oriented language and most loops can be vectorized thus eliminating the loop. Vectorized expressions in R run faster than loops. But when the loop is short, as it is here, the speed difference is unimportant, and I find it simpler to use a loop. The results of running the AIC.func function on the models we’ve fit in this exercise are shown below.</p>
<pre class="r"><code>AIC.func(models,80,model.names)</code></pre>
<pre><code>##       modelnames      LogL K      AIC     AICc     deltai    wi
## 1    Pois.common -176.8383 1 355.6766 355.7279 62.6393865 0.000
## 2      Pois.mean -171.1275 2 346.2551 346.4109 53.3223890 0.000
## 3     Zip.common -150.4711 2 304.9422 305.0980 12.0095342 0.001
## 4       Zip.mean -150.4209 3 306.8417 307.1575 14.0689934 0.000
## 5      Zip.theta -143.7118 3 293.4236 293.7394  0.6509085 0.410
## 6      lognormal -147.7365 2 299.4730 299.6288  6.5402901 0.022
## 7 lognormal.mean -143.3864 3 292.7727 293.0885  0.0000000 0.567</code></pre>
<blockquote>
<p>modelnames LogL K AIC AICc deltai wi 1 Pois.common -176.8383 1 355.6766 355.7279 62.6393865 0.000 2 Pois.mean -171.1275 2 346.2551 346.4109 53.3223890 0.000 3 Zip.common -150.4711 2 304.9422 305.0980 12.0095342 0.001 4 Zip.mean -150.4209 3 306.8417 307.1575 14.0689934 0.000 5 Zip.theta -143.7118 3 293.4236 293.7394 0.6509085 0.410 6 lognormal -147.7365 2 299.4730 299.6288 6.5402901 0.022 7 lognormal.mean -143.3864 3 292.7727 293.0885 0.0000000 0.567</p>
</blockquote>
<p>Note: it is not necessary or desirable to display both AIC and AICc in the same table. I do so only for pedagogic purposes here. For these data where n = 80, we could use either one although Burnham &amp; Anderson (2002) would recommend using AICc since for some of the models shown. Based on the output we would rank the Zip.theta model, a ZIP model with different values of θ in the two field types, and the lognormal.mean model, a lognormal model in which the means are allowed to vary in the two field types, as the two best models. Based on the Δi values and the Akaike weights we have little basis for choosing one over the other, although technically the lognormal model with separate means numerically ranks best. There is considerably less support for the third-ranking model, the lognormal model with common mean and standard deviation. There is essentially no support for any of the remaining models: the two Poisson models, the common mean and theta ZIP model, and the separate mean but common theta ZIP model. The recommended way to interpret the Akaike weights is as follows. If we were to obtain new data and refit the same set of models and then repeatedly carry out this process of getting new data and fitting the models, we would expect that 57% of the time the lognormal model with separate means would rank as the best model, 41% of the time the ZIP model with different θ parameters for the two field types would rank best, and 2% of the time the lognormal model with common mean and variance would rank best.</p>
</div>
</div>
<div id="cited-references" class="section level3">
<h3>Cited References</h3>
<blockquote>
<p>Burnham, K. P. and D. R. Anderson. 2002. Model Selection and Multimodel Inference. Springer-Verlag: New York. Crawley, Michael J. 2002. Statistical Computing: An Introduction to Data Analysis Using S-Plus. Wiley: New York. Lambert, D. 1992. Zero-inflated Poisson regression, with an application to defects in manufacturing. Technometrics 34: 1–14.</p>
</blockquote>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
