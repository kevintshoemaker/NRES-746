
    model { 
    # Priors and constraints
    mean.sj ~ dunif(0, 1)
    mean.sa ~ dunif(0, 1)
    mean.p ~ dunif(0, 1)
    mean.f ~ dunif(0, 10)
    
    for (t in 1:(n.occasions-1)){
    sj[t] <- mean.sj   #time dependence in likelihood, but not here
    sa[t] <- mean.sa
    p[t] <- mean.p
    }
    
    sigma.obs ~ dunif(0.5, 50)
    tau.obs <- pow(sigma.obs, -2)
    
    # State-space model for count data
    # Model for the initial population size: discrete uniform priors
    N[1,1] ~ dunif(1, 300)
    N[2,1] ~ dunif(1, 300)
    
    # Process model over time
    for (t in 1:(n.occasions-1)){
    N[1,t+1] <- mean.f * mean.sj * (N[1,t] + N[2,t])
    N[2,t+1] <- mean.sa * (N[1,t] + N[2,t])
    }
    
    # Observation model
    for (t in 1:n.occasions){
    count[t] ~ dnorm(N[1,t] + N[2,t], tau.obs)
    }
    
    # Poisson regression model for productivity data
    for (i in 1:n.J){
    J[i] ~ dpois(mean.f)
    }
    
    # Capture-recapture model (multinomial likelihood)
    # Define the multinomial likelihood
    for (t in 1:(n.occasions-1)){
    marr.j[t,1:n.occasions] ~ dmulti(pr.j[t,], rel.j[t])
    marr.a[t,1:n.occasions] ~ dmulti(pr.a[t,], rel.a[t])
    }
    # Define the cell probabilities of the m-arrays
    # Main diagonal
    for (t in 1:(n.occasions-1)){
    q[t] <- 1-p[t]   # Probability of non-recapture
    pr.j[t,t] <- sj[t]*p[t]
    pr.a[t,t] <- sa[t]*p[t]
    # Above main diagonal
    for (j in (t+1):(n.occasions-1)){
    pr.j[t,j] <- sj[t]*prod(sa[(t+1):j])*prod(q[t:(j-1)])*p[j]
    pr.a[t,j] <- prod(sa[t:j])*prod(q[t:(j-1)])*p[j]
    } #j
    # Below main diagonal
    for (j in 1:(t-1)){
    pr.j[t,j] <- 0
    pr.a[t,j] <- 0
    } #j
    } #t
    # Last column: probability of non-recapture
    for (t in 1:(n.occasions-1)){
    pr.j[t,n.occasions] <- 1-sum(pr.j[t,1:(n.occasions-1)])
    pr.a[t,n.occasions] <- 1-sum(pr.a[t,1:(n.occasions-1)])
    } #t
    
    # Derived parameters
    # Annual population growth rate
    for (t in 1:(n.occasions-1)){
    ann.growth.rate[t] <- (N[1,t+1] + N[2,t+1]) / (N[1,t] + N[2,t])    
    }
    # Total population size
    for (t in 1:n.occasions){
    Ntot[t] <- N[1,t] + N[2,t]
    }
    }
    