<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Taylor Brown, Otis Clyne, and Elise Pletcher" />

<meta name="date" content="2021-11-22" />

<title>Spatial Point Process Models in R</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">NRES 746</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Schedule
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="schedule.html">Course Schedule</a>
    </li>
    <li>
      <a href="Syllabus.pdf">Syllabus</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="INTRO.html">Introduction to NRES 746</a>
    </li>
    <li>
      <a href="LECTURE1.html">Why focus on algorithms?</a>
    </li>
    <li>
      <a href="LECTURE2.html">Working with probabilities</a>
    </li>
    <li>
      <a href="LECTURE3.html">The Virtual Ecologist</a>
    </li>
    <li>
      <a href="LECTURE4.html">Likelihood</a>
    </li>
    <li>
      <a href="LECTURE5.html">Optimization</a>
    </li>
    <li>
      <a href="LECTURE6.html">Bayesian #1: concepts</a>
    </li>
    <li>
      <a href="LECTURE7.html">Bayesian #2: mcmc</a>
    </li>
    <li>
      <a href="LECTURE8.html">Model Selection</a>
    </li>
    <li>
      <a href="LECTURE9.html">Performance Evaluation</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lab exercises
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="LAB_Instructions.html">Instructions for Labs</a>
    </li>
    <li>
      <a href="FINALPROJ.html">Final project overview</a>
    </li>
    <li>
      <a href="LAB3demo.html">Lab 3: Likelihood (intro)</a>
    </li>
    <li>
      <a href="LAB5.html">Lab 5: Model selection (optional)</a>
    </li>
    <li>
      <a href="FigureDemo.html">Demo: Figures in R</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Student-led topics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="LECTURE10.html">Machine Learning</a>
    </li>
    <li>
      <a href="TimeSeries_all.html">Time Series</a>
    </li>
    <li>
      <a href="SCR.html">Spatial Capture-Recapture</a>
    </li>
    <li>
      <a href="sppm.html">Spatial Point Process Models</a>
    </li>
    <li>
      <a href="spatial_autocorrelation.html">Spatial Autocorrelation</a>
    </li>
    <li>
      <a href="MEM2.html">Mixed Effects Models</a>
    </li>
    <li>
      <a href="MANOVA.html">MANOVA</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data sets
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TreeData.csv">Tree Data</a>
    </li>
    <li>
      <a href="ReedfrogPred.csv">Reed Frog Predation Data</a>
    </li>
    <li>
      <a href="ReedfrogFuncresp.csv">Reed Frog Func Resp</a>
    </li>
  </ul>
</li>
<li>
  <a href="Links.html">Links</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Spatial Point Process Models in R</h1>
<h4 class="author">Taylor Brown, Otis Clyne, and Elise Pletcher</h4>
<h4 class="date">11/22/2021</h4>

</div>


<pre class="r"><code># load packages
library(spatstat)
library(tidyverse)
library(raster)
library(rgdal)
library(RColorBrewer) 
library(sp)
library(sf)
library(maptools)</code></pre>
<p>Here is the download link for the R script for this lecture: <a href="sppm.R">Spatial point process models</a></p>
<div id="introductionspatial-point-process-models" class="section level1">
<h1>Introduction—Spatial Point Process Models</h1>
<div id="what-is-a-spatial-point-pattern" class="section level2">
<h2>What is a spatial point pattern?</h2>
<p>A spatial point <em>pattern</em> is a dataset giving the observed spatial locations of things or events (for example the location of trees in a forest) Point patterns can be: random, uniform, clustered (we will expand on this idea below)</p>
<p>And a spatial point process <em>model</em> focuses on the how these spatial points are arranged in relation to one another</p>
</div>
<div id="example-research-application" class="section level2">
<h2>Example research application</h2>
<p>A researcher might be interested in identifying spatial trends in the density of points, in which the spatial arrangement of points is often a surrogate for unobserved spatial variables (e.g., soil fertility) or unrecorded historical events such as (e.g., major disturbance events or geological mineralization history).</p>
</div>
<div id="data-format-what-form-does-spatial-point-data-take" class="section level2">
<h2>Data format: What form does spatial point data take?</h2>
<p>A point pattern dataset contains the spatial coordinates of the points, the marks attached to the points (if any), the window in which the points were observed, and the name of the unit of length for the spatial coordinates.</p>
<p>Auxiliary information attached to each point in the in the point pattern is called a mark and we speak of a marked point pattern Marks contain the information about a specific point that we might be interested –these are our possible response variables.</p>
<p>Covariates on the other hand are any data we treat as explanatory for example using a dem to show elevation at each point</p>
</div>
<div id="example-dataset" class="section level2">
<h2>Example Dataset</h2>
<p>Trees within a forested hectare <img src="sppm_dat.jpg" /></p>
<p><strong>Example Window Size: 10m x 10m</strong></p>
<pre class="r"><code>#load demo dataset from sppm package
sppm &lt;- finpines
plot(unmark(sppm), cols = &#39;#756bb1&#39;, main = &#39;spatial point pattern&#39;, border = &#39;red&#39;, pch=19)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code>plot(sppm, cols = &#39;#756bb1&#39;, main = &#39;spatial point pattern with marks&#39;, border = &#39;red&#39;)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-2-2.png" width="672" /></p>
<p><strong>Possible covariates</strong></p>
<pre class="r"><code>#load covariate data
  
  #rainfall
  rainfall.raster &lt;- raster(&quot;monthly_rainfall.tif&quot;)
  col.rain &lt;- colorRampPalette(rev(brewer.pal(5, &#39;Spectral&#39;)))
 
  #dem
  dem &lt;- raster(&quot;SJER2013_DSM.tif&quot;)
  
  # plot example covariates
  par(mfrow = c(1,2))
  plot(rainfall.raster, main = &quot;Average monthly rainfall (mm)&quot;, col = col.rain(255), labels = F)
  plot(dem, main = &quot;Elevation&quot;, col = terrain.colors(100), labels = F)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<div id="how-do-we-analyze-spatial-point-process-data-theres-an-r-package-for-that" class="section level3">
<h3>How do we analyze spatial point process data?? There’s an R package for that!</h3>
</div>
</div>
</div>
<div id="introducing-spatstat" class="section level1">
<h1>Introducing spatstat</h1>
<p><strong>What is spatstat?</strong></p>
<p>spatstat is an R package for spatial statistics with a major focus on analyzing point patterns. Most of the functionality is for two-dimensional spatial point patterns but there is some support for three-dimensional and space-time. The “spatstat” package is one of the largest contributed packages avialable for R. It is the result of 15 years of development with about 1500 functions and 43 datasets.</p>
<p><strong>What kinds of data can spatstat handle?</strong></p>
<p>spatstat can handle all the major kinds of spatial data: point patterns, regional data, and geostatstical data. The main historical focus of the spatstat package is spatial point patterns in two-dimensional space. The point patterns can be marked by real numbers, categorical values, and logical values. spatstat can also handle spatial regions, pixel images, line segments, and tessellations in two-dimensional space.</p>
<p>The package supports point pattern datasets in any number of dimensions but only has modest capability with three-dimensional point pattern datasets. This area is under development but the vast majority of functions will still focus on spatial point patterns in two-dimensional space.</p>
<p><strong>What kind of analysis can spatstat perform?</strong></p>
<p>spatstat is designed to support a complete statistical analysis of a spatial point pattern dataset. It contains functions for data handing, exploratory data analysis, model-fitting, simulation, spatial sampling, model diagnostics, and formal inference.</p>
<div id="data-handling-format" class="section level2">
<h2>Data handling format</h2>
<p>To use spatstat, a spatial point pattern dataset must converts points to an object of class “ppp”(planar point pattern). A point pattern object contains the spatial coordinates of the points, marks attached to the points(if any), the observation window of the points, and the name of the unit of length for the spatial coordinates.</p>
<p><strong>Example of ppp conversion with finpines dataset in spatstat</strong></p>
<p>The dataset finpines is a marked point pattern containing the locations of 126 pine saplings in Finland marked by their heights and their diameters.Sapling locations are given in meters; heights are in meters; diameters are in centimeters.</p>
<p>(Dr.Antti Penttinen, Department of Statistics, University of Finland.)</p>
<pre class="r"><code>fp &lt;- read.table(&quot;finpines.txt&quot;, header=TRUE)
head(fp)</code></pre>
<pre><code>##           x         y diameter height
## 1 -1.993875 0.9297642        1    1.7
## 2 -1.019901 0.4120694        1    1.7
## 3 -4.914071 1.9854250        1    1.6
## 4 -4.469962 1.4523900        5    4.1
## 5 -4.303847 0.9148214        3    3.1
## 6 -3.814774 0.8108644        4    4.3</code></pre>
<pre class="r"><code>fin_pines &lt;- as.ppp(fp, owin(c(-5,5), c(-8,2)))
fin_pines</code></pre>
<pre><code>## Marked planar point pattern: 126 points
## Mark variables: diameter, height 
## window: rectangle = [-5, 5] x [-8, 2] units</code></pre>
</div>
</div>
<div id="exploratory-data-analysis" class="section level1">
<h1>Exploratory Data Analysis</h1>
<div id="summary-statistics-intensity-correlation-spacing" class="section level2">
<h2>Summary Statistics – intensity, correlation &amp; spacing</h2>
<p><strong>Intensity</strong> Intensity’ is the average density of points (expected number of points per unit area). Intensity may be constant (‘uniform’) or may vary from location to location (‘non-uniform’ or ‘inhomogeneous’).</p>
<p>If the point process X is homogeneous, then for any sub-region B of two-dimensional space, the expected number of points in B is proportional to the area of B: E[N(X ∩ B)] = λ area(B)</p>
<p>If we know that a point process is homogeneous, then the empirical density of points, λ =n(x)/area(W)</p>
<p>An example with data:</p>
<pre class="r"><code>data(bei)
summary(bei)</code></pre>
<pre><code>## Planar point pattern:  3604 points
## Average intensity 0.007208 points per square metre
## 
## Coordinates are given to 1 decimal place
## i.e. rounded to the nearest multiple of 0.1 metres
## 
## Window: rectangle = [0, 1000] x [0, 500] metres
## Window area = 5e+05 square metres
## Unit of length: 1 metre</code></pre>
<pre class="r"><code>lamb &lt;- summary(bei)$intensity
lamb</code></pre>
<pre><code>## [1] 0.007208</code></pre>
<p><em>Inhomogenous Intestity</em> In general the intensity of a point process will vary from place to place. Assume that the expected number of points falling in a small region of area du around a location u is equal to λ(u) du. Then λ(u) is the “intensity function” of the process, satisfying E[n(X∩B)] = Integral(Bλ(u)d)</p>
<p><strong>Correlation</strong></p>
<p>The motivation for analyzing point pattern data is to determine whether the points are independent of each other or whether they have interpoint dependence. A standard tool for measuring dependence is correlation, or more generally covariance. Correlation in this situation means measuring dependence between points in a point pattern.</p>
<div class="figure">
<img src="point_patterns_examples.jpg" alt="" />
<p class="caption">(Crawley 2007)</p>
</div>
<p>Correlation is classified as a second moment quantity. The “first moment” of a random variable X is its mean value and the “second moment” is the mean of X^2. The first and second moments of random variables determine variance, standard deviation, covariance, and correlation. To obtain an accurate measurement of correlation it requires estimation of the mean (first moment). In the point process context, it means to have good knowledge of intensity before we can trust the correlation. The correlation is not a characteristic of dependence or causation but a summary index of statistical association. With this measure, we cannot discriminate between different possible causes of spatial clustering.</p>
<p><strong>Ripley K-function</strong></p>
<p>A popular technique for analizing spatial correlations in point patterns is the Ripley K-function. The Ripley K-function compares a given point distribution with a random distribution. It is testing against the null hypothesis that the points are distributed randomly and independently (CSR). Using the K-function implicitly assumes that the point process has homogeneous intensity.</p>
<p><strong>Ripley’s K for nests of two species of ants</strong></p>
<p>These data give the spatial locations of nests of two species of ants, Messor wasmanni and Cataglyphis bicolor, recorded by Professor R.D. Harkness at a site in northern Greece, and described in Harkness &amp; Isham (1983). The harvester ant M. wasmanni collects seeds for food and builds a nest composed mainly of seed husks. C. bicolor is a heat-tolerant desert foraging ant which eats dead insects and other arthropods. Interest focuses on whether there is evidence in the data for intra-species competition between Messor nests (i.e. competition for resources) and for preferential placement of Cataglyphis nests in the vicinity of Messor nests.</p>
<p>Demo as followed by Brooke McInttyre.</p>
<pre class="r"><code>data(&quot;ants&quot;)
summary(ants)</code></pre>
<pre><code>## Marked planar point pattern:  97 points
## Average intensity 0.0002261486 points per square unit (one unit = 0.5 feet)
## 
## Coordinates are integers
## i.e. rounded to the nearest unit (one unit = 0.5 feet)
## 
## Multitype:
##             frequency proportion    intensity
## Cataglyphis        29  0.2989691 6.761144e-05
## Messor             68  0.7010309 1.585372e-04
## 
## Window: polygonal boundary
## single connected closed polygon with 11 vertices
## enclosing rectangle: [-25, 803] x [-49, 717] units
##                      (828 x 766 units)
## Window area = 428922 square units
## Unit of length: 0.5 feet
## Fraction of frame area: 0.676</code></pre>
<pre class="r"><code>#Create object to hold density function
ants_dens &lt;- density(ants)
summary(ants_dens)</code></pre>
<pre><code>## real-valued pixel image
## 128 x 128 pixel array (ny, nx)
## enclosing rectangle: [-25, 803] x [-49, 717] units (one unit = 0.5 feet)
## dimensions of each pixel: 6.47 x 5.984375 units
## (one unit = 0.5 feet)
## Image is defined on a subset of the rectangular grid
## Subset area = 429038.731933594 square units
## Subset area fraction = 0.676
## Pixel values (inside window):
##  range = [0.0001244011, 0.0003996359]
##  integral = 97.57579
##  mean = 0.0002274289</code></pre>
<pre class="r"><code># Density plot with contour lines and points showing where the nests of the two species of ants are located.
plot.new()
plot(ants_dens, main =&quot;Density of Ant Nests&quot;)
contour(ants_dens,add=T)
points(ants, pch=20)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>This density plot indicates that ant nests are more dense in the bottom right corner of the polygonial boundary. This is the only location with a density this high, which suggests ant nests are only clumped together in this one location. The rest of the plot points look pretty random. We can investigate these patterns further using Ripley <em>K</em> functions.</p>
<pre class="r"><code>#Ripley&#39;s K for ants dataset

n &lt;- 100
ants_ripleyK &lt;- envelope(ants,fun=Kest,nsim=n, verbose=FALSE) 

plot(ants_ripleyK)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>The observed <em>K(r)</em> function is within the envelope, which indicates that the ants follow CSR (complete spatial randomness) at every distance. If the observed <em>K</em> value is larger than the expected <em>K</em> value for a particular distance means the distribution is more clustered than a random distribution.</p>
<pre class="r"><code>#Create subsets of data for each ant species
cataglyphis &lt;- subset(ants, marks==&quot;Cataglyphis&quot;, drop=T)
messor &lt;- subset(ants, marks==&quot;Messor&quot;, drop=T)

##Density plot for Cataglyphis species with points added
plot(density(cataglyphis), main = &quot;Density of C. bicolor ant nests&quot;)
points(cataglyphis, pch=20)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r"><code>##Density plot for Messor species with points added
plot(density(messor), main = &quot;Density of M. wasmanni ant nests&quot;)
points(messor, pch=20)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>The density plots indicate that there are more ant nests of both species in the lower right hand corner of study site. There are no Cataglyphis ant nests in the upper right side of the plot but several Messor ant nests.</p>
<pre class="r"><code>#K function plots for each species of ants
#cataglyphis
plot(envelope(cataglyphis,fun=Kest,nsim=n,verbose=F))</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>#Messor
plot(envelope(messor,fun=Kest,nsim=n,verbose=F))</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r"><code>#Array of K function plots for ants dataset
ants_all_k_plots &lt;- alltypes(ants,&quot;K&quot;,envelope=T,verbose=F)
plot(ants_all_k_plots)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>The <em>K</em>- function plots indicate that within and between ant nests follow a CSR pattern at all distances.</p>
<p><strong>Spacing</strong></p>
<p>Correlation overlooks some aspects of dependence. To parse out these dependencies we can use measured spacings or shortest distances to reveal additional information about the point pattern.</p>
<p><strong><em>Distances can be measured as:</em></strong></p>
<p>Pairwise distances - the distance between all distinct pairs of points <em>xi</em> and <em>xj</em></p>
<p>Nearest-neighbor distances – the distance from each point , <em>xi</em>, to its nearest neighbour</p>
<p><img src="nnd.jpg" /></p>
<p>(or instead of nearest nieghbor we may also consider the 2nd, 3rd, etc. nearest neighbors)</p>
<p>Empty space distance – the distance from a fixed reference location (+) in the window to the nearest data point</p>
<p><img src="esd.jpg" /></p>
<p><strong>Note:</strong> nearest-neighbor distances and empty-space distances respond in opposite directions—as nnd become larger, esd becomes smaller.</p>
<pre class="r"><code># paired distances
pairdist(finpines)[1:3, 1:5]</code></pre>
<pre><code>##          [,1]     [,2]     [,3]      [,4]     [,5]
## [1,] 0.000000 1.103011 3.105151 2.5306411 2.310020
## [2,] 1.103011 0.000000 4.200001 3.6034966 3.322207
## [3,] 3.105151 4.200001 0.000000 0.6938005 1.232301</code></pre>
<pre class="r"><code>#nearest neighbor distances 
nndist(finpines)[1:5]</code></pre>
<pre><code>## [1] 1.1030110 0.4291570 0.6938005 0.5626493 0.1847252</code></pre>
<pre class="r"><code># empty space distanecs 
Z &lt;- distmap(finpines)
plot(Z)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<div id="indices" class="section level4">
<h4>Indices</h4>
<p><strong>Clark-Evans Index:</strong></p>
<p>Takes the average nearest neighbor distances from randomly sampled points in a point pattern, and divides this by the expected value for a random process with the same intensity—to obtain an index of spatial regularity.</p>
<p><img src="clark_evans_eq.jpg" /></p>
<p>We can turn this index into a test of spatial randomness where: <em>R</em> = 1 is completely random; <em>R</em>&lt;1 suggests clustering; <em>R</em> &gt; 1 suggests regularity</p>
<p>We need to account for edge effects or <em>R</em> will be positively biased. Because the true nearest neighbor may lie outside of the actual window.</p>
<p>We can do this by adding a correction argument to our function, here we added Donnelly correction</p>
<pre class="r"><code># clark evans test
clarkevans.test(finpines, correction = &quot;donnelly&quot;)</code></pre>
<pre><code>## 
##  Clark-Evans test
##  Donnelly correction
##  Monte Carlo test based on 999 simulations of CSR with fixed n
## 
## data:  finpines
## R = 0.85639, p-value = 0.006
## alternative hypothesis: two-sided</code></pre>
<p><strong>Hopkins-Skellam Index:</strong></p>
<p>Uses both nearest-neighbor distances and the empty spaced distances and goes off the assumption that if pattern is random, then the prob distribution distance for both metrics should be the same (because remember the less clustering, the less large distances empty spaces).</p>
<p><img src="hopkins_skellam_eq.jpg" /></p>
<p><em>A</em> = 1 random; <em>A</em> &lt;1 clustering; <em>A</em> &gt; 1 consistent with regularity</p>
<p>** less sensitive to edge effects bias and spatial inhomogeneity than Clark-Evans test</p>
<p><img src="random_spacing.jpg" /></p>
<p>Nearest Neighbor and empty space functions as tools to determine randomness</p>
<p>Instead of just looking at the average nearest neighbor distance or average empty space distance for a spatial point pattern, we can look at these distances as a function over distance <em>r</em>.</p>
<p><img src="f_funct.jpg" /></p>
<p>Which is defined for all distances <em>r</em> &gt;= 0, where u is an arbitrary reference location. <em>F(r)</em> is a vector of probability, giving for any fixed reference location (<em>u</em>) the chance that there will be a point <em>X</em> lying within distance <em>r</em> from this location.</p>
<p>If completely random, then <em>F(r)</em> will follow a poisson distribution—basically this function gives us a theoretical empty-space function for a homogeneous point process with an intensity of λ</p>
<p><img src="f_func_graph.jpg" /></p>
</div>
<div id="summary-of-spacing" class="section level3">
<h3>Summary of spacing</h3>
<p><img src="f_and_g_functions.jpg" /> When the empirical function for empty space distances follows the theoretical function closely the data can be interpreted as nearly spatially random. When the empirical function falls below the theoretical function, the empty spaces are larger than would be expected of randomness (clustering). When the empirical function falls above empty spaces are smaller than expected, indicated regularity.</p>
<p>Here’s an example of the <em>F(r)</em> function for the finpines dataset:</p>
<pre class="r"><code>plot(Fest(finpines))</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Above we can see the blue dashed line, which is the theoretical function for complete randomness and 3 estimates of the function given the data. Our empirical data is below the theoretical curve for a completely random process–indicating the empty-space distances are larger than would be expected of randomness (aka clustering). This is also consistent with both A and R indices being less than 1.</p>
<p>Again, we could plot ‘Gest()’ to interpret the nearest-neighbor distance distribution function <em>G</em> but we will skip that for the sake of time today.</p>
</div>
<div id="estimating-the-functions-for-k-f-and-g-will-have-important-implications-and-guide-our-selection-of-the-appropriate-point-process-model." class="section level3">
<h3>Estimating the functions for <em>K</em>, <em>F</em>, and <em>G</em> will have important implications and guide our selection of the appropriate point process model.</h3>
</div>
</div>
</div>
<div id="statistical-inference" class="section level1">
<h1>Statistical Inference</h1>
<div id="poisson-point-process-models" class="section level2">
<h2>Poisson Point Process Models</h2>
<p>The simplest theoretical point process model is the homogeneous Poisson process. This process satisfies two conditions. First, the number of events in any region A follows a Poisson distribution with mean λ|A|, where λ is a constant value denoting the intensity and |A| is the area of region A. And second, the number of events in disjoint regions are independent. Thus, if a point pattern arises as a realization of a homogeneous Poisson process, an event is equally likely to occur at any location within the study region, regardless of the locations of other events.</p>
<p>The homogeneous Poisson process of intensity λ &gt; 0 has the properties</p>
<p>(PP1): the number N(X ∩ B) of points falling in any region B is a Poisson random variable;</p>
<p>(PP2): the expected number of points falling in B is E[N(X ∩ B)] = λ · area(B);</p>
<p>(PP3): if B1, B2 are disjoint sets then N(X∩B1) and N(X∩B2) are independent random variables;</p>
<p>(PP4): given that N(X ∩ B) = n, the n points are independent and uniformly distributed in B.</p>
<p>You may have heard this as “Complete Spatial Randomness” (CSR) especially in biological science. Under CSR, points are independent of each other and have the same propensity to be found at any location.</p>
<p>Homogeneity: The points have no preference for any spatial location</p>
<p>Independence: Information about the outcome in one region of space has no influence on the outcome in other regions</p>
<p>A realistic model of some physical phenomena such as radioactivity, rare events, or extreme events. It serves as a benchmark or standard reference model for which other patterns can be compared. In many models, the Homogeneous Poisson process serves as the null hypothesis.</p>
<p>Fitting a Poisson point process in spatstat</p>
<p>A simple homogeneous Poisson Point Process</p>
<pre class="r"><code>summary(bei)</code></pre>
<pre><code>## Planar point pattern:  3604 points
## Average intensity 0.007208 points per square metre
## 
## Coordinates are given to 1 decimal place
## i.e. rounded to the nearest multiple of 0.1 metres
## 
## Window: rectangle = [0, 1000] x [0, 500] metres
## Window area = 5e+05 square metres
## Unit of length: 1 metre</code></pre>
<pre class="r"><code>class(bei)</code></pre>
<pre><code>## [1] &quot;ppp&quot;</code></pre>
<pre class="r"><code>plot(bei)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<pre class="r"><code>plot(quadratcount(bei)) # shows a count of all the data in quadrats</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-18-2.png" width="672" /></p>
<pre class="r"><code>fit &lt;- ppm(bei ~ 1)
fit</code></pre>
<pre><code>## Stationary Poisson process
## Intensity: 0.007208
##              Estimate       S.E.   CI95.lo   CI95.hi Ztest      Zval
## log(lambda) -4.932564 0.01665742 -4.965212 -4.899916   *** -296.1182</code></pre>
<pre class="r"><code>class(fit)</code></pre>
<pre><code>## [1] &quot;ppm&quot;</code></pre>
<p>The result of ppm is a fitted point process model, an object belonging to the class “ppm”. There are many facilities for handling such objects. For instance there is a print method print.ppm, which produced the output above. This output tells us that the fitted intensity was λ = 0.007208 trees per square meter.</p>
<pre class="r"><code>exp(-4.933)</code></pre>
<pre><code>## [1] 0.007204856</code></pre>
<p>Now for something a little more… Interesting We will explore the covariates in the bei dataset using the separably supplied “bei.extra” object. in bei.extra elevation (elev) and terrain slope (grad) are provided as a list.</p>
<p>Take a look at the data</p>
<pre class="r"><code>bei.extra</code></pre>
<pre><code>## List of pixel images
## 
## elev:
## real-valued pixel image
## 101 x 201 pixel array (ny, nx)
## enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] metres
## 
## grad:
## real-valued pixel image
## 101 x 201 pixel array (ny, nx)
## enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] metres</code></pre>
<p>Let’s run inhomogeneous (non-stationary as labeled in the output) Poisson model with the intensity of the Beilschmiedia tress as a loglinear function of terrain slope</p>
<pre class="r"><code>fit2 &lt;- ppm(bei ~ grad, data = bei.extra)
fit2</code></pre>
<pre><code>## Nonstationary Poisson process
## 
## Log intensity:  ~grad
## 
## Fitted trend coefficients:
## (Intercept)        grad 
##   -5.391053    5.026710 
## 
##              Estimate       S.E.   CI95.lo   CI95.hi Ztest      Zval
## (Intercept) -5.391053 0.03001787 -5.449887 -5.332219   *** -179.5948
## grad         5.026710 0.24534296  4.545847  5.507573   ***   20.4885</code></pre>
<p>The model above defines intensity as λ(u) = exp(β0 +β1S(u). Where S(u) is the terrain slope at location u. The component β1S(u) is called the ‘effect’ of the covariate S.</p>
<p>covariates — any data that we treat as explanatory, rather than as part of the ‘response’.</p>
<p>Note that the outpus of “intercept” and “grad” gives us the maximum likelihood estimates of of β0 and β1, respectively, the coefficients of the linear predictor; so the fitted model is λ(u) = exp(−5.391+5.022S(u))</p>
<p>These results tell us that the estimated intensity of Beilschmiedia trees on a level surface (slope S = 0) is about exp(−5.391) = 0.004559 trees per square meter, or 45.59 trees per hectare, and would increase by a factor of exp(5.022) = 151.7 if the slope increased to 1.0. The largest slope value in the data is about 0.3, at which stage the predicted intensity has risen by a factor of exp(0.3× 5.022) = 4.511, that is, more than quadrupled from its value on a level surface.</p>
<p>In this simple model, the fitted intensity can also be plotted as a function of a covariate (in the current example, the covariate grad) using the spatstat utility effetfun, as shown below.</p>
<pre class="r"><code>plot(effectfun(fit2, &quot;grad&quot;, se.fit = T))</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>NOTE: the formula bei ~ grad corresponds to the loglinear relationship (9.7), that is, it corresponds to assuming intensity is exponentially increasing or decreasing as a function of terrain slope.</p>
<p>We can also look at the interaction between the covariates of elev and grad by using an additive model. using the formula: λ(u) = exp(β0 +β1E(u) +β2S(u)), where β0,β1,β2 are parameters to be estimated, E(u) is the terrain elevation in meters at location u, and S(u) is the terrain slope (a dimensionless gradient). Additive models are specified by joining the relevant model terms together using + (just like almost all additive regressions in R).</p>
<pre class="r"><code>fit3 &lt;- ppm(bei ~ elev + grad, data=bei.extra)
fit3</code></pre>
<pre><code>## Nonstationary Poisson process
## 
## Log intensity:  ~elev + grad
## 
## Fitted trend coefficients:
## (Intercept)        elev        grad 
## -8.56355220  0.02143995  5.84646680 
## 
##                Estimate        S.E.     CI95.lo     CI95.hi Ztest       Zval
## (Intercept) -8.56355220 0.341113849 -9.23212306 -7.89498134   *** -25.104675
## elev         0.02143995 0.002287866  0.01695581  0.02592408   ***   9.371155
## grad         5.84646680 0.255781018  5.34514522  6.34778838   ***  22.857313</code></pre>
<p>interpretation of this model is relatively straightforward. Both covariates are continuous variables. On an aspect of terrain where slope = 0 and elevation = 0 (sea level), the intensity of trees would be exp(-8.56355220) or 0.0001918 trees per square meter, and for each additional meter of elevation, intensity would increase by 1.022 trees. And say, for each additional 0.1 degree of slope units the intensity increases by a factor of exp(0.1*5.841) = 1.793 trees.</p>
<p>Since this model was additive, elevation increases by 1 meter and slope by 0.1 units, the log intensity increases by the elevation effect (1 x 0.02141) PLUS the slope effect (0.1 x 5.841).</p>
<p>To assess the ‘importance’ of each covariate, we need to take the range of each variable.</p>
<pre class="r"><code>coefs &lt;- fit3$coef

grad = bei.extra$grad
max(grad)</code></pre>
<pre><code>## [1] 0.3284767</code></pre>
<pre class="r"><code>imp.grad &lt;- exp(coefs[3]*max(grad))
imp.grad</code></pre>
<pre><code>##     grad 
## 6.823879</code></pre>
<pre class="r"><code>elev = bei.extra$elev
dif.elev &lt;- max(elev) - min(elev)
min.elev &lt;- min(elev)
imp.elev &lt;- exp(coefs[2]*dif.elev)
imp.elev</code></pre>
<pre><code>##    elev 
## 2.34087</code></pre>
<p>Slope is “more important” in magnitude.</p>
<div id="section" class="section level56">
<p class="heading"></p>
</div>
<div id="using-fitted-models-for-prediction" class="section level10">
<p class="heading">Using fitted models for Prediction</p>
<div id="section-1" class="section level56">
<p class="heading"></p>
<p>The value returned by the model-fitting function ppm is an object of class "“ppm”" that represents the fitted model. This is analogous to the fitting of linear models (lm), generalized linear models (glm), and so on.</p>
<p>AND because of this, we can use of fitted Poisson Point Process Model to make predictions about the points in our given area.</p>
<p>For any Poisson model with intensity λ(u) = λθ(u) where θ is a parameter vector, the fitted intensity or predicted intensity is the function λθb(u) obtained by substituting the fitted parameter estimates into the intensity formula.</p>
<pre class="r"><code>fit4 &lt;- ppm(bei ~ polynom(grad, elev, 2), data=bei.extra)
lamhat &lt;- predict(fit4)

lamB &lt;- predict(fit4)
plot(lamB)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-25-1.png" width="672" /> This yields a contour plot of intensity from predict(fit4) and the second plot is standard error.</p>
<pre class="r"><code>plot(predict(fit4, se=TRUE)$se)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>We can also create a perspective view of rain forest terrain shaded according to intensity of fitted model, with original point pattern superimposed.</p>
<pre class="r"><code>M &lt;- persp(bei.extra$elev, olin=lamhat, colmap=topo.colors,
  shade=0.4, theta=-55, phi=25, expand=6,
  box=FALSE, apron=TRUE, visible=TRUE, main = &quot;Terrain with Intensity of Fitted Model&quot;)
perspPoints(bei, Z=bei.extra$elev, M=M, pch=20, cex=0.1)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-27-1.png" width="672" /> Pretty cool!</p>
<p>Lastly we can predict the number of points in our region B. Using a Poisson process, the expected number of points in B is the integral of the intensity over B E[n(X∩B)] = Integral(Bλ(u)d)</p>
<pre class="r"><code>#this can be computed by using the predict.ppm() and by setting type = &quot;count&quot; and by specifying B as the window. 
#in this way we can compute the expected number of trees at elevations below 130 meters. 
B &lt;- levelset(bei.extra$elev, 130)
predict(fit4, type=&quot;count&quot;, window=B)</code></pre>
<pre><code>## [1] 37.16835</code></pre>
<pre class="r"><code>predict(fit4, B, type=&quot;count&quot;, se=TRUE)</code></pre>
<pre><code>## $estimate
## [1] 37.16835
## 
## $se
## [1] 3.613492</code></pre>
<pre class="r"><code>predict(fit, B, type=&quot;count&quot;, interval=&quot;confidence&quot;)</code></pre>
<pre><code>##     2.5%    97.5% 
## 192.0165 204.9776</code></pre>
<pre class="r"><code>#In this case it is also meaningful to compute a prediction interval for the random number of trees in the specified region:
predict(fit, B, type=&quot;count&quot;, interval=&quot;prediction&quot;)</code></pre>
<pre><code>##  2.5% 97.5% 
##   170   226</code></pre>
<p><strong>In Summary</strong></p>
<p>A 95% prediction interval for the number of points in region B is designed so that, if the experiment were repeated, there is a 95% probability that the random value of n(X ∩B) would lie in the interval.</p>
<p>Here we have looked at both homogenous and inhomogenous Poisson Process models in R.</p>
<p>Key takeaways:</p>
<p>Always assess your data and look for randomness and independence between each point.</p>
<p>In the first case, the constant, intensity, is the average density of the points in the Poisson process located in some region of space. The resulting point process is called a homogeneous or stationary Poisson point process.</p>
<p>In the second case, the point process is called an inhomogeneous or nonhomogeneous Poisson point process, and the average density of points depends on the location of the underlying space of the Poisson point process.</p>
<p>But not all data meet the assumptions of Poisson processes… Let’s look at some other potential models!</p>
</div>
</div>
</div>
<div id="cox-and-cluster-models" class="section level2">
<h2>Cox and Cluster Models</h2>
<p>Until now we have focused on Poisson process models, in which the points are assumed to be independent of each other. Now we will be introducing models that allow dependence between points. Cox and cluster processes are modifications of the Poisson process to incorporate additional random influences.</p>
<p>In a cluster process, the additional random influence arises from the unseen parent points which give rise to offspring points which are actually observed. Each observed point’s location depends on its parent’s location, and this influence is shared by other offspring of the same parent. The pattern looks clustered. The California redwood trees seedlings dataset could be modeled as a cluster process. In this model, each of the original parent trees gave rise to a cluster of young trees.</p>
<pre class="r"><code>#Locations of 62 seedlings and saplings of California redwood trees.
plot(redwood)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<p>A Cox process is effectively a Poisson process in which the intensity itself is random. The random variation is often attributable to an unobserved spatial covariate. Spatial variation in the random intensity function can cause points to be more abundant in some areas than in others. This phenomenon can make the point pattern look clustered, if there are high peaks in the random intensity. The Beischmidedia data could be modeled as a Cox process. The model postulates that there is an underlying, spatially varying, intensity function which is random because it depends on unobservable external factor as as well as observable covariates. In this case, it could be attributable to habitat preferences (ex: preference for steep slope, acidic soil. There is positive association between trees, because the presense of Beilschmideia tree implies the habitat is favorable there, which then implies that other Beilschmiedia trees are likely to be found nearby.</p>
<pre class="r"><code>#A point pattern giving the locations of 3605 trees in a tropical rain forest. Accompanied by covariate data giving the elevation (altitude) and slope of elevation in the study region.
plot(bei)</code></pre>
<p><img src="sppm_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>Both Cox processes and cluster processes are “clustered” as measured by the K-function. They combine the variability of the Poisson point process with an additional source of variability, so they are overdispersed (the variance of the number of points falling in a region is greater than the mean). They both are modifications of the Poisson process to incorporate random effects, they just reflect slightly different ways of thinking about the underlying random influences.</p>
<p>It is a strategic choice to decide whether to use a fixed effects model (Poisson process) or a random effects model (Cox or cluster process).</p>
<p>Cluster and cox process models are fitted to data in spatstat using the function kppm.</p>
</div>
<div id="gibbs-models" class="section level2">
<h2>Gibbs Models</h2>
<p>Another flexible type of model and work well when there is dependency between points in a point pattern.</p>
<p>The K function measures correlation between points, not causal interaction. To draw inferences about the interactions that may give rise to a particular spatial point pattern, a GIBBS MODEL explicitly postulates that interactions occur between points of the process (such as repulsion or attraction of points).</p>
</div>
<div id="a-note-on-model-validation" class="section level2">
<h2>A note on model validation</h2>
<p>Similar to other modeling methods we have seen, you can explore the residuals and QQ plots</p>
</div>
<div id="potential-limitations" class="section level2">
<h2>Potential Limitations</h2>
<p>An issue with presence-only data is data quality, and there are a number of potential extensions to take into account data of varying quality. For example, typically there is uncertainty in the spatial location of presence points, and locations are often assigned ‘accuracy’ scores to estimate this which can be accounted for in subsequent modelling.</p>
</div>
<div id="strengths" class="section level2">
<h2>Strengths</h2>
<p>A key strength of point process models is that they operate at what is usually the most ecologically relevant of sampling levels – the level of the individual. This means they can (in principle) incorporate processes operating at the level of the individual, such as interactions between individual organisms, or covariates that vary across individuals.</p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>Analyzing point pattern data is a major focus of study within spatial statistics. Point pattern data appears in a broad range of disciplines. It allows the researcher to be able to describe why an phenomenon is occurring at random locations and/or times.</p>
<p>Examples: forestry and plant ecology (positions of trees or plants in general), epidemiology (home locations of infected patients), zoology (burrows or nests of animals), geography (positions of human settlements, towns or cities), seismology (epicenters of earthquakes), materials science (positions of defects in industrial materials), astronomy (locations of stars or galaxies), computational neuroscience (spikes of neurons)</p>
<p>(Baddeley et al. 2006)</p>
<p>The first question of interest is typically whether the data exhibits complete spatial randomness (realization of spatial Poisson process) as opposed to exhibiting either spatial aggregation (clustering) or spatial inhibition (repulsion/regular).</p>
</div>
</div>
<div id="resources" class="section level1">
<h1>Resources</h1>
<p>Baddeley, A., Gregori, P., Mateu, J., Stoica, R., and Stoyan, D., editors (2006). Case Studies in Spatial Point Pattern Modelling, Lecture Notes in Statistics No. 185. Springer, New York. ISBN 0-387-28311-0.</p>
<p>Baddeley, A., Rubak, E., and Turner, R. (2015). Spatial Point Patterns Methodology and Applications with R. Chapman and Hall/CRC; 1st edition.</p>
<p><a href="https://cran.r-project.org/web/packages/spatstat/spatstat.pdf" class="uri">https://cran.r-project.org/web/packages/spatstat/spatstat.pdf</a></p>
<p><a href="http://spatstat.org/" class="uri">http://spatstat.org/</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
