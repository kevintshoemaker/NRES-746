<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Weylin Gilbert and Cara Piske" />


<title>Spatial Autocorrelation</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">NRES 746</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Schedule
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="schedule.html">Course Schedule</a>
    </li>
    <li>
      <a href="Syllabus.pdf">Syllabus</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="INTRO.html">Introduction to NRES 746</a>
    </li>
    <li>
      <a href="LECTURE1.html">Why focus on algorithms?</a>
    </li>
    <li>
      <a href="LECTURE2.html">Working with probabilities</a>
    </li>
    <li>
      <a href="LECTURE3.html">The Virtual Ecologist</a>
    </li>
    <li>
      <a href="LECTURE4.html">Likelihood</a>
    </li>
    <li>
      <a href="LECTURE5.html">Optimization</a>
    </li>
    <li>
      <a href="LECTURE6.html">Bayesian #1: concepts</a>
    </li>
    <li>
      <a href="LECTURE7.html">Bayesian #2: mcmc</a>
    </li>
    <li>
      <a href="LECTURE8.html">Model Selection</a>
    </li>
    <li>
      <a href="LECTURE9.html">Performance Evaluation</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lab exercises
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="LAB_Instructions.html">Instructions for Labs</a>
    </li>
    <li>
      <a href="FINALPROJ.html">Final project overview</a>
    </li>
    <li>
      <a href="LAB3demo.html">Lab 3: Likelihood (intro)</a>
    </li>
    <li>
      <a href="LAB5.html">Lab 5: Model selection (optional)</a>
    </li>
    <li>
      <a href="FigureDemo.html">Demo: Figures in R</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Student-led topics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="LECTURE10.html">Machine Learning</a>
    </li>
    <li>
      <a href="spatial_autocorrelation.html">Spatial Autocorrelation</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data sets
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TreeData.csv">Tree Data</a>
    </li>
    <li>
      <a href="ReedfrogPred.csv">Reed Frog Predation Data</a>
    </li>
    <li>
      <a href="ReedfrogFuncresp.csv">Reed Frog Func Resp</a>
    </li>
  </ul>
</li>
<li>
  <a href="Links.html">Links</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Spatial Autocorrelation</h1>
<h4 class="author">Weylin Gilbert and Cara Piske</h4>
<h4 class="date">Fall 2021</h4>

</div>


<pre class="r"><code># Import necessary packages
library(&quot;rgdal&quot;,warn.conflicts = FALSE)
options(&quot;rgdal_show_exportToProj4_warnings&quot;=&quot;none&quot;)
library(&quot;sp&quot;)
library(&quot;raster&quot;)
#library(&quot;spatstats&quot;)
library(&quot;gstat&quot;)
library(dplyr, quietly = T, verbose =F)
library(mosaic,quietly = T, verbose =F)
# load the raster, sp, and rgdal packages
library(raster)
library(sp)
library(rgdal)
library(ggfortify)
library(tseries)
library(forecast)
#library(imager) # https://www.xquartz.org/
library(&quot;usdm&quot;)
library(plotrix)
library(png)
library(nlme)</code></pre>
<div id="an-intro-to-spatial-autocorrelation" class="section level1">
<h1>An Intro to Spatial Autocorrelation</h1>
<p>Here is the download link for the R script for this lecture: <a href="spatial_autocorrelation.R">spatial autocorrelation script</a></p>
<p><strong>Correlation</strong> is used to determine the relationship between two variables.</p>
<ul>
<li>Example: Let variables f and g be evaluated with respect to variable x<br />
</li>
<li>Correlation can be either positive or negative.<br />
</li>
<li>Positive correlation: As f(x) increases, g(x) increases<br />
</li>
<li>Negative correlation: As f(x) increases, g(x) decreases.<br />
</li>
<li>Most intuitive way to examine relationships between variables in science</li>
</ul>
<p>Reminder… correlation analysis relies on several assumptions:</p>
<ul>
<li>linearity between f(x) and g(x)<br />
</li>
<li>independence between f(x) and g(x)<br />
</li>
<li>large sample size<br />
</li>
<li>no relationship between variables and one of its components<br />
</li>
<li>homoscedastity</li>
</ul>
<p><strong>Autocorrelation</strong> is the extent to which a variable varies in conjunction with an offset version of itself.</p>
<div id="temporal-autocorrelation" class="section level2">
<h2>Temporal Autocorrelation</h2>
<p>It can be helpful to think of autocorrelation using standard time-series examples. Time-series show temporal autocorrelation when observations are closely correlated within a time-step (i.e. they don’t display temporal independence).</p>
<pre class="r"><code># Load in the Mauna Loa CO2 data
CO2 &lt;-  co2
# Plot the data
plot.ts(CO2, xlab = &quot;Year&quot;, ylab = &quot;CO2 Concentrations (ppm)&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>CO2 is additive with a positive trend through time with an added seasonal effect.</p>
<p>We can decompose the time series using the “decompose” function, which stores seasonal, trend, and irregular components.</p>
<div id="autocorrelation" class="section level3">
<h3>Autocorrelation</h3>
<p>To look at the autocorrelation of CO2, we shift the CO2 by one time step (one day)</p>
<pre class="r"><code>decomposeCO2 &lt;- decompose(co2,&quot;additive&quot;)
autoplot(decomposeCO2)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>The autocorrelation function (ACF) tests for stationarity and shows the correlation between the residuals of an observation and a time-lagged observation (varied magnitude of a time offset with itself). For example, the first sample shows a lag of 0, indicating there is no time offset. We are correlating each value with itself! So, the ACF = 1. At lag = 1, the original CO2 is compared to a new dataset equal to the original shifted by t-1 month. This continues until a lag of 100 months. We can see that as time increases, the ACF decreases, or as time increases observations become less and less similar. We can also see the seasonality here.</p>
<pre class="r"><code>ggAcf(CO2, lag=100)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>We can see that trends it’s important to control for trends and seasonality in time-series analyses. This is also true of spatial analyses.</p>
</div>
</div>
</div>
<div id="spatial-autocorrelation" class="section level1">
<h1>Spatial Autocorrelation</h1>
<p><strong>“Everything is related to everything else, but near things are more related than distant things.” - Waldo R. Tobler’s stated in the first law of geography</strong></p>
<p>Similar to temporal autocorrelation, spatial autocorrelation is the measurement of the potential tendency for similar values to cluster based on proximity. This, too complicates statistical analyses that rely on assumptions of independence of residuals. As a reminder, violations of independence negate the Central Limit Theorem, leading to an underestimation of the error sum of squares and an inflated test statistic. Residuals, thus, are a tool for investigating variation that may exist beyond primary predictors. If data is spatially autocorrelated, residuals can provide insight into the magnitude and location of spatially dependent observations. In summary, statistically, spatial autocorrelation is viewed as a loss of information.</p>
<p>Positive spatial autocorrelation - if a large value is observed at point A, large values will also be observed at the neighboring points.</p>
<p>Negative spatial autocorrelation - if a large value is observed at point A, small values will be observed at the neighboring points. More rare than positive spatial autocorrelation in geographically constrained phenomena.</p>
<pre class="r"><code># example of negative spatial autocorrelation
image(rbind(c(1,0,1),c(0,1,0),c(1,0,1),c(0,1,0),c(1,0,1),c(0,1,0),c(1,0,1),c(0,1,0)))</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code>image(rbind(c(1,1,0),c(1,1,0),c(0,0,0),c(0,0,0),c(0,0,0),c(0,1,1),c(0,1,1),c(0,1,1)))</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-6-2.png" width="672" /></p>
<p>When spatial heterogeneity of data increases, it can be hard to determine spatial autocorrelation through visual analytics.</p>
<p>Spatial autocorrelation is ubiquitious in ecological and climatological data.</p>
<p>Examples of data that includes positive spatial autocorrelation:</p>
<ol style="list-style-type: decimal">
<li>Elevation<br />
</li>
<li>Disease clusters/infections<br />
</li>
<li>Election vote margins</li>
</ol>
<p>Examples of data that includes negative spatial autocorrelation:</p>
<ol style="list-style-type: decimal">
<li>Plant cover in water-limited ecosystems (absent hydraulic uplift)<br />
</li>
<li>Other ecological “competition” scenarios<br />
</li>
<li>Urban decay/suburban sprawl</li>
</ol>
<p><strong>Example: Burn Severity</strong></p>
<p>Wildfires typically exhibit spatial autocorrelation because of positive feedbacks dictated by geographical, climatological, and hydrological constraints. Fires create a “mosaic” throughout a landscape and burn preferentially depending on antecedent conditions and local topographic factors. Here, we use an example from the Empire Fire which burned a portion of Yosemite National Park in 2017. Overall, the fire was mixed-severity.</p>
<p><em>An intro to raster data</em> Raster data is gridded, geographically referenced data made up of a matrix of pixels, each containing a value and a spatial reference. Values are often derived from remote sensing technology. In this case, we are utilizing imagery collected by the Landsat satellite. Each pixel contains a spectral signature and, similar to vegetation indices (NDVI), the normalized burn ratio (NBR) takes advantage of spectral bands that highlight vegetation health (near infrared and shortwave infrared). Pre- and post-fire imagery is taken and the NBR is differenced between rasters to calculate the differenced Normalized Burn Ratio (dNBR).</p>
<p><strong>Value Representation</strong></p>
<ul>
<li>-500 -&gt; -101*: Enhanced Regrowth post-fire <br><br />
</li>
<li>-100 -&gt; 99*: Unburned <br><br />
</li>
<li>100 -&gt; 269*: Low Severity <br></li>
<li>270 -&gt; 439*: Moderate-low Severity <br></li>
<li>440 -&gt; 659*: Moderate-high Severity <br></li>
<li>660 -&gt; 1300*: High Severity <br></li>
</ul>
<pre class="r"><code># load raster in an R object called &#39;DEM&#39;
dNBR &lt;- raster(&quot;dNBR_empire.tif&quot;)
# get values
dNBR_values &lt;- getValues(dNBR)
# look at the raster attributes. 
dNBR</code></pre>
<pre><code>## class      : RasterLayer 
## dimensions : 306, 339, 103734  (nrow, ncol, ncell)
## resolution : 30, 30  (x, y)
## extent     : -2045415, -2035245, 1874025, 1883205  (xmin, xmax, ymin, ymax)
## crs        : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs 
## source     : dNBR_empire.tif 
## names      : dNBR_empire 
## values     : -104, 1013  (min, max)</code></pre>
<pre class="r"><code># show the distribution of values in the raster
dNBR_min &lt;- min(dNBR_values, na.rm = TRUE)
dNBR_max &lt;- max(dNBR_values, na.rm = TRUE)
dNBR_mean &lt;- mean(dNBR_values, na.rm = TRUE)
dNBR_sd &lt;-  sd(dNBR_values, na.rm = TRUE)
h&lt;-hist(dNBR_values, breaks=seq(dNBR_min,dNBR_max,length = 40), 
        col=rev(terrain.colors(40)), xlab=&quot;difference Normalized Burn Ratio&quot;,
        main=&quot;&quot;,
        #xlim=my.xlim, 
        #ylim=c(0,0.001599), 
        freq=FALSE) 
xfit&lt;-seq(dNBR_min,dNBR_max,length=100) 
yfit&lt;-dnorm(xfit,mean=dNBR_mean,sd=dNBR_sd) 
lines(xfit, yfit, col=&quot;black&quot;, lwd=2)
boxplot(dNBR_values, horizontal=TRUE,  outline=TRUE,  axes=FALSE,at=0.0001,
        ylim=c(dNBR_min, dNBR_max), col = &quot;white&quot;, add = TRUE, boxwex=0.0002)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<pre class="r"><code># add a color map with 5 colors
col=terrain.colors(5)
# plot data
plot(dNBR, col=col, main=&quot;NdBR&quot;, legend = TRUE)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>This is a lot of data (too much for the R functions to handle), so it can be helpful to subset. The chosen region has relatively low variability in aspect, slope, and elevation.</p>
<pre class="r"><code># Zoom into a smaller sample
x_coord &lt;- c(-2038320,  -2036880,  -2036880, -2038320) # define cropping extent
y_coord &lt;- c(1880790, 1880790, 1879590, 1879590)
xym &lt;- cbind(x_coord, y_coord) 
p = Polygon(xym) # create a polygon with cropping extent
ps = Polygons(list(p),1)
sps = SpatialPolygons(list(ps))
#crop the raster
dNBR_crop &lt;- crop(dNBR, xym)</code></pre>
<pre class="r"><code># plot with new cropping extent
# add a color map with 5 colors
col=terrain.colors(5)
# add breaks to the colormap (6 breaks = 5 segments)
brk &lt;- c(1, 2, 3, 4, 5)
plot(dNBR, col=col, main=&quot;differenced Normalized Burn Ratio&quot;, legend = TRUE) 
lines(sps,  col= &quot;red&quot;, lwd = 3) # add cropping extent</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code># save values to variable
dNBR_cp_values &lt;-  getValues(dNBR_crop)</code></pre>
<pre class="r"><code># plot only the cropped section
dNBR_cp_min &lt;- min(dNBR_cp_values, na.rm = TRUE)
dNBR_cp_max &lt;- max(dNBR_cp_values, na.rm = TRUE)
dNBR_cp_mean &lt;- mean(dNBR_cp_values, na.rm = TRUE)
dNBR_cp_sd &lt;-  sd(dNBR_cp_values, na.rm = TRUE)
h&lt;-hist(dNBR_cp_values, breaks=seq(dNBR_cp_min,dNBR_cp_max,length = 40), 
        col=rev(terrain.colors(40)), xlab=&quot;difference Normalized Burn Ratio&quot;,
        main=&quot;&quot;,
        #xlim=my.xlim, 
        #ylim=c(0,0.001599), 
        freq=FALSE) 
xfit&lt;-seq(dNBR_cp_min,dNBR_cp_max,length=100) 
yfit&lt;-dnorm(xfit,mean=dNBR_cp_mean,sd=dNBR_cp_sd) 
lines(xfit, yfit, col=&quot;black&quot;, lwd=2)
boxplot(dNBR_cp_values, horizontal=TRUE,  outline=TRUE,  axes=FALSE,at=0.0001,
        ylim=c(dNBR_cp_min, dNBR_cp_max), col = &quot;white&quot;, add = TRUE, boxwex=0.0002)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r"><code># zoom into a smaller sample
# add a color map with 5 colors
col=terrain.colors(5)

#plot(dNBR_crop, col=col, breaks=brk, main=&quot;NdBR&quot;, legend = FALSE)
plot(dNBR_crop, col=col, main=&quot;NdBR&quot;, legend = TRUE) </code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>Visually, this plot indicates high spatial autocorrelation with clumping patterns in the burn severity data. We can test for spatial autocorrelation in a few ways.</p>
<ol style="list-style-type: decimal">
<li>Variogram plot</li>
<li>Moran’s Coefficient</li>
</ol>
<div id="variogram" class="section level3">
<h3>Variogram</h3>
<p>A variogram plot is used to visualize spatial autocorrelation and quantify where our variance reaches a critical threshold. It is a function of the difference between observations (variance) over a distance.</p>
<p><em>Null hypothesis</em> is that there is no spatial autocorrelation, or that all observations are independent.</p>
<p>The equation:</p>
<p><span class="math display">\[Y(h) = \frac{1}{2N(h)} (\sum_{\alpha =1}^{N(h)} (z(u_\alpha) -z(u_\alpha + h))^2 \]</span></p>
<p>Variogram (in this case semi-variogram) is 1/2 the average squared difference of values separated by the lag vector.</p>
<p><strong>Attribute Similarity</strong> <br></p>
<p>Dissimilarity metric -&gt; squared difference between an observation and a neighboring observation <br></p>
<ul>
<li>similar values will have smaller square differences, dissimilar values will have large square differences</li>
</ul>
<p><strong>Locational Similarity</strong></p>
<div id="what-is-a-neighbor" class="section level4">
<h4>What is a neighbor?</h4>
<p>What is the relationship between an observation and the observations around it? Well, we first have to determine how we define surrounding observations.</p>
<p><strong>Contiguity Based Neighbors</strong> spatial contiguity determined based on adjacency</p>
<p><strong>Distance Based Neighbors</strong> spatial neighbors based on a distance threshold… distance measured from the center of the pixel.</p>
<pre class="r"><code># convert raster to matrix
dNBR_mat &lt;-  as.matrix(dNBR_crop)
dNBR_mat2 &lt;-  as.matrix(dNBR)

# choose a point... we&#39;ll choose a point in the middle of the matrix
dNBR_midCoor &lt;- c((-2036865-(-2038305))/2 + -2038305, (1880775-1879575)/2+1879575)
dNBR_midPt &lt;- dNBR_mat[20,25]
# plot point 
col=terrain.colors(5)
plot(dNBR_crop, col=col, main=&quot;Contiguity Rook - sharing a boarder&quot;, legend = FALSE) 
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2], pch = 15,col = &quot;red&quot;)
points(x = dNBR_midCoor[1]+30, y = dNBR_midCoor[2],pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1]-30, y = dNBR_midCoor[2], pch = 0,col = &quot;blue&quot;)
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2]+30, pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2]-30, pch = 0, col = &quot;blue&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<pre class="r"><code>plot(dNBR_crop, col=col, main=&quot;Contiguity Queen - sharing a point&quot;, legend = FALSE) 
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2], pch = 15, col = &quot;red&quot;)
points(x = dNBR_midCoor[1]+30, y = dNBR_midCoor[2], pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1]-30, y = dNBR_midCoor[2], pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2]+30, pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2]-30, pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1]+30, y = dNBR_midCoor[2]+30, pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1]-30, y = dNBR_midCoor[2]-30, pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1]-30, y = dNBR_midCoor[2]+30, pch = 0, col = &quot;blue&quot;)
points(x = dNBR_midCoor[1]+30, y = dNBR_midCoor[2]-30, pch = 0, col = &quot;blue&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-15-2.png" width="672" /></p>
<pre class="r"><code>plot(dNBR_crop, col=col, main=&quot;Distance Based&quot;, legend = FALSE) 
points(x = dNBR_midCoor[1], y = dNBR_midCoor[2], pch = 15,col = &quot;red&quot;)
draw.circle(dNBR_midCoor[1],dNBR_midCoor[2],radius = 120, border = &quot;blue&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-15-3.png" width="672" /></p>
<pre class="r"><code># Convert raster to point values
dNBR_pt &lt;- rasterToPoints(dNBR_crop)
# we can see that we now have a matrix with x = lat, y = lon, and the dNBR classes
head(dNBR_pt)</code></pre>
<pre><code>##             x       y dNBR_empire
## [1,] -2038290 1880760         291
## [2,] -2038260 1880760         304
## [3,] -2038230 1880760         240
## [4,] -2038200 1880760         223
## [5,] -2038170 1880760         315
## [6,] -2038140 1880760         316</code></pre>
<pre class="r"><code>dNBR_var=usdm::Variogram(dNBR_crop)
plot(dNBR_var, ylab = &quot;Y(h)&quot;, xlab = &quot;Lag Distance (h), meters&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
</div>
<div id="brute-force-variogram" class="section level3">
<h3>Brute Force Variogram</h3>
<p>First we calculate the Y(h) for one lag distance. The minimum distance cannot exceed the spatial resolution. If we look at the dNBR_crop, we see that that spatial resolution is 30 meters. If we start by simply looking at the lag distance in the x direction, we’re only interested in calculating our Y(h) over each column. The maximum distance, then, would be 30*ncol.</p>
<pre class="r"><code>col=terrain.colors(5)
plot(dNBR_crop, col=col, main=&quot;NdBR&quot;, legend = TRUE)
points(dNBR_pt[1,1],dNBR_pt[1,2],pch = 16, col=&quot;red&quot;); points(dNBR_pt[5,1],dNBR_pt[1,2],pch = 16, col=&quot;red&quot;)
segments(dNBR_pt[1,1], dNBR_pt[1,2], dNBR_pt[5,1],dNBR_pt[1,2], col = &quot;red&quot; )
points(dNBR_pt[20,1],dNBR_pt[900,2],pch = 16, col=&quot;red&quot;)
points(dNBR_pt[25,1],dNBR_pt[900,2],pch = 16, col=&quot;red&quot;)
segments(dNBR_pt[20,1], dNBR_pt[900,2], dNBR_pt[25,1],dNBR_pt[900,2], col = &quot;red&quot; )
points(dNBR_pt[40,1],dNBR_pt[1920,2],pch = 16, col=&quot;red&quot;)
points(dNBR_pt[45,1],dNBR_pt[1920,2],pch = 16, col=&quot;red&quot;)
segments(dNBR_pt[40,1], dNBR_pt[1920,2], dNBR_pt[45,1],dNBR_pt[1920,2], col = &quot;red&quot; )</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>We can observe how a value changes when shifted by a specified distance and observe that when the lag distance (h) is small, the relationship is relatively linear with little variance. As the lag distance increases, we see more variance.</p>
<pre class="r"><code>lag_dis &lt;- 30 # the lag distance we want to test
pixel_dis &lt;-  lag_dis/30 # each pixel represents 30 m so this is the number of pixels between desired pixel and lagged pixel
final_pt &lt;- ncol(dNBR_crop) - pixel_dis
variogram_x &lt;- matrix(nrow = nrow(dNBR_mat), ncol = (final_pt))
correlation_vals &lt;- matrix(nrow = nrow(dNBR_mat),ncol = final_pt)
# let&#39;s look at the first row
for (i in 1:nrow(dNBR_mat)){
  for(j in 1:final_pt){
    variogram_x[i,j] &lt;-  dNBR_mat[i,j+pixel_dis] - dNBR_mat[i,j]
    correlation_vals[i,j] &lt;- dNBR_mat[i,j+pixel_dis]
  }
}
n_pairs &lt;- length(variogram_x)
variogram_x2 &lt;-  1/(2*n_pairs)*(sum(variogram_x^2))
plot(dNBR_mat[,1:final_pt], correlation_vals, xlab = &quot;z(u_a)&quot;, ylab = &quot;z(u_a +h)&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<pre class="r"><code>spatial_res &lt;- 30
lag_m &lt;- seq(spatial_res,(nrow(dNBR_mat)*spatial_res-spatial_res), by = 30)
var_num &lt;- 1
variogram &lt;- matrix(nrow = length(lag_m), ncol = 1)
for (lag_dist in lag_m){
  lag_dis &lt;- lag_dist # the lag distance we want to test
  pixel_dis &lt;-  lag_dis/30 # each pixel represents 30 m so this is the number of pixels between desired pixel and lagged pixel
  final_pt &lt;- ncol(dNBR_crop) - pixel_dis
  variogram_x &lt;- matrix(nrow = nrow(dNBR_mat), ncol = (final_pt))
  for (i in 1:nrow(dNBR_mat)){
    for(j in 1:final_pt){
    variogram_x[i,j] &lt;-  dNBR_mat[i,j+pixel_dis] - dNBR_mat[i,j]
    }
  }
  n_pairs &lt;- length(variogram_x)
  variogram_x2 &lt;-  1/(2*n_pairs)*(sum(variogram_x^2))
  variogram[var_num] &lt;- variogram_x2
  var_num &lt;- var_num + 1
}</code></pre>
<pre class="r"><code>plot(lag_m, variogram, xlim=c(0,600), xlab = &quot;Lag Distance (h), m&quot;, ylab = &quot;Y(h) Variogram&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Semi-variance is typically reported because it allows us to directly relate the covariance function to the variogram. <span class="math display">\[C_x(h) = \sigma^2 - y_x(h)  \]</span></p>
<pre class="r"><code># calculate variance
sigma_s  &lt;- apply(dNBR_mat, MARGIN = 1, FUN = function(x) (x - mean(dNBR_mat))^2)
sigma_s &lt;- sum(sigma_s) / (length(dNBR_mat)-1)</code></pre>
<pre class="r"><code># standardize Y(h) by the variance
variogram_sig &lt;- variogram/sigma_s
plot(lag_m, variogram_sig, xlim=c(0,600), xlab = &quot;Lag Distance (h), m&quot;, ylab = &quot;Y(h) Variogram&quot;)
abline(h = sigma_s/sigma_s)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>The distance where our variogram = total variance (sill), represents the distance where spatial autocorrelation no longer impacts variability. This can be thought of as the distance at which we no longer have information about a starting point. This is relevant in contamination studies, for examples, where we might want to know where we can sample in order to tell information about the contamination source.</p>
<pre class="r"><code># standardize Y(h) by the variance
variogram_sig &lt;- variogram/sigma_s
plot(lag_m, variogram_sig, xlim=c(0,800), xlab = &quot;Lag Distance (h), m&quot;, ylab = &quot;Y(h) Variogram&quot;)
abline(h = sigma_s/sigma_s)
abline(v = 390, lty = 2)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>We can then repeat this process in the y-direction.</p>
<pre class="r"><code>spatial_res &lt;- 30
lag_m &lt;- seq(spatial_res,(nrow(dNBR_mat)*spatial_res-spatial_res), by = 30)
var_num &lt;- 1
variogramY &lt;- matrix(nrow = length(lag_m), ncol = 1)
for (lag_dist in lag_m){
  lag_dis &lt;- lag_dist # the lag distance we want to test
  pixel_dis &lt;-  lag_dis/30 # each pixel represents 30 m so this is the number of pixels between desired pixel and lagged pixel
  final_pt &lt;- nrow(dNBR_crop) - pixel_dis
  variogram_y &lt;- matrix(nrow = final_pt, ncol = ncol(dNBR_mat))
  for (j in 1:ncol(dNBR_mat)){
    for(i in 1:final_pt){
    variogram_y[i,j] &lt;-  dNBR_mat[i+pixel_dis,j] - dNBR_mat[i,j]
    }
  }
  n_pairs &lt;- length(variogram_y)
  variogram_y2 &lt;-  1/(2*n_pairs)*(sum(variogram_y^2))
  variogramY[var_num] &lt;- variogram_y2
  var_num &lt;- var_num + 1
}</code></pre>
<pre class="r"><code># standardize Y(h) by the variance
variogram_sig &lt;- variogram/sigma_s
plot(lag_m, variogram_sig, xlim=c(0,800), xlab = &quot;Lag Distance (h), m&quot;, ylab = &quot;Y(h) Variogram&quot;, col = &quot;blue&quot;)
points(lag_m, variogramY/sigma_s, xlim=c(0,800), xlab = &quot;Lag Distance (h), m&quot;, ylab = &quot;Y(h) Variogram&quot;, col = &quot;green&quot;)
abline(h = sigma_s/sigma_s)
abline(v = 390, lty = 2, col = &quot;blue&quot;)
abline(v = 510, lty = 2, col = &quot;green&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>The y-direction variogram does not reach the critical threshold (sill), this is considered zonal anisotropy.</p>
</div>
<div id="morans-number" class="section level2">
<h2>Moran’s Number</h2>
<pre class="r"><code># Let&#39;s simulate some further data to go with NdBR

# We can ensure the simulated data autocorrelates by designating an interpolation appropriately. 
set.seed(133)
vgm_sim &lt;- vgm(psil = 0.05, range = 100, model = &quot;Exp&quot;)
krige_sim &lt;- gstat(formula = z~1, locations = ~x+y, dummy = TRUE, beta = 1, model = vgm_sim, nmax = 100)

# We need a grid object for populating the simulated data
sample_grid &lt;- as(dNBR_crop, &#39;SpatialGridDataFrame&#39;)
sim_data &lt;- predict(krige_sim, newdata = sample_grid, nsim = 1)</code></pre>
<pre><code>## [using unconditional Gaussian simulation]</code></pre>
<pre class="r"><code>sim_raster &lt;- raster(sim_data)

plot(sim_raster, main = &quot;simulated raster data&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<pre class="r"><code>Moran(sim_raster)</code></pre>
<pre><code>## [1] 0.6765339</code></pre>
<pre class="r"><code># Now, let&#39;s do a linear regression between our two rasters and see whether the residuals autocorrelate. 

# First we need to ensure they share the same extent. 

sample_ext &lt;- extent(dNBR_crop)
#sample_ext
sim_ext &lt;- extent(sim_raster)
#sim_ext

setExtent(sim_raster, sample_ext)</code></pre>
<pre><code>## class      : RasterLayer 
## dimensions : 40, 48, 1920  (nrow, ncol, ncell)
## resolution : 30, 30  (x, y)
## extent     : -2038305, -2036865, 1879575, 1880775  (xmin, xmax, ymin, ymax)
## crs        : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs 
## source     : memory
## names      : sim1 
## values     : 0.2612599, 2.031264  (min, max)</code></pre>
<pre class="r"><code>extent(sim_raster) &lt;- extent(dNBR_crop)

# Regression models between rasters are facilitated by combining them in a RasterStack object. 

raster_stack &lt;- stack(dNBR_crop, sim_raster)
names(raster_stack)</code></pre>
<pre><code>## [1] &quot;dNBR_empire&quot; &quot;sim1&quot;</code></pre>
<pre class="r"><code># We then need to convert this to a dataframe so it will be accepted by the lm() function. 

sample_data &lt;- data.frame(na.omit(values(raster_stack)))

# Now we can generate our regression model. 

#lm_sample &lt;- lm(sim_raster, dNBR_crop)</code></pre>
<pre class="r"><code>sample_points_dNBR &lt;- rasterToPoints(dNBR_crop)
sample_points_sim &lt;- rasterToPoints(sim_raster)

subset &lt;- sample(1:333, 100)

sample_points_dNBR &lt;- sample_points_dNBR[subset,]
sample_points_sim &lt;- sample_points_sim[subset]

sample_data_frame &lt;- data.frame(sample_points_dNBR, sample_points_sim)
coordinates(sample_data_frame) &lt;- coordinates(sample_points_dNBR)

#sample_data_frame$

#sample_spdf &lt;- sample_data_frame
#sample_spdf</code></pre>
<pre class="r"><code># What implications does all of this have for regression analyses? 

lm1 &lt;- lm(sample_points_sim ~ dNBR_empire, data = sample_data_frame)

lm1_raster &lt;- predict(raster_stack, lm1)
plot(lm1_raster, main = &quot;raster prediction from LM1&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<pre class="r"><code>print(&quot;Moran&#39;s I value predicted from LM1&quot;)</code></pre>
<pre><code>## [1] &quot;Moran&#39;s I value predicted from LM1&quot;</code></pre>
<pre class="r"><code>Moran(lm1_raster)</code></pre>
<pre><code>## [1] 0.8917046</code></pre>
<pre class="r"><code>lm1_resid &lt;- raster_stack$sim1 - lm1_raster
plot(lm1_resid, &quot;residuals from LM1&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-29-2.png" width="672" /></p>
<pre class="r"><code>print(&quot;Moran&#39;s I value for redisuals from LM1&quot;)</code></pre>
<pre><code>## [1] &quot;Moran&#39;s I value for redisuals from LM1&quot;</code></pre>
<pre class="r"><code>Moran(lm1_resid)</code></pre>
<pre><code>## [1] 0.8917192</code></pre>
</div>
<div id="accounting-for-spatial-autocorrelation-in-analysis" class="section level2">
<h2>Accounting for Spatial Autocorrelation in Analysis</h2>
<p>We now know that our data has some troublesome spatial autocorrelation. What can we do about it? Below we will briefly present some methods for accounting for spatial autocorrelation.</p>
<p><strong>1. Rescaling or Resampling</strong></p>
<p><strong>2. Least Squares</strong></p>
<div id="rescaling-or-resampling" class="section level3">
<h3>1. Rescaling or Resampling</h3>
<p>Spatial autocorrelation is an issue of scale. Aggregation is one potential solution.</p>
<pre class="r"><code># rescale raster by a factor of 2
dNBR_2x &lt;- aggregate(dNBR_crop, fact = 2)
# look at attributes
dNBR_2x</code></pre>
<pre><code>## class      : RasterLayer 
## dimensions : 20, 24, 480  (nrow, ncol, ncell)
## resolution : 60, 60  (x, y)
## extent     : -2038305, -2036865, 1879575, 1880775  (xmin, xmax, ymin, ymax)
## crs        : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs 
## source     : memory
## names      : dNBR_empire 
## values     : -37, 859.25  (min, max)</code></pre>
<pre class="r"><code>hist(dNBR_2x)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<pre class="r"><code># add a color map with 5 colors
col=terrain.colors(5)
plot(dNBR_2x, col=col, main=&quot;NdBR&quot;, legend = TRUE) </code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<pre class="r"><code>dNBR_2x_mat &lt;-as.matrix(dNBR_2x)
sigma_s  &lt;- apply(as.matrix(dNBR_2x), MARGIN = 1, FUN = function(x) (x - mean(as.matrix(dNBR_2x)))^2)
sigma_s &lt;- sum(sigma_s) / (length(as.matrix(dNBR_2x))-1)
# plot the variogram
dNBR_var_2x=usdm::Variogram(dNBR_2x)
plot(dNBR_var_2x, ylab = &quot;Y(h)&quot;, xlab = &quot;Lag Distance (h), meters&quot;)
abline(h=sigma_s)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
<pre class="r"><code>Moran(dNBR_2x)</code></pre>
<pre><code>## [1] 0.7638022</code></pre>
<pre class="r"><code>dNBR_resamp &lt;- resample(dNBR_mat, R = 100, replace = TRUE)
dNBR_resamp_raster &lt;- raster(
             dNBR_resamp,
             xmn=-2038305, xmx=-2036865,
             ymn=1879575, ymx=1880775, 
             crs=CRS(&quot;+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs&quot;)
            )

# plot 
# add a color map with 5 colors
col=terrain.colors(5)
plot(dNBR_resamp_raster, col=col, main=&quot;NdBR&quot;, legend = TRUE)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<pre class="r"><code>dNBR_2x_mat &lt;-as.matrix(dNBR_resamp_raster)
sigma_s  &lt;- apply(as.matrix(dNBR_resamp_raster), MARGIN = 1, FUN = function(x) (x - mean(as.matrix(dNBR_resamp_raster)))^2)
sigma_s &lt;- sum(sigma_s) / (length(as.matrix(dNBR_resamp_raster))-1)
# plot the variogram
dNBR_var_2x=usdm::Variogram(dNBR_resamp_raster)
plot(dNBR_var_2x, ylab = &quot;Y(h)&quot;, xlab = &quot;Lag Distance (h), meters&quot;)
abline(h=sigma_s)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<pre class="r"><code>Moran(dNBR_resamp_raster)</code></pre>
<pre><code>## [1] 0.497763</code></pre>
</div>
<div id="least-squares-modeling" class="section level3">
<h3>2. Least Squares Modeling</h3>
<pre class="r"><code>gls1 &lt;- gls(sample_points_sim ~ dNBR_empire, data = sample_data_frame)

gls1_raster &lt;- predict(raster_stack, gls1)
plot(gls1_raster, main = &quot;raster prediction from GLS1&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<pre class="r"><code>print(&quot;Moran&#39;s I value predicted from GLS1&quot;)</code></pre>
<pre><code>## [1] &quot;Moran&#39;s I value predicted from GLS1&quot;</code></pre>
<pre class="r"><code>Moran(gls1_raster)</code></pre>
<pre><code>## [1] 0.8917046</code></pre>
<pre class="r"><code>gls1_resid &lt;- raster_stack$sim1 - gls1_raster
plot(gls1_resid, &quot;residuals from GLS1&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-35-2.png" width="672" /></p>
<pre class="r"><code>print(&quot;Moran&#39;s I value for redisuals from GLS1&quot;)</code></pre>
<pre><code>## [1] &quot;Moran&#39;s I value for redisuals from GLS1&quot;</code></pre>
<pre class="r"><code>Moran(gls1_resid)</code></pre>
<pre><code>## [1] 0.8917192</code></pre>
<pre class="r"><code># Notice that this doesn&#39;t actually work differently from the LM, statistically
# To get the GLS method to really work, one needs to specify a correlation geometry. </code></pre>
<pre class="r"><code># Linear Correlation Geometry


gls4 &lt;- gls(sample_points_sim ~ dNBR_empire, data = sample_data_frame, correlation = corLin(form = ~y+x, nugget = TRUE), method = &quot;REML&quot;)

gls4_raster &lt;- predict(raster_stack, gls4)
plot(gls4_raster, main = &quot;raster prediction from GLS4, Linear correlation&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<pre class="r"><code>gls4_resid &lt;- raster_stack$sim1 - gls4_raster
plot(gls4_resid, &quot;residuals from GLS4&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-36-2.png" width="672" /></p>
<pre class="r"><code>print(&quot;Moran&#39;s I value for redisuals from GLS4&quot;)</code></pre>
<pre><code>## [1] &quot;Moran&#39;s I value for redisuals from GLS4&quot;</code></pre>
<pre class="r"><code>Moran(gls4_resid)</code></pre>
<pre><code>## [1] 0.8910359</code></pre>
<pre class="r"><code># Expontential Correlation Geometry


gls6 &lt;- gls(sample_points_sim ~ dNBR_empire, data = sample_data_frame, correlation = corExp(form = ~y+x, nugget = TRUE), method = &quot;REML&quot;)

gls6_raster &lt;- predict(raster_stack, gls6)
plot(gls6_raster, main = &quot;raster prediction from GLS6, Exponential correlation&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-36-3.png" width="672" /></p>
<pre class="r"><code>gls6_resid &lt;- raster_stack$sim1 - gls6_raster
plot(gls6_resid, &quot;residuals from GLS6&quot;)</code></pre>
<p><img src="spatial_autocorrelation_files/figure-html/unnamed-chunk-36-4.png" width="672" /></p>
<pre class="r"><code>print(&quot;Moran&#39;s I value for redisuals from GLS6, Exponential correlation&quot;)</code></pre>
<pre><code>## [1] &quot;Moran&#39;s I value for redisuals from GLS6, Exponential correlation&quot;</code></pre>
<pre class="r"><code>Moran(gls6_resid)</code></pre>
<pre><code>## [1] 0.8910359</code></pre>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
